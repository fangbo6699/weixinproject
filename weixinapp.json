{"title": "微信小程序开发，如何优雅地兼容 ", "author": "Rolan", "time": "2018-9-19 00:02", "content": "关于单个 API 如何兼容，微信官方提供了兼容文档，因此我们这里不再赘述。下面主要讨论在整个项目如何优雅地处理兼容问题。问题如果在每处需要兼容的地方都写上一堆兼容相关的代码，随着代码量增加，会出现以下问题：代码难以阅读兼容方案有变动时，需要改动多处随着时间推移，你的代码才是最需要并且是最难兼容的思考最理想的情况是不需要任何兼容处理，因此可以反推出兼容性处理的代码并不是代码正常流程中的一部分，基于此：兼容的细节不必暴露兼容的方案应该统一兼容的方案可方便地变动解决方案1.将兼容方案隐藏，对外提供接口即可比如 wx.showLoading 是在 1.1.0 版本之后才提供的，对于之前的版本需要兼容。我们选择将其放在 show-loading.js 中，内部进行兼容性相关处理，并对外提供 showLoading 方法。这样调用者只需调用 showLoading 方法即可，不用考虑兼容性的问题，而且如果兼容的方式有变动，只需改动 show-loading.js 一处即可。2.兼容的处理还有共性可以抽象兼容处理多了之后我们会发现，对兼容所做的处理无非两方面：支持该方法时，直接使用对应方法不支持该方法时，做一些兼容处理因此这种模式我们又可以抽离出来，这样做当然有一些好处：减少重复代码做一些共性的处理时，我们又只用改动一处（比如当不兼容官方 API 时加上对应统计，用于分析当前应用跨版本的情况）比如我们抽离出这样一个简单的 compatible.js 用于处理兼容时的共性问题：之前的 showLoading.js 我们可以这样写：简单吧 :)，这种写法的意思是兼容时正常展示 loading 即可，不兼容时则不展示。当然可能有完美主义者会觉得『怎么能不展示呢？我就是要展示！』 那么我们可以这样写：用 wx.showToast 伪造了一个 showLoading。3.文件组织兼容性的文件可能会越来越多，对于我这种有收拾的人，看到所有东西散乱地扔在一个抽屉里肯定是不能忍的...因此我们可以多用几个小盒子把它们分门别类地装起来。小盒子怎么选呢？其实官方已经给出了答案，官方 API 是按照不同的功用分组的，因此我们拿分组当『盒子』即可。最终的文件组织像这样："}
{"title": "微信小程序开发之从“跳伞”到“吃鸡” ", "author": "Rolan", "time": "2018-7-26 00:28", "content": "写在前边微信小程序随着官方开放越多越多的接口，也是变的越来越火了，越来越多的企业已经开始布局小程序生态。所以，对于我们开发者来说，掌握小程序开发显得分外重要。如果点亮了该技能，那么离升职加薪赢取白富美的日子就又近了一步啦！关于我笔者算是一个野生的程序猿吧，没有什么大厂经验，搞开发就是一个字，干！从不来虚的。因此，随性的性格造就了我全栈（一窍不通）的本事，做项目那就是一把抓，前后端全包，什么前后端撕逼的问题统统没有了，哈哈哈（想想心里还有点小激动）。不过本文笔者只重点分享小程序开发相关的东西，想了解后端的话，可以坐等我下一次的分享哈哈哈（可能会遥遥无期）。准备工作话不多说，进入正题。现在开始分享我是怎么开发完一款小程序的。小程序的官方文档其实写的是很详细很清晰的，相比微信公众号的开发文档来说真的是非常非常的良心，所以开发前浏览一遍开发文档非常关键。下边我分享一下其他准备工作。1. 开发工具工欲善其事，必先利其器，首选的就是把开发环境给弄好咯，我推荐如下：开发工具官方微信开发者工具visio studio code调试工具官方微信开发者工具当然开发工具什么的只要自己习惯就好，我的推荐只是参考。笔者最后习惯是直接在官方的开发者工具上编辑加调试。2. 小程序配置这块的内容官方文档都有详细的教程，我就不多补充啦。总体来说就是需要去申请一个开发者账号，然后配置小程序的基本信息，比较值得重点说的就是小程序api的配置，官方要求必须是https。说到这里，如果读者你的api接口已经了https可以跳过了，如果不是，然后你也像笔者一样是全栈开发，那么笔者将告诉你如何快速让接口踏上https的航班。是的，没错， 就是它！Certbot在官网上选好http服务器和linux系统后，按照命令一个一个敲，就ok了，简直不要太简单。哈哈哈，至于想深入了解这个东东的话，可以去了解下Let's Encrypt开发总算可以正式的开始撸功能了！因为考虑到现在程序猿找对象是真的太难了，所以笔者撸的小程序是一个脱单交友的小程序（单身汪的福音哦），小程序页面也不多，核心就是让用户填写个人信息然后展示出来。是的，就是这么简单！授权登录小程序的授权登录其实可以看作是两件事情，授权和登录，这两者是可以单独分开处理的（个人观点，允许反驳）。授权对于授权，其实官方已经有讲到，就是换成微信内的授权询问，就是如下这个东西。这个微信授权的询问弹窗之前的版本中只要调用获取用户信息的api，是会自动弹出的，现在小程序做了调整需要自行通过按钮触发，所以这个很蛋疼。那么需要怎么去设计呢，这里也有两个方案，一个是做个单独的页面，另一个方案是做弹窗。个人建议是选方案一，因为这样可以把授权逻辑从页面逻辑里独立出来，方便所有页面渲染前调用。具体coding如下：在app.js中，判断是否已经授权，如果未授权则跳转到授权页面App({\r\n  onLaunch: function () {\r\n    ...\r\n    wx.getSetting({\r\n      success: res => {\r\n        if (res.authSetting['scope.userInfo']) {\r\n          // 已经授权，可以直接调用 getUserInfo 获取头像昵称，不会弹框\r\n          console.log('已经授权')\r\n        } else {\r\n              // 未授权，跳转到授权页面，必须要用reLauch进行跳转\r\n          wx.reLaunch({\r\n            url: '/pages/auth/index',\r\n          })\r\n          console.log('需要授权')\r\n        }\r\n      }\r\n    })\r\n  },在'pages/auth/index.wxml'页面中，使用button做授权按钮<button open-type=\"getUserInfo\" bindgetuserinfo=\"bindGetUserInfo\">微信账号授权登录</button>'pages/auth/index.js'中定义绑定的回调方法，重新跳转回上一页Page({\r\n  ...\r\n  // 点击授权后跳回首页\r\n  bindGetUserInfo (e) {\r\n    wx.reLaunch({ url: '../index/index' })\r\n    // 用户已经同意小程序使用获取用户信息功能，后续调用 wx.startRecord 接口不会弹窗询问\r\n  }\r\n})\r\n这样，一个授权逻辑就完成了。登录登录的目录其实是和后端交互，需要在服务器端存储当前用户的标识，以便用户下一次登录时服务器知道是谁登录了。做过微信公众号开发的朋友应该都知道，能承担这个作用的角色就是open_id了，所以要实现登录的话，其实就是需要获取当前用户的open_id，官方文档中是这么介绍的：1.小程序调用wx.login() 获取 临时登录凭证code ，并回传到开发者服务器。2.开发者服务器以code换取 用户唯一标识openid 和 会话密钥session_key。之后开发者服务器可以根据用户标识来生成自定义登录态，用于后续业务逻辑中前后端交互时识别用户身份。所以完成登录的前提就是需要后端提供一个接口，咱们把code传给后端就行了，剩下的工作就是后端去完成啦App({\r\n  onLaunch: function () {\r\n    // 授权判断\r\n    wx.getSetting({\r\n      success: res => {\r\n        if (res.authSetting['scope.userInfo']) {\r\n          // 已经授权，可以直接调用 getUserInfo 获取头像昵称，不会弹框\r\n          console.log('已经授权')\r\n        } else {\r\n              // 未授权，跳转到授权页面，必须要用reLauch进行跳转\r\n          wx.reLaunch({\r\n            url: '/pages/auth/index',\r\n          })\r\n          console.log('需要授权')\r\n        }\r\n      }\r\n    })\r\n  },\r\n  // 登录\r\n  wx.login({\r\n      success: res => {\r\n        // 发送 res.code 到后台换取 openId, sessionKey, unionId\r\n        if (res.code) {\r\n          api.post('/user/mplogin', { 'code': res.code }).then(res => {\r\n              wx.setStorageSync('access_token', res.access_token)\r\n          }).catch(error=>{\r\n            console.log(error)\r\n          })\r\n        } else {\r\n          console.log('登录失败！' + res.errMsg)\r\n        }\r\n      }\r\n    })这里需要多提的一点是关于会话维持的方案，就是如何让服务器端知道访问接口的是谁。笔者提供两个办法：通过wx.request()在header中强行组装cookie字符串，来实现传统浏览器上用cookie维持会话的效果使用access_token的方式，比如jwt笔者选择的是第二种，通过后端的登录接口返回token，然后将token存入Storage，然后在发起请求的时候将token封装到http请求体中。 两种方案都可行，读者们可根据自己情况自行实现。 由于wx.request()方法发起请求比较麻烦，还需要处理会话逻辑，所以建议读者们还是进行一次封装，下边贴上笔者的代码：在utils文件夹中创建request.js文件const domain = \"https://cdx.tyhub.com\"\r\nfunction GET(url, params) {\r\n  return request('GET', url, params)\r\n}\r\nfunction POST(url, params) {\r\n  return request('POST', url, params)\r\n}\r\nfunction request(method, url, params) {\r\n  return new Promise((resolve, reject) => {\r\n    wx.request({\r\n      url: domain + url,\r\n      data: params,\r\n      method: method, // OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT\r\n      header: {\r\n        'Content-Type': 'application/x-www-form-urlencoded',\r\n        'Authorization': 'bearer' + ' ' + wx.getStorageSync('access_token'),\r\n      },\r\n      success(res) {\r\n        if (res.data.code === 100) {\r\n          let resData = res.data.data\r\n          if (!resData) {\r\n            resData = ''\r\n          }\r\n          resolve(resData)\r\n        } else {\r\n          let err = {\r\n            code: res.data.code,\r\n            msg: res.data.msg\r\n          }\r\n          reject(err)\r\n        }\r\n      }\r\n    })\r\n  })\r\n}\r\n\r\nmodule.exports = {\r\n  get: GET,\r\n  post: POST\r\n}使用const api = require('../../utils/request')\r\n...\r\napi.post('/user/mplogin', { 'code': res.code }).then(res => {\r\n     wx.setStorageSync('access_token', res.access_token)\r\n }).catch(error=>{\r\n   console.log(error)\r\n })至此，登录逻辑便已完成，是不是觉得小程序开发也不过如此呢？由于篇幅有限，今天就分享到这啦，后续我将继续和看官们一起探究以下小程序开发的话题图片上传表单提交级联选择器的实现如何使用iconfont图标微信支付模板消息....欢迎笔者持续关注，也欢迎笔者私信告知我其他疑问，我尽量都一一分享，知无不言，言无不尽。不是结束的结语打波小小的广告，个人开发的找对象小程序“佛系处对象”已经顺利上线，欢迎笔者看官们扫码体验，如果脱单了记得通知我哟！最后祝大家在事业和爱情的“战场中都能脱颖而出，顺利吃鸡！"}
{"title": "[微信小程序开发]如何去掉或隐藏小程序顶部栏navigationBar ", "author": "Rolan", "time": "2018-7-30 00:12", "content": "小程序全局配置app.josn增加选项：\"navigationStyle\": \"custom\",具体如下：原生小程序开发打开 app.json：{    \"pages\": [        \"pages/index/index\",        \"pages/logs/index\"    ],    \"window\": {        \"backgroundTextStyle\": \"light\",        \"navigationBarBackgroundColor\": \"#000\",        \"navigationStyle\": \"custom\",        \"navigationBarTitleText\": \"WeChat\"    }}mpvue方式开发小程序>打开 /src/main.js：export default {  config: {    pages: [      'pages/logs/main',      '^pages/index/main'　　],    window: {      backgroundTextStyle: 'light',      navigationBarBackgroundColor: '#666',      navigationStyle: 'custom',      navigationBarTitleText: 'WeChat',      navigationBarTextStyle: '#fff',      enablePullDownRefresh: false,      disableScroll: true    }  }}"}
{"title": "微信小程序开发--『狗蛋TV』 ", "author": "Rolan", "time": "2018-5-17 00:08", "content": "狗蛋TV是基于微信小程序开发的一款App。gordanLee每天都会推荐一首歌、一篇文章、一段短视频，每天用十分钟的细碎时光，点燃内心的光明。目前分为音乐，短视频，影评三个模块。线上开源地址 https://github.com/lishuaixingNewBee/gordanTv 点个赞吧！小程序开发文档以下所有 API 均由产品公司自身提供，本人皆从网络获取。获取与共享之行为或有侵犯产品权益的嫌疑。若被告知需停止共享与使用，本人会及时删除此页面与整个项目。请您暸解相关情况，并遵守产品协议。为了方便大家学习和测试，我们提供了https的接口供大家使用，且用且珍惜。请在微信开发设置中加入request合法域名,或者在开发设置中勾选——不校验合法域名、web-view（业务域名）、TLS 版本以及 HTTPS 证书。感谢与支持-   狗蛋TVapi: https://api.gordantv.top\r\n    -   豆瓣api: https://api.douban.com\r\n    -   QQ音乐api: https://y.qq.com项目介绍狗蛋TV是基于微信小程序+ES6进行开发，能同时运行在Android、iOS环境下。涵盖了音乐、短视频、影评三个版块。开屏引导图调用微信wx.onAccelerometerChange重力感应设备API,实现水波荡漾。调用wx.getUserInfo获取用户头像。工具类用Promise封装wx.request(),简化代码结构:const $get = (url, data) => {\r\n  return new Promise((resolve, reject) => {\r\n    wx.request({\r\n      url,\r\n      data,\r\n      header: { 'Content-Type': 'json' },\r\n      success: resolve,\r\n      fail: reject\r\n    })\r\n  })\r\n}电影评分实现const convertToStarsArray = (average) => {\r\n  const LENGTH = 5;\r\n  const CLS_ON = 'on'; // 全星\r\n  const CLS_HALF = 'half'; // 半星\r\n  const CLS_OFF = 'off'; // 无星\r\n  let result = [];\r\n  let score = Math.round(average) / 2;\r\n  let hasDecimal = score % 1 !== 0\r\n  let integer = Math.floor(score)\r\n  for (let i = 0; i < integer; i++) {\r\n    result.push(CLS_ON)\r\n  }\r\n  if (hasDecimal) {\r\n    result.push(CLS_HALF)\r\n  }\r\n  while (result.length < LENGTH) {\r\n    result.push(CLS_OFF)\r\n  }\r\n  return result;\r\n}小程序内部组件实现上拉刷新，下拉加载方法一：scroll-view 组件\r\n    方法二：onPullDownRefresh和onReachBottom方法实现小程序下拉加载和上拉刷新阅读模块微信小程序使用wxParse解析html项目中遇到在微信小程序里需要显示音乐文章的内容，文章内容是通过接口读取的服\r\n务器中的富文本内容，是html格式的，小程序默认是不支持html格式的内容显示的，\r\n那我们需要显示html内容的时候，就可以通过wxParse来实现。项目安装\r\n    git clone git@github.com:lishuaixingNewBee/gordanTv.git\r\n目录结构\r\n\r\n|--- utils & Public Function              通用函数\r\n|--- components & components Public View  components和template模板\r\n|--- images & Img Resources               图片资源\r\n|--- pages & View Dir                     页面"}
{"title": "微信小程序开发BUG经验总结 ", "author": "Rolan", "time": "2018-6-4 00:38", "content": "小程序开发越来越热，开发中遇到各种各样的bug，在此总结了一些比较容易掉进去的坑分享给大家。1. new Date跨平台兼容性问题在Andriod使用 new Date(“2018-05-30 00:00:00”) 木有问题，但是在ios下面识别不出来。因为IOS下面不能识别这种格式，需要用 2018/05/30 00:00:00 格式。可以使用正则表达式对做字符串替换，将短横替换为斜杠。 var iosDate= date.replace(/-/g, '/'); 。2. wx.getUserInfo()接口更改问题微信小程序最近被吐槽最多的一个更改，就是用户使用wx.getUserInfo（开发和体验版）时不会弹出授权，正式版不受影响。现在授权方式是需要引导用户点击一个授权按钮，然后再弹出授权。解法很长，请参考:解法1： 微信小程序不支持wx.getUserInfo授权的解决方法解法2： getUserInfo兼容解决方案3. 只有在调试模式下，才能发送数据到自己的正式服务器其实，只要注意配置合法域名，这个问题就解决了。有的时候，因为一上来就开发，忘记掉去配置域名。后来发现数据没法出去，可能半天没想来忘记配置了！4. 无法获取UnionID的问题login获取UID必须满足两个条件： 1、把小程序和公众号都绑定在开放平台； 2、用户必须已经关注公众号。用wx.getUserInfo获取满足一个条件：把小程序和公众号都绑定在开放平台；5. wx.getSystemInfoSync获取windowHeight不准确主要原因在于获取是时机，wx.getSystemInfoSync是在页面初始化的时候就计算了，基本上可以理解为是屏幕高度。所以，最好的方法是使用异步接口，并且在onReady函数中调用。onReady() {\r\n  wx.getSystemInfo({\r\n    success({windowHeight}) {\r\n      // todo\r\n    }\r\n  });\r\n}6. 图片本地资源名称，尽量使用小写命名在解决iPhone X适配时，底部多余部分使用图片时<image class='iphonexImg' src=\"/imgs/iphoneBGT.png\" mode=\"aspectFill\">image>路径是 src='imgs/iphoneBGT.png'发现在pc IDE上面可以显示出来，但是真机调试时，图片找不到，然后将图片名称改为iphonex.png真机调试就可以了<image class='iphonexImg' src=\"/imgs/iphonex.png\" mode=\"aspectFill\">image>写在最后：代码总是有各种bug，像上面列举的问题还是在开发中就可以发现。而代码上线以后呢，测试也不能保证100%没有问题。在这里，推荐Fundebug的 微信小程序bug监控服务 给各位老铁！关于Fundebug2017年初，小程序还刚上线，Fundebug就支持小程序错误监控了。做为最早的小程序错误监控服务的拓荒者，累计为数千个小程序提供免费服务，累计处理数千万小程序错误。"}
{"title": "微信小程序开发之从相册获取图片 使用相机拍照 本地图片上传 ... ... ", "author": "Rolan", "time": "2018-6-19 00:26", "content": "1.index.wxml1 <!--index.wxml-->  2 <button style=\"margin:30rpx;\" bindtap=\"chooseimage\">获取图片</button>  3 <image src=\"{{tempFilePaths }}\" mode=\"aspecFill\" style=\"width: 100%; height: 450rpx\"/>  2.index.js 1 //index.js   2 //获取应用实例   3 var app = getApp()   4 Page({   5   data: {   6     tempFilePaths: ''   7   },   8   onLoad: function () {   9   },  10   chooseimage: function () {  11     var _this = this;  12     wx.chooseImage({  13       count: 1, // 默认9  14       sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有  15       sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有  16       success: function (res) {  17         // 返回选定照片的本地文件路径列表，tempFilePath可以作为img标签的src属性显示图片  18         _this.setData({  19           tempFilePaths:res.tempFilePaths  20         })  21       }  22     })  23   }  24 })  这里说说sourcetype.默认是从相册获取和使用相机拍照,跟微信现在选择图片的界面一样,第一格是拍照,后面的是相册照片.这里注意:返回的是图片在本地的路径.如果需要将图片上传到服务器,需要用到另一个API.示例代码: 1 wx.chooseImage({   2   success: function(res) {   3     var tempFilePaths = res.tempFilePaths   4     wx.uploadFile({   5       url: 'http://example.weixin.qq.com/upload', //仅为示例，非真实的接口地址   6       filePath: tempFilePaths[0],   7       name: 'file',   8       formData:{   9         'user': 'test'  10       },  11       success: function(res){  12         var data = res.data  13         //do something  14       }  15     })  16   }  17 })"}
{"title": "怎么掌握微信小程序的取值、传值、数据存储 ", "author": "Rolan", "time": "2018-12-10 00:12", "content": "小程序界面设定如下父级页面：A界面子级页面：B界面异级页面：C界面 一.本页面取值（A界面→A界面）a.例如：input输入文字获取到value（键盘输入时触发）wxml：<input type='text' name=\"userName\" maxlength=\"11\" bindinput=\"userPhoneInput\" ></input>js:data: {\r\n    userPhone: '',\r\n  },\r\n  //手机号输入框事件键盘输入时触发(文字提醒)\r\n  userPhoneInput: function (e) {\r\n    this.setData({\r\n      userPhone: e.detail.value\r\n    })\r\n  },\r\n  //接口取值格式\r\n  onShow: function () {\r\n    .....\r\n    data:{\r\n        UserPhoneNum:that.data.userPhone,\r\n    },\r\n    .....\r\n  }, b.例如：input不输入文字获取到全部的value（键盘不输入时触发）wxml：<form bindsubmit=\"formSubmit\">\r\n        <input type='text' value='{{putdata.name}}' name=\"companyname\" placeholder='请输入你的姓名/公司名称'></input>\r\n        <input type='text' value='{{putdata.bankName}}' name=\"openbank\" placeholder='请输入你的开户行全称'></input>\r\n        <button formType=\"submit\">完成</button>\r\n</form>注：form表单与button绑定获取input的内容js://按钮点击事件\r\n  formSubmit: function (e) {\r\n    var companyname = e.detail.value.companyname;\r\n    var openbank = e.detail.value.openbank;\r\n    //根据name取input的value\r\n    wx.request({\r\n      url: aaaaaa,\r\n      data: {\r\n        name: companyname,\r\n        bankName: openbank,\r\n      },\r\n      header: {\r\n        'content-type': 'application/json',\r\n      },\r\n      success: function (res) {\r\n\r\n      },\r\n      fail: function () {\r\n\r\n      }\r\n    })\r\n  } 二.异页面传值取值（A界面→B界面，A界面→C界面）a.url传值用 navigator标签或 wx.navigator传值，A界面向B界面传值；（不懂的自行安利小程序api和组件）wxml:// navigator标签传值\r\n<navigator url=\"/page/index/index?id=1432&name=qima&password=hj1234\" >传值</navigator>\r\n\r\n//wx.navigator传值\r\nwx.navigateTo({\r\n      url: '/page/index/index?id=' + id +'&username='+ username+'&password='+ password\r\n})下一个页面取值方法：js:data: {\r\n    id : \"\" ,\r\n    name : \"\" ,\r\n    password : \"\",\r\n  },\r\nonLoad: function (options) {\r\n    var id = options.id;\r\n    var name = options.name;\r\n    var password = options.password;\r\n    this.setData({\r\n      id:id,\r\n      name:name,\r\n      password:password,\r\n    })\r\n},一般小程序能不用接口解决的就不要用到接口呈现数据，可以用URL传值，到下一个页面取值，然后呈现到页面即可； b.数据存储我们会用到小程序的api,通过调用微信提供的方法：wx.setStorage、wx.setStorageSync、wx.getStorage、wx.getStorageSync、wx.clearStorage、wx.clearStorageSync、实现对数据本地缓存、获取、清除。js缓存:我们获取接口传回的数据，id,code之类的，我们做全局储存，命名一个key和内容value；wx.request({\r\n        url: aaaaa,\r\n        data: {\r\n          UserPhoneNum: '86//' + that.data.userPhone,\r\n          Password: that.data.passWd,\r\n          IP: that.data.IP,\r\n        },\r\n        header: {\r\n          'content-type': 'application/json',\r\n        },\r\n        success: function (res) {\r\n          console.log(res.data),\r\n          //存储格式 wx.setStorageSync('key命名', value内容);\r\n          wx.setStorageSync('salemanId', res.data.salemanId);\r\n          wx.setStorageSync('salemanLevel', res.data.salemanLevel);\r\n          if (res.data.state == 200){\r\n            \r\n          }else{\r\n           \r\n          }\r\n        },\r\n })js获取：根据key获取到数据，缓存到本地或上传到接口；//根据key获取到缓存的值\r\nvar salemanId= wx.getStorageSync(\"salemanId\");js清除：从本地缓存中同步移除指定 key。这里具体使用同步或是异步需要根据你存储时的方法，或是同步清理本地数据缓存；//清除数据\r\nwx.removeStorageSync(\"salemanId\") 查看自己缓存数据地点：（如图） c.全局App对象在我们的app.js文件里面，我们需要写好我们需要全局使用的数据；//用户学校数据\r\n globalData: {\r\n     school:null,\r\n }我们需要给它赋值，赋值代码如下：var self = this\r\n......\r\nself.globalData.school = res.data.schoolID在我们需要取值的地方引用全局的app.js,然后取值：var app = getApp();\r\nonLoad: function () {\r\n    var that = this; \r\n    //调用应用实例的方法获取全局数据  \r\n    app.getUserSchool(function (school) {\r\n      //更新数据  \r\n    })\r\n},\r\n//取值\r\n......\r\nschool: app.globalData.school,\r\n...... 三.总结小程序了解到这些传值取值过程，接通接口，呈现数据就快多了，还有哪些可以传值取值的方法，欢迎大家留言哦，交流才能让人进步，有什么错误的地方也欢迎大家指正，我将进行更改，觉得博主写的还可以的，欢迎点个关注，以后有空常来我的博客逛逛，虽然可能写的东西不是很高级，但是对于初级的人来说，还是能帮助到很多东西的，我的博文能帮助到大家我就很开心了，谢谢您百忙之中的观看，一起加油进步，哇哈哈哈"}
{"title": "微信小程序的wx-charts插件-tab选项卡 ", "author": "Rolan", "time": "2018-11-29 00:18", "content": "微信小程序的wx-charts插件-tab选项卡效果://index.js\r\nvar wxCharts = require('../../utils/wxcharts-min.js');\r\nconst app = getApp();\r\nvar ringChart = null;\r\nPage({\r\n  data: {\r\n    selected: true,\r\n    selected1: false\r\n  },\r\n  torecord() {\r\n    wx.navigateBack({\r\n      delta: 1,\r\n    })\r\n  },\r\n  onLoad: function (e) {\r\n    //  高度自适应\r\n    var windowWidth = '', windowHeight = '';    //定义宽高\r\n    try {\r\n      var res = wx.getSystemInfoSync();    //试图获取屏幕宽高数据\r\n      windowWidth = res.windowWidth / 750 * 690;   //以设计图750为主进行比例算换\r\n      windowHeight = res.windowWidth / 750 * 550    //以设计图750为主进行比例算换\r\n    } catch (e) {\r\n      console.error('getSystemInfoSync failed!');   //如果获取失败\r\n    }\r\n    ringChart = new wxCharts({\r\n      canvasId: \"ringCanvas\",\r\n      type: \"ring\",\r\n      series: [\r\n        { data: 20, },\r\n        { data: 30, },\r\n        { data: 60, }\r\n      ],\r\n      width: windowWidth,\r\n      height: windowHeight,\r\n      dataLabel: false,\r\n      legend: false,\r\n    });\r\n  },\r\n\r\n  selected: function (e) {\r\n    this.setData({\r\n      selected1: false,\r\n      selected: true\r\n    })\r\n  },\r\n\r\n  selected1: function (e) {\r\n    this.setData({\r\n      selected: false,\r\n      selected1: true\r\n    })\r\n  }\r\n})<view class=\"head\">\r\n  <view class=\"head_item {{selected?'head_itemActive':''}}\" bindtap=\"selected\">个人</view>\r\n  <view class=\"ring\"></view>\r\n  <view class=\"head_item {{selected1?'head_itemActive':''}}\" bindtap='selected1'>设置</view>\r\n</view>\r\n<view class=\"main {{selected?'show':'hidden'}}\">\r\n  <canvas canvas-id=\"ringCanvas\" disable-scroll=\"true\" class=\"canvas\"></canvas>\r\n  <cover-view class='text'>\r\n   黄\r\n  </cover-view>\r\n</view>\r\n<view class=\"main {{selected1?'show':'hidden'}}\">\r\n  <text>for sutdnet month attend</text>\r\n</view>page {\r\n  background-color: rgba(239, 239, 240, 1);\r\n}\r\n\r\n.text {\r\n  position: absolute;\r\n  top: 380rpx;\r\n  left: 356rpx;\r\n}\r\n\r\n.canvas {\r\n  width: 100%;\r\n  height: 550rpx;\r\n  margin: 30rpx;\r\n}\r\n\r\n.head_item {\r\n  width: 374rpx;\r\n  text-align: center;\r\n  font-size: 34rpx;\r\n  color: #999;\r\n  letter-spacing: 0;\r\n}\r\n\r\n.head_itemActive {\r\n  color: rgba(87, 213, 200, 1);\r\n}\r\n\r\n.ring {\r\n  width: 2rpx;\r\n  height: 100%;\r\n  background-color: rgba(204, 204, 204, 1);\r\n}\r\n\r\n.head {\r\n  width: 100%;\r\n  height: 100rpx;\r\n  background-color: rgba(255, 255, 255, 1);\r\n  border-bottom: 1rpx solid rgba(204, 204, 204, 1);\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: space-between;\r\n  position: fixed;\r\n  top: 0;\r\n  z-index: 10;\r\n}\r\n\r\n.main {\r\n  position: absolute;\r\n  width: 100%;\r\n  height: 100%;\r\n  display: block;\r\n  box-sizing: border-box;\r\n  padding-top: 100rpx;\r\n  top: 0;\r\n}\r\n\r\n.show {\r\n  display: block;\r\n  text-align: center;\r\n}\r\n\r\n.hidden {\r\n  display: none;\r\n  text-align: center;\r\n}往后余生，唯独有你简书作者：达叔小生90后帅气小伙，良好的开发习惯；独立思考的能力；主动并且善于沟通简书博客： https://www.jianshu.com/u/c785ece603d1结语下面我将继续对 其他知识 深入讲解 ，有兴趣可以继续关注小礼物走一走 or 点赞"}
{"title": "mp-redux：解耦小程序中的业务与视图，让测试更容易 ", "author": "Rolan", "time": "2018-10-16 00:34", "content": "项目地址：点我，欢迎star和issue\r\nmp-redux\r\n一个用于小程序和轻量级H5应用的状态管理工具， 使用方法是一个简化版本的Redux。之所以是适用于轻量级应用，主要是因为没有实现组件间的数据共享。因此不适合于复杂，庞大的前端应用。\r\n是否你需要使用它？\r\n如果你也和我有同样的困惑，那么你就该尝试一下：\r\n\r\n代码耦合严重，业务代码重复，往往改一处就会引起诸多功能也要跟着修改\r\n业务逻辑都写在视图逻辑层，但是有苦于没有办法将业务代码剥离\r\n代码越来越臃肿不堪\r\n对老代码不敢碰，会影响很多业务逻辑\r\n\r\n为什么借鉴redux\r\n\r\n用为redux是框架无关的，所以具有更好的可移植性，当然我这里在内部还是做了一些\"猥琐\"处理来兼容多平台\r\n单一数据源，让状态更容易被跟踪\r\n将业务逻辑与视图层分离，让代码更清晰，耦合更低\r\n状态都应该放在页面的根容器去管理，分发到各个子组件。以便更好的控制业务逻辑\r\n业务逻辑都放入model中，而model都是纯函数，让测试更加容易\r\n\r\n如何使用？\r\n拷贝 /mp-redux/index.js文件到项目中引入即可。开包即用。\r\n为什么没有使用npm?\r\n懒\r\napi使用方法\r\n\r\n在系统入口我们必须初始化store\r\n\r\n  const mpState = require('./mp-redux/index.js');\r\n  const userInfo = require('./model/userinfo.js');\r\n  const logs = require('./model/logs.js');\r\n\r\n  mpState.createStore({\r\n    logs, // 这些model 就是redux的reduce，必须是纯函数，并且需要返回一个纯对象\r\n    userInfo // 这些model 就是redux的reduce，必须是纯函数，并且需要返回一个纯对象\r\n  }, 'onShow') // 第二个参数是劫持的生命周期函数，这是为了解决不同平台的差异性问题导致的。后期会考虑优化\r\n复制代码\r\n创建model\r\n\r\n  // model 就是数据模型，是根据业务而来的\r\n  // model/userinfo.js\r\n  const actions = require('./../action/logs.js'); // 这里同样采用了redux的action机制\r\n\r\n  const initState = {\r\n    logs: []\r\n  }\r\n\r\n  module.exports = function (state = initState, action = {}) {\r\n    const newState = { ...state };\r\n    switch (action.type) {\r\n      case actions.addLogs:\r\n        const now = new Date();\r\n        newState.logs.push({\r\n          time: now.getHours() + \":\" + now.getMinutes() + \":\" + now.getSeconds(),\r\n          value: action.data\r\n        });\r\n        return newState;\r\n      case actions.clearLogs:\r\n        newState.logs = [];\r\n        return newState;\r\n      default:\r\n        return newState;\r\n    }\r\n  }\r\n  // action/userinfo.js\r\n  module.exports = {\r\n    addLogs: 'LOGS_ADD',\r\n    clearLogs: 'LOGS_CLEAR'\r\n  }\r\n复制代码\r\n在Page中使用\r\n\r\n  // 使用connect来注入需要订阅的状态，并且mp-redux会在页面对象中自动注入dispatch方法 \r\n  const mpState = require('./../../mp-redux/index.js');\r\n  const util = require('../../utils/util.js');\r\n  const logActions = require('./../../action/logs.js');\r\n\r\n  Page(mpState.connect((state) => {\r\n    return {\r\n      userInfo: state.userInfo.userInfo,\r\n      logs: state.logs.logs\r\n    }\r\n  },\r\n  { // 在这里所有的业务数据都保存在store中，所以页面如果只有业务数据的话，是不需要data属性的。\r\n    clearLogs() {\r\n      this.dispatch({ // 通过dispatch方法来发出action，从而更新store中的数据\r\n        type: logActions.clearLogs\r\n      })\r\n    }\r\n  }))\r\n复制代码\r\n更容易被测试的业务代码\r\n从上面我们将业务数据声明到model中，而所有的业务数据更新以及业务数据更新的逻辑都在model中完成(参考/model/logs.js)。而model都是纯函数，因此业务代码更加容易被测试。\r\n\r\n  // 不要吐槽，，，，，，我第一次写测试用例。(-_-)\r\n  const actions = require('./../action/logs.js');\r\n  const model = require('./../model/logs.js');\r\n\r\n  test('1. init logs data', () => {\r\n    expect(model()).toEqual({\r\n      logs: []\r\n    })\r\n  })\r\n\r\n  test('2. add new log into empty logs', () => {\r\n    const newState = model(undefined, {\r\n      type: actions.addLogs,\r\n      data: \"Test new log\"\r\n    });\r\n\r\n    expect({\r\n      value: newState.logs[0].value,\r\n      len: newState.logs.length\r\n    }).toEqual({\r\n      value: \"Test new log\",\r\n      len: 1\r\n    });\r\n  })\r\n\r\n  test('3. add new log into logs', () => {\r\n    const newState = model({logs: [{time: '00:00:00', value: 'the first log'}]}, {\r\n      type: actions.addLogs,\r\n      data: \"the second log\"\r\n    });\r\n\r\n    expect({\r\n      log1: newState.logs[0].value,\r\n      log2: newState.logs[1].value,\r\n      len: newState.logs.length\r\n    }).toEqual({\r\n      log1: \"the first log\",\r\n      log2: \"the second log\",\r\n      len: 2\r\n    });\r\n  })\r\n\r\n  test('4. clear all logs', () => {\r\n    const newState = model({ logs: [\r\n      { time: '00:00:00', value: 'log1' }, \r\n      { time: '00:00:00', value: 'log2' }\r\n      ] }, {\r\n        type: actions.clearLogs\r\n      });\r\n\r\n    expect({\r\n      len: newState.logs.length\r\n    }).toEqual({\r\n      len: 0\r\n    });\r\n  })\r\n复制代码因为互联网产品都是toC业务，UI基本上每天都在变化，但是业务的变化其实是很小的。我们通过将业务建模，在前端构建业务数据模型。而这些模型是可以预知的。因此也就可测试。\r\n而对于一些互联网产品，前端测试是一件非常繁琐而复杂的事情。因此这个简单的方案大大的降低了前端代码变动引起的风险，而增加的工作量也并不是很大。可以一定程度上降低业务代码的回归测试成本。作者：YaHuiLiang(Ryou)链接：https://juejin.im/post/5bbb315d6fb9a05cf039ffed来源：掘金"}
{"title": "万字解析小程序（3）：流量升级触发的“礼物经济” ", "author": "Rolan", "time": "2018-10-29 00:06", "content": "本文观点：流量升级的原因：微信社交能力的开放，将渠道集中式的“公域流量”转化成用户为中心的“私域流量”。流量升级的结果：私域流量去中心化，导致了“赢家通吃”模式的失效。礼物经济的启示：礼物具有极强的“外部性”。互惠是一种方式，而不是目的。流量升级的原因2017年6月13日，我写了一篇“唱衰小程序”的文章。在小程序初期，有很多人的看法，是和我相同的。认为“小程序 PK APP”，胜算并不大。1年的时间，我明白了1件事情，擂台搭错了，你在旁边磕一吨焦糖瓜子儿，也等不出输赢。看小程序这个赛道，不该看 “小程序 PK APP”，也不该看“微信 PK Android”，而是看“微信 PK 智能手机”。为什么？移动浪潮的兴起，是因为“智能手机”的发展，带来了流量红利。小程序浪潮的兴起，是因为“微信”社交能力的开放，带来的流量升级。1. 追忆移动浪潮智能手机的出现，大大的提高了用户的终端保有量。它太简单便携，人手一部。可是换一个角度想，如果智能手机没有出现，世界会怎样？2018年，可能会有“9毽键盘”、“大屏”电脑，专供于三四线城市，老年人，小镇青年。没有智能手机，可能人手一部电脑。智能手机最性感的点，不在于让一些不触网的人触网，而在于流量的重新洗牌。这一点，只有它可以做到。流量迁移：流量从一个地方转移到另一个地方；流量洗牌：流量池结构打散，重排。人生海海，我们大部分时间在拼“定位”。一亩三分地，种了玉米就不能种高粱。你需要找到你的差异化优势，才能赢得竞争。可是某些浪潮下，这一亩三分地迅速洗牌，种了的玉米被全部拔了下来。要知道，乱世出英雄，混乱是阶梯。——姜太公公智能手机的洗牌，在于“使用场景”的洗牌，因为LBS，移动性等带来的随时随地的场景。这大大拓宽了整体的使用频次和使用时间。在这波使用场景的浪潮下，产生了各种场景解决方案的公司，比如：吃饭、出行、打发时间……微信的洗牌，在于“用户”结构的洗牌。这导致了用户接触信息、使用信息的方式的完全颠覆。微信社交能力的开放，带来了“用户”结构从渠道集中式的公域流量转化成用户为中心的私域流量。所以小程序的价值不在于小程序是什么？而在于微信开放了自己的终端价值，这个开放带来了什么？2. 为什么当初会错判？我们当初为啥会比较“小程序 PK APP”？为了形成“短平快”的判断，我们经常会贴标签。比如：实习生小姑娘一脸花痴的说“我的idol太帅了，简直是行走的荷尔蒙，我要给idol生孩子”  你说：“小鲜肉就是长得好看，实力都不行”。拜托，人家idol都特么42岁了好么，见了面，你都得叫人家一声大哥。（这个case并不是发生在我身上的哦，不要瞎想）“标签”，帮助我们迅速定义未知事物，却模糊了事物的全貌。如果牛在你心中的标签只有“黑白色”，那我问你是否见过牛尾巴是“666”的？你就不会知道，站在你眼前的这一只就是。标签化思考导致我们无法看到事物的全貌。在看小程序赛道时，很多人同样用了标签化思考，导致使用了错误的擂台。为了快速定义“小程序”，我们给它贴了一个“类似app”的标签。原来安卓、苹果手机上使用“微博APP”，现在微信中使用“微博小程序”。这样的“标签”，遮盖了什么全貌呢？为了更好的说明，我先来拆解下移动浪潮的全貌：应用层：用户使用的东西属于应用层。“APP”属于应用层。系统层：指操作系统。“android系统”，“iOS系统”属于系统层。应用的实现依赖于系统层。同一个应用，可能有“android版本”、“iOS版本”终端：“智能手机”是终端。终端带来了流量，流量和价值直接相关。对应到小程序赛道，这个全貌是什么呢？小程序浪潮下的终端是“微信”，开发者原来抢的是“移动手机”里的用户，现在抢的是“微信”里的用户。终端带来了流量，流量和价值直接相关。小程序能力开放前，“微信”里的用户你是很难碰到的。“微信”和“移动手机”在终端价值上，是一个级别的。万物皆有裂痕，那是风吹过来的地方。不要找风口上的猪，而是要看风里有什么能力。——姜太公公小结移动浪潮的兴起，是因为“智能手机”的发展，带来了流量红利。小程序浪潮的兴起，是因为“微信”社交能力的开放，带来的流量升级。流量升级的结果每一个小程序，都需要回答一个问题：“你是在玩儿微信里的公域流量还是私域流量？”如何判断公域还是私域？这里提供一个判断标准——根据用户的使用场景。如果用户的使用场景是“吃喝玩乐上班上课”，那就是在玩儿公域流量。如果用户的使用场景是“公众号 朋友圈 聊天”，那就是玩儿私域流量。小程序的流量升级，是因为出现了私域流量。私域流量的作用是什么呢？引起的后果是什么呢？NO.1 “赢家通吃”模式失效淘宝店主想多卖货，过去怎么办？需要买直通车，需要冲击金钻，需要提高淘宝搜索排名。这面向的是“公域流量”。现在怎么办？搞粉丝群，搞社群，把“公域流量”拉出一部分到自己的“私域流量”。为什么要搞私域流量？在选择爆炸的情况下，用户的每次选择都是站在一个茫茫的大海上。海上满满的都是船，用户会看到离他近的船，或者体量大的船。小船的被看到的机会，很少。私域流量的存在带来了什么？天崩地裂，大海被拆分成很多“浅水湖”。我是一艘小小船，用户在“大海”上看不到我，我就开进他身边的“浅水湖”。每日优鲜，玩儿的是公域流量。干死了无数生鲜电商，成为了用户在海上可以看的到的大船。而社区团购生鲜，玩儿的是私域流量，通过一个个宝妈建立的微信群，拼团买生鲜。公域流量是中心化的，这种模式下火的是“规模经济”。赢家因为规模增大带来了经济效益的提高，规模增大后，成本分摊得更低，获客成本更低。所谓赢家通吃。私域流量去中心化的，这一次，“规模效应”失效了。正所谓 场下格斗没套路，乱拳打死老师傅。微信中的“关系”形成了天然的壁垒，导致了去中心化。大海，因为这些关系的存在，变成了“浅水湖”。NO.2 用户行为的“驱动力”不再是“需求”Fogg模型阐述了如何让行为发生。Fogg模型认为一次行为的发生需要具备三个要素，缺一不可，这三个要素是： 动机、成本、触发点。举一个例子，一家饭馆想吸引用户走进来吃饭，这个行为的发生需要如下条件：动机：顾客想吃饭成本：顾客兜里有50块钱，这家饭馆人均消费30元。顾客有“支付的能力”触发点：顾客走到饭馆旁边，看到饭馆“吸引人的招牌”要完成这次行为，三个要素缺一不可。公域流量和私域流量的区别在于，这三个要素出现的顺序不同。公域流量是“动机”驱动行为，私域流量是“触发点”驱动行为。公域流量下，用户首先有了一个“动机”，然后打开了一个软件。用户想听歌，于是打开某易云音乐APP。用户记得它的位置在手机第2屏的第3排，然后轻松的找到，然后点开。私域流量下，用户通过“群”“聊天”“公众号”的触发点，获得了一个动机。好友发给我一个“毛衣”拼团链接，看着还挺实惠的。天气真的变冷了，我也需要一件。两者行为的驱动点完全不同。如果你是玩公域流量，你需要降低“主动触发”下的用户摩擦。在用户有一个动机的时候，帮助她迅速完成行为。做到用户所想即所得，让用户快速找到你的软件。用户心理想要的是，don’t make think，don’t make wait。如果你是玩私域流量，你需要降低“被动触发”下对用户的打扰。Emmm，这，真的有点复杂哦！会在第3节中重点讲哦！NO.3 流量池结构变为“沙漏”提到“流量池”，最容易想到什么？没错，用户分层。公域流量，流量池的结构是上图这种“鸡尾酒”型。用户是分层的，稳定的，忠实用户 、老用户、新用户各占有稳定的比例。做好这杯鸡尾酒，需要调好用户分配比例，讲的是“精细化运营”。 私域流量，流量池的结构是“沙漏”型。用户是动态的，流动的。小程序中，留存率20%是一个坎儿，而一个普通app，留存率动辄40%，50%，可见微信中的私域流量留存之低。私域流量做不了鸡尾酒，因为“底是漏的”。APP，强调的是转化率，强调的是一节节，分子小于分母的比例。转化率永远是小于1的，如果做到0.9，已经可以封神了。小程序中，强调的是分享，强调的是一层层，分子大于分母的裂变K值。K值大于1才算及格，1.1的100次方=13780 ，但是0.9的100次方=0.000027。分享带来了流量的复利，解决了留存的问题。分享，是整个私域流量池模型成立的根基。小结私域流量的作用是什么呢？引起的后果是什么呢？NO.1 “赢家通吃”模式失效NO.2 用户行为的“驱动力”不再是“需求”NO.3 公域流量池的结构是“鸡尾酒”型，私域流量池的结构是“沙漏”型。“礼物经济”给小程序的启示上文提到了私欲流量池结构变为“沙漏”。这里就不得不重点讲一下分享，你以为我要讲用户分享的18大驱动力？你以为我要讲裂变的起点是“人民币”和“社交币”？不，我们站的高一点，玩儿的大一点的。私域流量的分享其实在做的是“礼物经济”。礼物经济指的是提供商品或服务者并没有明确的预期回馈对象，也没有预期回馈的内容，有许多分享行为出自于非制式的习惯。同时，礼物的施与受之间已转换成一种未明确规定的义务，形成送礼者与收礼者之间的隐晦关系。礼物经济也被认为是一种债务经济，在这种经济中，交易者的目标是尽可能获得最多的礼物债务人，而不像在商品经济中以获取最大利润为目的。——百度百科从礼物经济的3大特点中，我们可以获得针对于小程序流量的玩法儿启示。1. 礼物经济中“互惠”是媒介，但不是目的互惠是一种语言。小明分享了一个“原价999，团购价9块9”的拼团链接给姜太公公。拼团成功后，小明和公公各自省了900元。请问，小明潜意识里，是希望不久的将来，姜太公公也帮助他省900元钱么？不会，小明对于姜太公公给他的回报没有预期。互惠，是一种媒介，是礼物经济中语言。就好像，见面问一句“你吃了没”。实际上，对方吃了啥，根本不care。对小程序开发者的启示：要让“互惠”成为一种沟通的方式，不要把互惠看的太重，否则会本末倒置。小程序的各种玩儿法“拼 抢 坎 送 比”，都是一种沟通的媒介。2. 交换礼物目的是——增加礼物的往来“礼物和商品交易的一个重要不同之处是，礼物在双方之间形成了情感纽带，商品交易却并不会带来任何必要的联系。我进入一家五金店，付钱给店员购买一根锯条然后离开，我可能再也不会和这名店员见面。疏离感是商品交易模式的基本原则，我们不想被打扰，所以如果这个店员一直不想我谈家里的事儿，我会换一家店，因为我只想买一个金条”—— 摘取自《分享经济的爆发》和商品销售不同，礼物赠予是要在双方建立亲密关系。当礼物在群体里流通，形成了一系列相互交织的关系网络，出现了一种去中心化的内聚力。礼物经济在于关系的维护，通过赠送礼物，强化了双方的关系。如果破坏了双方的关系，就不能称为礼物，比如：什么样的礼物会破坏朋友圈的关系？打卡、广告、利己分享。比如：什么样的礼物会破坏朋友的关系？没完没了集call。对小程序开发者的启示：当小程序的某种裂变玩儿法，用户已经麻木甚至厌恶时，这种玩儿法就已经跳出了礼物经济，它不能对用户的关系起到正向的作用。3. 礼物具有“外部性”礼物的商品价值和消费价值在很大程度上是无关紧要的。礼物的价值，通过“送”而达成。礼物的价值不在于礼物本身。一个没有送出去的礼物，没有价值。礼物这种东西，具有很强的外部性。回到互联网。小程序需要具有“外部性”，用户通过分享，感知到价值。用户没有分享，感知不到价值。只有这样，分享才能成为必备操作。拼多多：用户分享前，感受到这是一个卖低价商品的卖场。用户分享后，哇塞好便宜，感觉自己赚到了人民币。黑咔：用户分享前，感受到这是一个图片处理工具。用户分享后，哇塞好有趣大家一起玩，感觉自己赚到了社交币。对小程序开发者的启示：用户通过分享，“才能”感知到小程序的核心价值。“才能”这两个字儿很重要。小结私域流量的分享其实在做的是“礼物经济”，从礼物经济的特点中，我们可以获得针对于小程序的3大启示。总结这篇文章写的有点难哦，感谢你能看完，本文观点回顾：流量升级的原因：微信社交能力的开放，将渠道集中式的“公域流量”转化成用户为中心的“私域流量”。流量升级的结果：私域流量去中心化，导致了“赢家通吃”模式的失效。礼物经济的启示：礼物具有极强的“外部性”。互惠是一种方式，而不是目的。相关阅读万字解析小程序（1）：小程序 PK APP = 无解 ？万字解析小程序（2）：如何保证大海上可以看到“小船”？#专栏作家#姜太公公，微信号公众号：grandpa_jiang，人人都是产品经理专栏作家。产品老流氓，终身学习者。致力于研究产品方法论，解决小白PM的疑难杂症。本文原创发布于人人都是产品经理。未经许可，禁止转载题图来自 Pexels，基于 CC0 协议"}
{"title": "微信小程序性能优化方案——让你的小程序如此丝滑 ", "author": "Rolan", "time": "2018-11-4 23:42", "content": "首先，问一个问题，当用户点击小程序后发生了什么？上图中的三个状态，我们经常遇到，它们分别对应小程序的下面三个状态：有三个点的白屏（左侧）： 下载代码包的阶段没有三个点的白屏（中间）： 业务代码注入和渲染的阶段加载中（右边）： 业务代码中异步请求数据总的来说，小程序呈现到用户面前，实际上经历了下面两个阶段：运行环境的加载下载代码包下面具体介绍这两个阶段：运行环境预加载这步是微信做的。微信会在用户打开小程序之前就已经准备好环境，用户点击小程序入口后，直接下载小程序的代码包即可。下载代码包启动小程序小程序代码包里面的代码，不是小程序的源代码，而是编译、压缩、打包之后的代码包。下图中，左侧的“ 预加载 ”对应的是运行环境的预加载，右侧的“小程序启动” 对应的是下载代码包启动小程序。小程序提供的运行环境，分为逻辑层（AppService）和 视图层（webView），逻辑层是执行javascript的地方，视图层是渲染页面的地方。当小程序的代码包下载完毕后，业务代码分别注入逻辑层和渲染层。提升加载性能的最最最关键性一点是，控制包的大小，这个也是微信官方的说法。控制包的大小提升体验最直接的方法是 控制小程序包的大小 ，基本上可以说，1M的代码包，下载耗时1秒左右。控制包的大小的措施压缩代码，清理无用的代码图片放在cdn采用分包策略分包预加载独立分包（版本要求有点高）除了上面讲的控制包的大小，对异步请求的优化也很重要。对异步请求的优化onLoad 阶段就可以发起请求，不用等ready请求结果放在缓存中, 下次接着用请求中可以先展示骨架图先反馈，再请求。比如说，点赞的按钮，可以先改变按钮的样式，再 发起异步请求。提升渲染性能setData 干了啥每调用一次setData, 都是逻辑层向渲染层的一次通讯，这个通信还不是直接传给webView, 而是通过走了native层，通讯的开销很大。渲染层收到通讯后，还需要重新渲染出来，所以，emmm, 一次setData带来两次开销：通信的开销 + webview更新的开销。在数据传输时，逻辑层会执行一次 JSON.stringify 来去除掉 setData 数据中不可传输的部分，之后将数据发送给视图层。同时，逻辑层还会将 setData 所设置的数据字段与 data 合并，使开发者可以用 this.data 读取到变更后的数据。减少setData的数据量如果一个数据不能会影响渲染层，则不用放在setData里面合并setData的请求，减少通讯的次数这个很好理解吧列表的局部更新在一个列表中，有 n 条数据，采用上拉加载更多的方式，假如这个时候想对其中某一个数据进行点赞操作，还能及时看到点赞的效果此时，可以采用setData全局刷新，点赞完成之后，重新获取数据，再次进行全局重新渲染，这样做的优点是：方便，快捷！缺点是：用户体验极其不好，当用户刷量100多条数据后，重新渲染量大会出现空白期（没有渲染过来）如果采用布局刷新，将点赞的 id 传过去，知道点的是那一条数据, 将点赞的 id 传过去，知道点的是那一条数据。重新获取数据，查找相对应id的那条数据的下标（ index 是不会改变的），用setData进行局部刷新this.setData({\r\n    list[index] = newList[index]\r\n})\r\n复制代码小心后台页面的js小程序中可能有n个页面，所有的这些页面，虽然都拥有自己的webview(渲染层)， 但是却共享同一个js运行环境。也就是说，当你跳到了另外一个页面（假设是B页面），本页面（假设是A页面）的定时器等js操作仍在进行，并且不会被销毁，并且会抢占B页面的资源。在h5的环境中，当我们跳转到其他页面，老页面的js环境会被自动销毁，定时器什么都被销毁掉了，因此我们不需要关心老页面中，还有哪些js代码可能还会执行。但是在小程序中，我们必须手动的“清理”掉这样的代码。小心onPageScrollpageScroll 事件，也是一次通讯，是webview层向js逻辑层的通讯。这次通讯也是开销较大，如果考虑到这个事件被频繁的调用，回调函数如果有复杂的setData的话，emmmmm， 性能就会很差了。​小心获取节点位置在h5 中的环境中，为了实现懒加载、下拉加载，我们 不得不 去获取节点的位置。为啥说 不得不 ，是因为我们本可以用新的api ——intersectionObject去轻松实现（google等主流浏览器都已经支持了），但是微信的内置X5浏览器很遗憾的不支持。没想到，在小程序的环境中，微信竟然良心发现，支持intersectionObject api, 因此获取节点的信息，尽量还是用这api 吧。尽可能使用小程序组件自定义组件的更新只在组件内部进行，不受页面其他不能分内容的影响；比如一些运营活动的定时模块可以单独抽出来，做成一个定时组件，定时组件的更新并不会影响页面上其他元素的更新；各个组件也将具有各自独立的逻辑空间。每个组件都分别拥有自己的独立的数据、setData调用优化心得相比于上面的优化策略，最重要的是找出小程序中的性能瓶颈。在自己的优化实践中，遇到了下面的问题：下拉加载更多，特别特别卡，通过列表局部更新的技巧，发现性能改善不大。 后来发现，是因为首页需要监听scroll事件，导致scroll事件被频繁的触发，回调函数中有耗时操作，导致onreachBottom事件被阻塞了，也就是说，要等大概1~2秒才会去发起下一页的请求。 取消掉scroll事件的监听，原本>4s的加载时间，控制在1s之内。"}
{"title": "微信小程序之购物车和父子组件传值及calc的注意事项 ", "author": "Rolan", "time": "2018-11-13 00:57", "content": "1.效果图2.子组件实现要实现图中删除的效果，使用组件的形式更好做点，我当时本想直接在pages里实现，不过结果就是，滑动时，所有的商品都显示了删除按钮，除非用数组将每个商品要移动的距离存储起来，不过这样的话就很麻烦，所以我也是用组件来实现的关于微信组件，可以直接点击链接访问官网查看自定义组件子组件index.wxml<view class=\"commodityItem\" bindtouchstart=\"handleTouchStart\" bindtouchmove=\"handleTouchMove\" style=\"transform:translateX({{-rightSpace}}px)\">\r\n  <view class=\"selectedBtn\" bindtap=\"handleSelect\" data-is-selected=\"{{commodity.isselected}}\">\r\n    <view class=\"noSelected\" wx:if=\"{{commodity.isselected==0}}\"></view>\r\n    <image class=\"selectedImg\" wx:else src=\"/images/selected.png\"></image>\r\n  </view>\r\n  <view class=\"commodityInfo\">\r\n    <view class=\"commodityImg\">\r\n      <image src=\"{{commodity.image}}\"></image>          \r\n    </view>\r\n    <view class=\"commodityTitle\">\r\n      <view class=\"title\">{{commodity.title}}</view>\r\n      <view class=\"standard\">规格：{{commodity.standard?commodity.standard:'无'}}</view>\r\n      <view class=\"count\">\r\n        <view class=\"price\">￥{{commodity.price}}</view>\r\n        <view class=\"commodityNum\">\r\n          <i-input-number value=\"{{selectedNum}}\" min=\"1\" max=\"{{commodity.stock}}\" bindchange=\"numChange\" />\r\n        </view>\r\n      </view>\r\n    </view>\r\n  </view>\r\n  <view class=\"deleteBtn\">\r\n    <image class=\"deleteImg\" src=\"/images/delete.png\"></image>\r\n    <text class=\"deleteText\">删除</text>\r\n  </view>\r\n</view>子组件index.wxss/* 商品 */\r\n.commodityItem{\r\n  display: flex;\r\n  position: relative;\r\n  padding: 10rpx 24rpx 20rpx 30rpx;\r\n  box-sizing: border-box;\r\n  background: #fff;\r\n  transition: all .5s;\r\n}\r\n/* 选择按钮 */\r\n.selectedBtn{\r\n  display: flex;\r\n  align-items: center;\r\n  width: 80rpx;\r\n}\r\n.noSelected{\r\n  width: 46rpx;\r\n  height: 46rpx;\r\n  border-radius: 50%;\r\n  border: 1px solid #ef5225;\r\n}\r\n.selectedBtn .selectedImg{\r\n  width: 50rpx;\r\n  height: 50rpx;\r\n}\r\n/* 商品信息 */\r\n.commodityInfo{\r\n  display: flex;\r\n  width: calc(100% - 80rpx);\r\n}\r\n.commodityImg{\r\n  margin-right: 18rpx;\r\n  width: 220rpx;\r\n  height: 220rpx;\r\n}\r\n.commodityImg image{\r\n  width: 100%;\r\n  height: 100%;\r\n  vertical-align: middle;  \r\n}\r\n/* 商品title */\r\n.commodityTitle{\r\n  width: calc(100% - 220rpx);\r\n}\r\n.title{\r\n  display: -webkit-box;\r\n  width: 100%;\r\n  height: 70rpx;\r\n  line-height:35rpx;\r\n  font-size: 24rpx;\r\n  font-weight:600;\r\n  overflow: hidden;\r\n  -webkit-line-clamp: 2;\r\n  -webkit-box-orient: vertical;\r\n}\r\n.standard{\r\n  padding-top: 16rpx;\r\n  width: 100%;\r\n  height: 90rpx;\r\n  box-sizing: border-box;\r\n}\r\n.count{\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: space-between;\r\n  width: 100%;\r\n  height: 60rpx;\r\n}\r\n\r\n/* 删除按钮 */\r\n.deleteBtn{\r\n  display: flex;\r\n  position: absolute;\r\n  width: 70px;\r\n  height: 100%;\r\n  top: 0rpx;\r\n  right: -70px;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  justify-content: center;\r\n  background: #ef5225;\r\n}\r\n.deleteImg{\r\n  margin-bottom: 10rpx;\r\n  width: 50rpx;\r\n  height: 50rpx;\r\n  vertical-align: middle;\r\n}\r\n.deleteText{\r\n  color: #fff;\r\n}子组件index.json，这里用了iview中的数字输入框{\r\n  \"component\": true,\r\n  \"usingComponents\": {\r\n    \"i-input-number\": \"/component/iview/input-number/index\"\r\n  }\r\n}子组件index.jsComponent({\r\n\r\n  properties: {\r\n    commodity: Object,\r\n  },\r\n\r\n  data: {\r\n    touchStart: null,\r\n    rightSpace: 0,\r\n    selectedNum: 1,\r\n  },\r\n\r\n  methods: {\r\n    /* 商品是否选中 */\r\n    handleSelect() {\r\n            let selectedNum = this.data.selectedNum;\r\n      let commodity = this.data.commodity;\r\n      if(commodity.isselected == 0) {\r\n        commodity.isselected = 1;\r\n      } else {\r\n        commodity.isselected = 0;\r\n      }\r\n            this.triggerEvent('handleselect', { commodity, selectedNum})\r\n    },\r\n    /* 处理触摸滑动开始 */\r\n    handleTouchStart(e) {\r\n      /* 记录触摸滑动初始位置 */\r\n      let touchStart = e.changedTouches[0].clientX;\r\n      this.setData({\r\n        touchStart\r\n      })\r\n    },\r\n    /* 处理触摸滑动 */\r\n    handleTouchMove(e) {\r\n      console.log(e)\r\n      let moveSpace = e.changedTouches[0].clientX;\r\n      let touchStart = this.data.touchStart;\r\n      if (touchStart != null) {\r\n        if (moveSpace - touchStart > 70) {\r\n          this.setData({\r\n            touchStart: null,\r\n            rightSpace: 0\r\n          })\r\n        }\r\n        else if (moveSpace - touchStart < -70) {\r\n          this.setData({\r\n            touchStart: null,\r\n            rightSpace: 70\r\n          })\r\n        }\r\n      }\r\n    },\r\n    numChange(e) {\r\n        let selectedNum = e.detail.value;\r\n        let commodity = this.data.commodity;\r\n        this.setData({\r\n            selectedNum\r\n        })\r\n        this.triggerEvent('handleselect', { commodity, selectedNum})\r\n    }\r\n  }\r\n})3.父组件实现父组件index.wxml，这里用的是假数据，所以操作上会有一些是联调时不必要的操作<view class=\"cart\">\r\n  <view class=\"item\" wx:for=\"{{cartList}}\" wx:key=\"{{items.shopid}}\" wx:for-item=\"items\">\r\n    <view class=\"storeInfo\">\r\n      <image class=\"avatar\" src=\"{{items.logo}}\"></image>\r\n      <view class=\"storeName\">{{items.shopname}}</view>\r\n    </view>\r\n    <view class=\"discount\">满￥100包邮，满10件包邮</view>\r\n    <view class=\"commodity\" wx:for=\"{{items.commodity}}\" wx:key=\"{{item.id}}\">\r\n      <cart-item commodity=\"{{item}}\" bind:handleselect=\"handleSelect\" />\r\n    </view>\r\n  </view>\r\n    <view class=\"count\">\r\n        <view class=\"selectAll\" bindtap=\"handleSelectAll\">\r\n            <view class=\"noSelected\" wx:if=\"{{!isSelectedAll}}\"></view>\r\n        <image class=\"selectedImg\" wx:else src=\"/images/selected.png\"></image>\r\n            <text class=\"selectAllText\">全选</text>\r\n        </view>\r\n        <view class=\"countPrice\">\r\n      <text>合计:</text>\r\n      <text>￥{{countPrice}}</text>\r\n    </view>\r\n        <view class=\"account\">\r\n      <text>结算</text>\r\n      <text>({{countSelectedNum}})</text>\r\n    </view>\r\n    </view>\r\n</view>父组件index.wxsspage{\r\n  background: #f8f8f8;\r\n}\r\n.cart{\r\n    padding-bottom: 100rpx;\r\n  font-size: 26rpx;\r\n}\r\n.item{\r\n  border-bottom: 1px solid #eee;\r\n}\r\n/* 头部店铺信息 */\r\n.storeInfo{\r\n  display: flex;\r\n  padding: 18rpx 0rpx 18rpx 30rpx;\r\n  background: #fff;\r\n  box-sizing: border-box;\r\n}\r\n.storeInfo .avatar{\r\n  width: 56rpx;\r\n  height: 56rpx;\r\n  border-radius: 50%;\r\n  vertical-align: middle;\r\n}\r\n.storeInfo .storeName{\r\n  margin-left: 16rpx;\r\n  line-height: 56rpx;\r\n}\r\n/* 包邮信息 */\r\n.discount{\r\n  padding-left: 30rpx;\r\n  height:50rpx;\r\n  line-height: 50rpx;\r\n  font-size:20rpx;\r\n  color: #666;\r\n  box-sizing: border-box;\r\n}\r\n/* 底部操作 */\r\n.count{\r\n    display: flex;\r\n    position: fixed;\r\n    padding-left: 30rpx;\r\n    bottom: 0;\r\n  left: 0;\r\n    width: 100%;\r\n    height: 100rpx;\r\n    line-height: 100rpx;\r\n  box-sizing: border-box;\r\n  color: #232323;\r\n    background: #eee;\r\n}\r\n/* 全选 */\r\n.selectAll{\r\n    display: flex;\r\n  padding-right: 20rpx;\r\n    align-items: center;\r\n    width: 25%;\r\n  font-size: 30rpx;\r\n}\r\n.selectAll .noSelected{\r\n  width: 46rpx;\r\n  height: 46rpx;\r\n  border-radius: 50%;\r\n  border: 1px solid #ef5225;\r\n}\r\n.selectAll .selectedImg{\r\n  width: 50rpx;\r\n  height: 50rpx;\r\n}\r\n.selectAllText{\r\n    margin-left: 18rpx;\r\n}\r\n\r\n.countPrice{\r\n    position: absolute;\r\n  top: 0;\r\n  right: 270rpx;\r\n  height: 100%;\r\n  line-height: 100rpx;\r\n  text-align: center;\r\n  font-size: 30rpx;\r\n}\r\n.countPrice text{\r\n  margin-right: 15rpx;\r\n}\r\n.account{\r\n  position: absolute;\r\n  top: 0;\r\n  right: 0;\r\n    width: 270rpx;\r\n  height: 100%;\r\n  line-height: 100rpx;\r\n  text-align: center;\r\n  font-size: 30rpx;\r\n  background: #ef5225;\r\n  color: #fff;\r\n}父组件index.json，引用子组件{\r\n  \"usingComponents\": {\r\n    \"cart-item\": \"/component/cart/index\"\r\n  }\r\n}父组件index.jsPage({\r\n\r\n  data: {\r\n    cartList: [\r\n      {\r\n        shopname: '猫咪小店',\r\n        logo: '/images/avatar.jpeg',\r\n        shopid: 11,\r\n        commodity: [\r\n          {\r\n            id: 1,\r\n            image:'/images/commodity.jpg',\r\n            title: '雅诗兰黛鲜活焕亮红石榴晚霜50ml 补水保湿 滋润排浊',\r\n            standard: '111 + 黑色',\r\n            price: '100',\r\n            stock: 10,\r\n            quantity: 1,\r\n            isselected: 0,\r\n          }, \r\n          {\r\n            id: 2,\r\n            image:'/images/avatar7.jpg',\r\n            title: '雅诗兰黛鲜活焕亮红石榴晚霜50ml 补水保湿 滋润排浊',\r\n            price: '10',\r\n            stock: 5,\r\n            quantity: 1,\r\n            isselected: 0,\r\n          }\r\n        ]\r\n      },\r\n      {\r\n        shopname: '猫咪小店',\r\n        logo: '/images/avatar5.jpg',\r\n        shopid: 450,\r\n        commodity: [\r\n          {\r\n            id: 3,\r\n            image:'/images/commodity.jpg',\r\n            title: '雅诗兰黛鲜活焕亮红石榴晚霜50ml 补水保湿 滋润排浊',\r\n            price: '90',\r\n            stock: 10,\r\n            quantity: 1,\r\n            isselected: 0,\r\n          },\r\n          {\r\n            id: 4,\r\n            image:'/images/avatar7.jpg',\r\n            title: '雅诗兰黛鲜活焕亮红石榴晚霜50ml 补水保湿 滋润排浊',\r\n            price: '100',\r\n            stock: 5,\r\n            quantity: 1,\r\n            isselected: 0,\r\n          }, \r\n          {\r\n            id: 5,\r\n            image:'/images/commodity.jpg',\r\n            title: '雅诗兰黛鲜活焕亮红石榴晚霜50ml 补水保湿 滋润排浊',\r\n            standard: '111 + 黑色',\r\n            price: '100',\r\n            stock: 2,\r\n            quantity: 1,\r\n            isselected: 0,\r\n          }\r\n        ]\r\n      },\r\n      {\r\n        shopname: '猫咪小店',\r\n        logo: '/images/avatar.jpeg',\r\n        shopid: 550,\r\n        commodity: [\r\n          {\r\n            id: 6,\r\n            image:'/images/avatar8.jpg',\r\n            title: '雅诗兰黛鲜活焕亮红石榴晚霜50ml 补水保湿 滋润排浊',\r\n            standard: '111 + 黑色',\r\n            price: '100',\r\n            stock: 1,\r\n            quantity: 1,\r\n            isselected: 0,\r\n          }\r\n        ]\r\n      },\r\n    ],\r\n        /* 商品是否全选中 */\r\n        isSelectedAll: false,\r\n        /* 已选中商品的价格 */\r\n        countPrice: 0,\r\n    /* 统计所有选中的商品数量 */\r\n    countSelectedNum: 0,\r\n  },\r\n  /* 处理商品选中 */\r\n  handleSelect(e) {\r\n        let countPrice = 0;\r\n    let countSelectedNum = 0;\r\n    let cartList = this.data.cartList;\r\n    let length = cartList.length;\r\n\r\n        /* 因为是假数据，所以需要循环查找到对应的数据将其替换 */\r\n    for(let i = 0; i < length; i++) {\r\n      for(let j = 0; j < cartList[i].commodity.length; j++) {\r\n                if (cartList[i].commodity[j].id == e.detail.commodity.id) {\r\n          cartList[i].commodity[j] = e.detail.commodity;\r\n          cartList[i].commodity[j].selectedNum = e.detail.selectedNum;\r\n        }\r\n        if (cartList[i].commodity[j].isselected == 1) {\r\n          /* 点击选中的时候，计算价格，要判断下设置的商品选中数量，\r\n           * 我这里的是对点击了的商品才设置了选中的数量，所以需要对没有点击的商品数量设置为1，然后就默认的加一\r\n           */\r\n          if (cartList[i].commodity[j].selectedNum != undefined) {\r\n            countPrice += cartList[i].commodity[j].price * cartList[i].commodity[j].selectedNum;\r\n            countSelectedNum += cartList[i].commodity[j].selectedNum\r\n          } else {\r\n            countPrice += cartList[i].commodity[j].price * 1;\r\n            countSelectedNum += 1;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n        /* 对是否全选中进行判断 */\r\n        let isSelectedAll = true;\r\n        for (let i = 0; i < length; i++) {\r\n            for (let j = 0; j < cartList[i].commodity.length; j++) {\r\n                /* 若商品中的isselecetd有为0的就终止循环，直接设置为未全选 */\r\n                if (cartList[i].commodity[j].isselected == 0) {\r\n                    isSelectedAll = false;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n    this.setData({\r\n      cartList,\r\n            isSelectedAll,\r\n            countPrice,\r\n      countSelectedNum\r\n    })\r\n  },\r\n    /* 全选中商品 */\r\n    handleSelectAll() {\r\n        let isSelectedAll = !this.data.isSelectedAll;\r\n        let cartList = this.data.cartList;\r\n        let length = cartList.length;\r\n    let countPrice = 0;\r\n    let countSelectedNum = 0;\r\n\r\n        /* 遍历数据中的isselected来进行全选的操作 */\r\n        for(let i = 0; i < length; i++) {\r\n            for (let j = 0; j < cartList[i].commodity.length; j++) {\r\n                if(isSelectedAll) {\r\n                    cartList[i].commodity[j].isselected = 1;\r\n          /* 全选的时候，计算价格，要判断下设置的商品选中数量，\r\n           * 我这里的是对点击了的商品才设置了选中的数量，所以需要对没有点击的商品数量设置为1，然后就默认加一\r\n           */\r\n          if (cartList[i].commodity[j].selectedNum != undefined) {\r\n            countPrice += parseInt(cartList[i].commodity[j].price) * cartList[i].commodity[j].selectedNum;\r\n            countSelectedNum += cartList[i].commodity[j].selectedNum;\r\n          } else {\r\n            countPrice += cartList[i].commodity[j].price * 1;    \r\n            countSelectedNum += 1;        \r\n          }\r\n                } else {\r\n                    cartList[i].commodity[j].isselected = 0;\r\n                }\r\n            }\r\n        }\r\n\r\n        this.setData({\r\n            isSelectedAll,\r\n            cartList,\r\n      countPrice,\r\n      countSelectedNum\r\n        })\r\n    },\r\n})4.父子组件传值较常用的都是父组件往子组件传值，所以子组件往父组件传值就会不是很熟悉我这里的话，是因为用的假数据，在点击商品选中或者不选中时，需要改变商品里的选中属性，所以用到了子组件往父组件传值，也包括传递选中的商品数量子组件往父组件传值的话，是通过在调用this.triggerEvent()来实现的/* 在父组件中定义方法：bind:handleselect或者也可以直接写成bindhandleselect*/\r\n<cart-item commodity=\"{{item}}\" bind:handleselect=\"handleSelect\" />在子组件中调用this.triggerEvent('handleselect', { commodity, selectedNum})这个this.triggerEvent('handleselect', { commodity, selectedNum })方法中，handleselect的名称要与父组件中引用子组件时绑定的方法名称一样，后面的对象就是传递的值，也可以直接是以直接量的形式传递，然后再父组件中通过e.detail来获取对应的值handleSelect(e) {\r\n    console.log(e.detail)\r\n    console.log(e.detail.commodity)\r\n    console.log(e.detail.selectedNum)\r\n}5.calc的注意事项我以前也遇到过，然后现在再用的时候，一时间把这点给忘了，在看到编译器样式的时候，才猛然想起.user-content{\r\n    padding: 10px 0 10px 50px;\r\n    width: calc(100% - 50px);  /* 计算宽度，'+'或'-'符号前后有空格 */\r\n    height: 18px;\r\n}css中使用calc可以进行简单的运算：单位可以是百分比，px，rem，em等单位使用\"+\",\"-\",\"*\",\"/\"运算符（使用\"+\"或者\"-\"符号时，符号前后必须加上空格）在Firefox浏览器上使用要加上-moz前缀chrome浏览器上使用要加上-webkit前缀（使用\"+\"或者\"-\"符号时，符号前后必须加上空格）6.部分想法其实在样式上还是挺快就完成了，就是在计算商品价格的时候，想了挺久在计算价格时，当时就有点蒙圈，总是想着要怎么判断他是增加数量还是减少数量，然后就陷入死循环的之中。其实不用想她是增加还是减少数量，因为你都是传的是商品的数量，而且在计算时，也是判断了商品是否选中，所以，直接点，计算价格乘以数量就可以了然后选中的商品数量的统计就和计算价格的思路是一样的了正在努力学习中，若对你的学习有帮助，留下你的印记呗（点个赞咯^_^）往期好文推荐：判断iOS和Android及PC端css实现波浪线及立方体微信小程序中遇到的多规格问题(一)实现单行及多行文字省略号"}
{"title": "去除富文本中的html标签及vue、react、微信小程序中的过滤器 ", "author": "Rolan", "time": "2018-11-21 00:38", "content": "1.富文本去除html标签去除html标签及 空格let richText = ' <p style=\"font-size: 25px;color: white\">&nbsp; &nbsp; &nbsp; &nbsp;sdaflsjf的丰富及饿哦塞尔</p><span>dsfjlie</span>';\r\n\r\n/* 去除富文本中的html标签 */\r\n/* *、+限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。*/\r\nlet content = richText.replace(/<.+?>/g, '');\r\nconsole.log(content);\r\n\r\n/* 去除&nbsp; */\r\ncontent = content.replace(/&nbsp;/ig, '');\r\nconsole.log(content);\r\n\r\n/* 去除空格 */\r\ncontent = content.replace(/\\s/ig, '');\r\nconsole.log(content);截取字符串content = formatRichText(content);\r\nconsole.log(content);\r\n\r\n/* 使用substring来截取字符串 */\r\nif (content.length > 10) {\r\n    content = content.substring(0, 10) + '...';\r\n}\r\nconsole.log(content);\r\n\r\n/* 限制字数后添加省略号 */\r\nfunction formatRichText(richText) {\r\n    let temporaryText = '';\r\n    /* 设置多长后添加省略号 */\r\n    const len = 142;\r\n    if (richText.length * 2 <= len) {\r\n        return richText;\r\n    }\r\n    /* 用于记录文字内容的总长度 */\r\n    let strLength = 0;\r\n    for (let i = 0; i < richText.length; i++) {\r\n        temporaryText = temporaryText + richText.charAt(i);\r\n        /* charCodeAt()返回指定位置的字符的Unicode编码，值为128以下时一个字符占一位，当值在128以上是一个字符占两位 */\r\n        if (richText.charCodeAt(i) > 128) {\r\n            strLength = strLength + 2;\r\n            if (strLength >= len) {\r\n                return temporaryText.substring(0, temporaryText.length - 1) + \"...\";\r\n            }\r\n        } else {\r\n            strLength = strLength + 1;\r\n            if (strLength >= len) {\r\n                return temporaryText.substring(0, temporaryText.length - 2) + \"...\";\r\n            }\r\n        }\r\n    }\r\n    return temporaryText;\r\n}2.vue中使用过滤器filters: {\r\n    localData(value) {\r\n        let date = new Date(value * 1000);\r\n        let Month = date.getMonth() + 1;\r\n        let Day = date.getDate();\r\n        let Y = date.getFullYear() + '年';\r\n        let M = Month < 10 ? '0' + Month + '月' : Month + '月';\r\n        let D = Day + 1 < 10 ? '0' + Day + '日' : Day + '日';\r\n        let hours = date.getHours();\r\n        let minutes = date.getMinutes();\r\n        let hour = hours < 10 ? '0' + hours + ':' : hours + ':';\r\n        let minute = minutes < 10 ? '0' + minutes : minutes;\r\n        return Y + M + D + ' ' + hour + minute;\r\n    }\r\n}\r\n\r\n/* 使用，直接在div中添加就可以了，| 前面的是参数，后面的是过滤器 */\r\n<div class=\"time\">{{data.etime | localData}}</div>3.微信小程序中使用过滤器新建.wxs文件var localData = function (value) {\r\n    var date = getDate(value * 1000);\r\n    var Month = date.getMonth() + 1;\r\n    var Day = date.getDate();\r\n    var hours = date.getHours(); //计算剩余的小时\r\n    var minutes = date.getMinutes(); //计算剩余的分钟\r\n    var Y = date.getFullYear() + '-';\r\n    var M = Month < 10 ? '0' + Month + '-' : Month + '-';\r\n    var D = Day + 1 < 10 ? '0' + Day + '' : Day + '';\r\n    var H = hours < 10 ? '0' + hours + ':' : hours + ':'\r\n    var m = minutes < 10 ? '0' + minutes : minutes;\r\n    return Y+M + D + \"   \" + H + m;\r\n}\r\nmodule.exports = {\r\n    localData: localData\r\n}使用,用<wxs />标签来引入，src为路径，module为引入的文件模块名<wxs src=\"./filters.wxs\" module=\"tool\" />\r\n<text class=\"scoreText\">{{tool.filterScore(item.shop.score)}}分</text>直接在.wxml文件中用<wxs></wxs>包裹<wxs module=\"foo\">\r\nvar some_msg = \"hello world\";\r\nmodule.exports = {\r\n    msg : some_msg,\r\n}\r\n</wxs>\r\n<view> {{foo.msg}} </view>4.react中使用react中使用，其实就是定义一个方法import noBanner from '@/assets/storeDetail/no-banner.jpg'\r\nconst filterImg = item => {\r\n    let bgImg;\r\n    if (item.shopimages == null) {\r\n        bgImg = noBanner;\r\n    } else {\r\n        bgImg = item.shopimages[0];\r\n    }\r\n    return bgImg;\r\n};\r\n/* 使用 */  \r\n<img src={filterImg(storeitem)} className={style.topImg} alt=\"\" />正在努力学习中，若对你的学习有帮助，留下你的印记呗（点个赞咯^_^）往期好文推荐：判断iOS和Android及PC端纯css实现瀑布流（multi-column多列及flex布局）实现多行文字及单行的省略号微信小程序之购物车和父子组件传值及calc的注意事项"}
{"title": "微信小程序实现显示和隐藏控件-头像-取值-bindblur事件 ", "author": "Rolan", "time": "2018-11-21 00:56", "content": "小程序实现显示和隐藏控件\" style=\"margin: 20px 0px; padding: 0px; font-size: 21px; line-height: 1.5; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; background-color: rgb(255, 255, 255);\">微信小程序实现显示和隐藏控件.wxml: <view class=\" {{showOrHidden?'show':'hidden'}}\"></view>.wxss:.hidden {\r\n  display: none;\r\n}\r\n \r\n.show {\r\n  display: block;\r\n}.js: data: {\r\n    showOrHidden:true,\r\n    //判断显示与否的，true表示显示，反之隐藏\r\n },简洁的方式，利用wx:if的方式.wxml:<view wx:if='{{showOrHidden}}'></view>.js: data: {\r\n    showOrHidden:true,\r\n    //判断显示与否的，true表示显示，反之隐藏\r\n  },点击按钮隐藏view并显示另个view<view class=\"{{showView?'show':'hidden'}}\" >\r\n <button class='show-button' bindtap='showButton'>go</button>\r\n</view>data: {\r\n    showView: true,\r\n},\r\nshowButton:function(){\r\n    var that = this;\r\n    that.setData({\r\n      showView: (!that.data.showView)\r\n    })\r\n }头像<open-data type=\"userAvatarUrl\" class='img'></open-data>     .img {\r\n  width: 200rpx;\r\n  height: 200rpx;\r\n  margin: 20rpx;\r\n  border-radius: 50%;\r\n  display: flex;\r\n  overflow:hidden;\r\n}input输入框和form表单传值和取值方式实现方式\r\ndata-index=\"{{index}}\"\r\ne.currentTarget.dataset.indexform表单取值\r\n<form bindsubmit=\"formSubmit\">与<button formType=\"submit\">\r\n\r\nformSubmit: function(e) {\r\n  var detail = e.detail.value.detail;\r\n}bindblur事件<textarea bindblur=\"bindTextAreaBlur\" auto-height placeholder=\"请输入内容\" value=\"{{ceshi}}\" />"}
{"title": "微信小程序开发系列教程第七章：编辑名片页面开发 ", "author": "admin", "time": "2016-10-12 22:14", "content": "编辑名片有两条路径，分为新增名片流程与修改名片流程。用户手填新增名片流程：首先跳转到我们的新增名片页面 1 需要传递用户的当前 userId，wx.navigateTo 带值跳转。Manual 为 true 设置用户走的是新增路线。新增名片页面 1 基本布局如下：取到 userId。使用微信自带的 input 组件验证也非常好用，如 maxLength 属性，可以限制用户输入长度，如我这的姓名长度是最大 5 位，直接数字 5 即可。也可以自定义一些验证效果，具体可以根据需求进行一些验证配置，取到用户输入的值，进行操作。这里绑定了自带的模态框提示组件。其中 modalHidden2 是模态框开关。另外 proptText 是需要提示的内容。即使很多输入框也支持数据动态改变，非常方便。实际效果，非常快捷，比以前省去很多事情，编写小程序，发现最大的好处可能就是我们不必去考虑一系列兼容性问题。最后还有个头像上传图片，测试了下目前上传到后台服务器还有点问题，应该是内测版本不太完善导致吧。设置的直接是背景图片。提交表单与跳转。提交表单使用的是自带的 bindsubmit 事件组件，在 button 组件上添加 formType=”submit” 即可，还有点需注意的是使用表单提交功能时 input 需加上 name 属性，这个传递方式是以键值对的形式传递的。这时候跳转到编辑页 2 页面，这个页面是根据用户填写的手机号码识别到匹配的公司，页面非常简单，一个数据循环而已，单选框日后可能还需要美化一下。同样也是一些数据绑定以及验证效果。实际渲染效果可以看到。这个和第一个编辑页面逻辑基本不相上下，一些基本验证与提交，这里就讲到前面两步骤即可，编辑页面3也是同理，这里不再过多啰嗦。修改名片流程效果图与需求，修改名片是一次性把以前填写的个人信息全部渲染出来，供用户来改动：名片图片模块，上传图片暂时还有点问题，这里就是模仿了个跳转组件，比较建议需要跳转的页面还是使用 wx.navigateTo 控制好一点，wx.navigateTo 提供了给我们不同的 3 个跳转路由，封装的都很好，而且跳转页面很多牵连到传值之类的，可以达到统一管理也可以避免一些看不到的 bug 吧，总之还是根据业务需求来定：姓名手机必填模块：个人信息模块，直接循环（block）出来：Onload 时我们请求必填与选填数据：* requiredGroup 必填中文信息* notRequiredGroup 选题中文信息* requiredGroupEn 必填英文信息* notRequiredGroupEn 选题英文信息```//请求名片对应的公司的中文信息的属性组数据，分为必填和选填//选题项变量以 no 开头requester.getOfflineCardInfoGroupFields(userId, cardId,function (res) {//debuggervar userName = res.card.userName;var mobile = res.card.mobile;var requiredGroup = res.requiredGroupCh;var notRequiredGroup = res.notRequiredGroupCh;var requiredGroupEn = res.requiredGroupEn;var notRequiredGroupEn = res.notRequiredGroupEn;var reqLen = requiredGroup.fields.length;var nreqLen = notRequiredGroup.fields.length;var reqLenEn = requiredGroupEn.fields.length;var nreqLenEn = notRequiredGroupEn.fields.length;self.setData({userName: userName,mobile: mobile,requireFields: requiredGroup.fields,notRequireFields: notRequiredGroup.fields,requireFieldsEn: requiredGroupEn.fields,notRequireFieldsEn: notRequiredGroupEn.fields,l1: reqLen,l2: nreqLen + reqLen,l3: reqLenEn + nreqLen + reqLen});self.forceUpdate();}, function (code, msg) {console.info(\"code=\" + code + \"&msg=\" + msg);});```中英文信息必填与选填渲染：这里表单提交数据转换有点复杂（大家根据业务需求来做，不必花时间研究这里的方法），获取的是数组，按照后台需要的数据格式进行转换传递过去。今天再回去理下首页 A、B、C 定点跳转功能实现方法。首先是右边小索引布局以及数据绑定，数据绑定和名片夹列表上的字母一样，该字母下面有名片则渲染出来，没有则不需要渲染，id同样是当前字母与右边显示的内容一样：数据 sort，和 group.name 数据一样：这里是因为 # 不支持设为 id（就是 id=”#”），故而进行了一个转化。点击事件：获取到当前 ID，以及绑定数据 toView 为当前 ID。首先名片列表，名片上的字母索引都在 scroll-view 里面，这个 scroll-view 必须设置好固定的高度，设置成 100% 与 100vh 是无效的，y 轴的滚动开关打开，scroll-into-view 需要跳转到它子元素的 id 上。可以看下：这个 group.name==sortmsg，等于就是 A==A,B==B 同理。在这里如顶部有些菜单栏的话，你就要注意好布局了，不然会出现向下偏移这个菜单栏的高度，其实你只要和字母索引同级下即可避免此问题（这里的顶部菜单以模板分离出去了，分离模板的时候需注意下，需要在这里绑定模板的一些数据会出现失效，具体没有继续深入研究下去）。跳转功能基本实现（ohter 就是 # 底部）。"}
{"title": "美团扫码付小程序的优化实践 ", "author": "Rolan", "time": "2018-9-14 00:12", "content": "短短几年的时间，微信小程序已经从一颗小小的萌芽成长为参天大树，形成了较大规模的开发者生态系统，尤其是在支付、线下垂直领域潜力巨大。作为领先的生活服务平台，美团的技术团队在小程序领域也进行了很多的探索和实践。像mpvue就是一款使用Vue.js开发微信小程序的前端框架，而且已经在美团点评多个实际业务项目中得到了验证，详细介绍大家可以阅读《 用Vue.js开发微信小程序：开源框架mpvue解析 》一文。目前，mpvue已经开源，项目地址是： https://github.com/Meituan-Dianping/mpvue。本文将介绍扫码付小程序的实践，根据美团前端工程师陈瑶在美团第31期技术沙龙（点击可以查看这次沙龙四场演讲的Slides和视频）的演讲《金融扫码付H5迁移小程序拓荒之旅》整理而成。什么是扫码付小程序？美团扫码付是一款面向C端消费者推出的线下收单业务，相信大家已经在线下很多餐馆和其他生活服务商家体验过了。这项业务主要就是通过小程序提供服务的，而在实际场景中，用户先使用微信“扫一扫”功能，扫描商家二维码，系统会自动调用扫码付小程序，进入支付页面，最后输入金额完成商品的支付。目标及数据分析支付服务最核心的指标，显然就是用户支付成功的占比，我们称之为支付转化率。对扫码付业务而言，支付转化率的百分比越高，扫码付业务的营业额也就越高，其带来的收益是正相关的。因此提升扫码付小程序的支付转化率，就成为我们技术团队的重要工作。经过数据分析，我们发现转化率流失主要存在于以下两个环节：扫码到进入小程序环节（外部环节）进入小程序到支付环节（内部环节）从扫码到进入小程序环节，微信会完成小程序基本信息获取、资源准备（代码下载或更新）等准备事项。在准备事项中，如果准备失败或等待时间过长，就会导致用户离开，这部分由微信控制的环节，我们称之为外部环节。在进入小程序到支付环节，页面会进行渲染、数据请求等，如果渲染时间长、数据请求时间长也容易导致用户离开，同样，如果数据请求失败也会造成用户使用过程的终止，这部分由我们美团扫码付技术团队控制的环节，称之为内部环节。如何提升外部环节转化率？对于小程序开发者而言，扫码到小程序调起这个环节是黑盒的，我们无法得知其中的细节。而我们在扫码付小程序中尝试和微信的同学做了一次梳理，发现扫码付小程序在外部环节的丢失率较高，查询数据后，我们发现其中大部分用户手动点击了右上角的退出。从业务视角出发，用户使用扫码付小程序，可认为他们有强需求进行支付，而造成用户手动点击退出的部分原因可能是等待时间过长。而在这个环节对时间造成影响更多的是资源准备，即小程序代码下载或者更新的行为。根据经验，影响下载和更新时间可能的因素包括两个方面：一个是网络，另一个是代码包。因为用户的网络是我们无法控制的，只能尝试从代码包开始下手。而在当时未使用分包的情况下，我们的主包大小约为3M，这意味着新用户和无缓存小程序用户均需要在首次使用时等待下载3M左右的包。在这种情况下，虽然用户享受了小程序离线缓存包的福利，却丢失了大部分新用户的体验。于是我们尝试从包代码层面做一些优化：增加分包加载机制。用户在使用扫码付业务时会按需进行加载，优化小程序首次启动的下载时间。减小主包和分包大小。按照空主包的概念进行优化。在进行分包加载机制后，主包因为无法最小化而影响首次下载时间。一方面，原有的3M整包中，图片大小占用了50%大小，我们将所有的内含二进制和Base64图片分发到了CDN；另一方面，部分可移出的业务分发到了其他分包。在做了这些事情后，扫码付分包从原先的整包3M缩减到了361K（主包300K+分包61K），而外部环节的转化率也提升了3%。虽然转化率提升了，但前置环节的转化率仍然有部分丢失，理论上继续缩减300K的主包能有效提升，但由于业务性质的原因无法再继续缩减，于是我们向微信小程序提出了独立分包的概念：用户在使用独立分包时无需下载主包。通过独立分包加载，程序使用期间下载更新阶段，只需要加载61K的分包大小。目前这个功能还在灰度阶段，扫码付小程序团队也在作为第一批的内测用户进行体验，优化效果在之后的实践中，我们也会分享出来，大家可关注美团技术团队公众号，持续关注我们。如何提升内部环节转化率？在进入小程序到支付这个环节，属于我们的业务流程。在这个环节中的转化率丢失虽然我们能够掌控，但是必须有所依据，才能对症下药。所以我们做了一些数据监控：业务核心流程监控。业务核心流程指用户进入小程序后所涉及的影响最终支付的中间流程，中间流程的丢失会直接影响业务整个转化率丢失，所以这里必须进行监控。而业务核心流程监控需要可监控的具体指标，我们对进入小程序和支付进行了关键动作拆解，从开始扫码到用户看到页面，再到点击支付、初始化订单、支付成功。拆解完这些关键动作，再针对每一步可控环节，进行技术指标的拆解。从入口到出口的每一步制定关键指标（扫码加载转化率、点击意愿等，见下图），形成一个至上而下的漏斗，产出多个可量化指标，来做业务流程的监控。对于这部分可量化指标，可以通过长期的观察分析来提升转化率。异常监控。页面的任何异常都可能导致支付页面的渲染失败，从而无法正常支付。我们对页面的接口异常、微信API异常进行了监控。接口异常可在API（wx.request）的fail函数中直接捕获，从而上报监控；对于接口超时，则只能通过全局的app.json进行全局设置（默认60s，时间过长，对用户体验较差），此前我们曾尝试在小程序中设置全局的5s请求超时，但实际应用中并非所有场景需要设置统一的超时，最终我们单独封装了接口请求超时。微信API的异常通过微信的一些fail中进行监控即可。性能监控。小程序内部转化环节中关注进入小程序后的白屏时间和可交互时间。内部白屏时间从onLoad处打点，到页面onReady处结束；内部可交互时间从onLoad处打点，到页面数据请求结束后的可点击支付时间截止。日常监控中，我们也发现了一些问题，例如接口调用超时、接口调用失败，这些问题会导致页面流程终止。针对这些问题我们做了一些优化：接口合并。支付页面的外网链路接口请求数量较多，任意一个接口的失败都会导致问题，合并接口则可以减少问题出现概率，提升中间流程的转化率。增加重试机制。在出现接口异常的情况下，会直接导致页面阻塞，如果通过重试能成功，则可以提升转化率。整个流程中可重试的有两类：自有的接口请求异常，小程序API调用异常。对于这两类异常，在接口超时、调用失败时采取重试。而为了避免在极端情况下服务端流量陡增、峰值倍数增加，页面的可重试次数会在前置获取全局配置时根据“可重试次数”进行控制，并且每次重试需要在一段时间后用户手动触发。超过重试次数时，则流程终止。如何监控内部和外部环节？前面我们也提到，对于小程序开发者而言，扫码到小程序调起这个环节是黑盒的，我们开发者无法得知此处的细节，所以说在监控外部环节这方面我们开发者似乎可做的事情屈指可数。但是，不知道细心的同学有没有发现，微信在每次扫码后会给我们在query参数上附带一个scancode_time字段。其实这个字段表示的是用户在使用扫一扫时微信服务端记录的时间，所以基于这个字段的考量，我们做了如下尝试，针对以下两个参数值分别做了实时监控：支付页面的白屏时间（用户看到首屏的客户端时间—用户微信扫一扫服务端时间+服务端客户端差额时间）。支付页面的用户可交互时间（页面Loading完毕时间—用户微信扫一扫服务端时间+服务端客户端差额时间）。由于客户端的时间戳是获取本地手机系统的时间，可能存在差异。所以为了保证上报的准确性，我们在每次onLoad的时候取了一次我们服务端的时间，记录了客户端的时间与服务端的一个时间差额，并且在后续所有涉及到服务端的时间都参照这个时间差额做计算（网络100-200ms级别的传输时延，暂可忽略）。但由于我们扫码付小程序的特殊应用场景就是为了保障用户进行快速可靠的支付，既然在外部环节可控度不高，那是不是可以考虑在内部的业务流程方面把监控统计做的细粒度一点，做到能对每一个可能影响到支付的环节有数据可循呢？我们针对这个方向，区别于传统的PV、UV统计，并对业务上报做了如下分类：根据上报的场景划分：实时性监控部分与统计部分。根据上报的类型划分：Error类型、Event类型（普通生命周期事件）、Metric类型（自定义Event类型，维度可自定义）、自定义测速类型（延时趋势与分布）。基于上述方案的探索，我们团队基本上做到了对可能影响支付环节的很多业务指标，进行了整体的把控。从而在下一步，针对每个潜在的可优化点做进一步思考与考量，然后作出及时的策略优化与更新。通过对扫码付小程序的探索，我们积累了很多优化经验。美团的价值观是追求卓越，对于能优化的方面，我们还会进一步去探索，也欢迎更多的同学跟我们一起讨论。作者简介陈瑶，2015年校招入职美团，此前参与过美团平台移动端触屏版的前端开发工作，从0到1参与了智能支付应用层的前端建设工作，现负责美团收单业务扫码付小程序业务。招聘如果对我们“智能支付大前端团队”感兴趣，可直接简历发送给（chenxuan03@meituan.com）。欢迎加入美团，跟我们一起探索未来。发现文章有错误、对内容有疑问，都可以关注美团技术团队微信公众号（meituantech），在后台给我们留言。我们每周会挑选出一位热心小伙伴，送上一份精美的小礼品。快来扫码关注我们吧！"}
{"title": "使用Taro框架开发小程序 ", "author": "Rolan", "time": "2018-9-20 00:27", "content": "最近一直在做小程序项目的开发，上手直接就是wepy, 风格跟vue差不多，整体上，还算稳定，开发起来比原生的效率要高一点；很多人也知道，mpvue就是用vue搭建的，但始终觉得，失去了路由的vue，就像失去了灵魂；虽然接下来要给大家安利的框架，也貌似失去了该灵魂- taro框架（ Taro 是一套遵循React 语法规范的 多端开发 解决方案。）taro开发文档： nervjs.github.io/taro/docs/R…有兴趣的可以去看看，在这里我将我初步入坑的学习过程，以及构建了大致矿建与大家分享下：一：安装 Taro 开发工具 @tarojs/clinpm install -g @tarojs/cli\r\n复制代码二：使用命令创建模板项目taro init taro-react-mini-program\r\n复制代码可以根据自己的需要，选择是否使用ts, sass或者less, 接着等安装好依赖，项目就构建完成；三：项目目录结构├── dist                   编译结果目录\r\n├── config                 配置目录\r\n|   ├── dev.js             开发时配置\r\n|   ├── index.js           默认配置\r\n|   └── prod.js            打包时配置\r\n├── src                    源码目录\r\n|   ├── pages              页面文件目录\r\n|   |   ├── index          index页面目录\r\n|   |   |   ├── index.js   index页面逻辑\r\n|   |   |   └── index.css  index页面样式\r\n|   ├── app.css            项目总通用样式\r\n|   └── app.js             项目入口文件\r\n└── package.json\r\n复制代码框架的使用和注意事项，文档中有介绍，我这边主要写一些项目配置和踩过的坑;这里需要先安装一些依赖npm install tslint stylelint tslint-config-prettier -D\r\n复制代码代码规范 .prettierrc{\r\n    \"stylelintIntegration\": true,\r\n    \"tslintIntegration\": true,\r\n    \"tabWidth\": 2,\r\n    \"singleQuote\": true,\r\n    \"semi\": false\r\n}\r\n复制代码.prettierignore/**/libs/**\r\ndist/\r\nlib/\r\n复制代码样式规范： .stylelintrc.jsmodule.exports = {\r\n  ignoreFiles: ['**/*.md', '**/*.ts', '**/*.tsx', '**/*.js']\r\n}\r\n复制代码.stylelintignore**/dist\r\n复制代码tslint.json{\r\n  \"extends\": [\"tslint:recommended\", \"tslint-config-prettier\"],\r\n  \"rules\": {\r\n    \"ordered-imports\": false,\r\n    \"object-literal-sort-keys\": false,\r\n    \"member-access\": false,\r\n    \"member-ordering\": false,\r\n    \"no-empty-interface\": false,\r\n    \"no-console\": [true, \"warning\"],\r\n    \"interface-name\": [true, \"never-prefix\"],\r\n    \"no-empty\": false,\r\n    \"quotemark\": [true, \"single\"]\r\n    // \"semicolon\": [false], // 结尾比较分号\r\n    // \"trailing-comma\": [false], // 结尾必须逗号\r\n    // \"requireForBlockBody\": true,\r\n  }\r\n}\r\n复制代码接着配置git的提交commit提交验证，需要安装对应的依赖包，可以从我的另外一篇文章看：juejin.im/post/5b9867…再加上自己配置一个.gitignore文件，就这样，我们将大致需要的配置文件都配置好了；看看效果：当有不规范的代码提交的时候把所有问题都解决之后提交，当然tslint以及其他的一些配置都是自定义的，可以自己配置。觉得麻烦的可以根据自己的“口味”配置项目然后我们就可以愉快的开发我们的项目，运行npm run dev:weapp,打开我们的小程序很多人反馈用原生的 Taro.request或者用第三方axios等等做异步请求总会有错，我没亲测，但是自己用promise封装了方法, 在根目录src文件夹下创建utils文件夹， 在这里我简单的模拟微信授权登录，以及检测session是否过期，绑定用户的场景写一个大概例子，接口为虚构：├── utils                 \r\n|   ├── api.ts            请求接口设置\r\n|   ├── http.ts           http公共请求文件\r\n|   └── index.ts          \r\n\r\n复制代码http.ts代码如下：import Taro from '@tarojs/taro'\r\nimport md5 from 'blueimp-md5'\r\n\r\ntype HttpMethods = 'GET' | 'POST' | 'PUT' | 'DELETE'\r\n\r\n// 后端是否支持json格式\r\nconst contentType = 'application/x-www-form-urlencoded'\r\n// const contentType = 'application/json'\r\n\r\nexport default class Http {\r\n  noNeedToken = ['mockFakeApi']\r\n\r\n  get(url: string, data: object) {\r\n    return this.commonHttp('GET', url, data)\r\n  }\r\n\r\n  post(url: string, data: object) {\r\n    return this.commonHttp('POST', url, data)\r\n  }\r\n\r\n  async commonHttp(method: HttpMethods, url: string, data: object) {\r\n    return new Promise<any>(async (resolve, reject) => {\r\n      Taro.showNavigationBarLoading()\r\n      try {\r\n        const res = await Taro.request({\r\n          url,\r\n          method,\r\n          data,\r\n          header: {\r\n            'content-type': contentType\r\n          }\r\n        })\r\n        Taro.hideNavigationBarLoading()\r\n        switch (res.statusCode) {\r\n          case 200:\r\n            return resolve(res.data.response)\r\n          default:\r\n            console.log(res.data.message)\r\n            reject(new Error(res.data.msg))\r\n        }\r\n      } catch (error) {\r\n        Taro.hideNavigationBarLoading()\r\n        reject(new Error('网络请求出错'))\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\n复制代码api.tsimport Http from './http'\r\n\r\nconst http = new Http()\r\n\r\n//  自动登录\r\nconst url = 'xxxxx'\r\nexport const login = (data: object) => http.post(url, data)\r\n\r\n复制代码index.ts (自定义公共处理接口文件)import Taro from '@tarojs/taro'\r\nimport { login } from './api'\r\n\r\n// 获取微信登录凭证\r\nexport const wxLogin = async () => {\r\n  try {\r\n    const res = await Taro.login()\r\n    return res.code\r\n  } catch (error) {\r\n    console.log('微信获取临时凭着失败')\r\n  }\r\n}\r\n\r\nexport const userLogin = async () => {\r\n  try {\r\n    await Taro.checkSession()\r\n    if (!Taro.getStorageSync('token')) {\r\n      throw new Error('本地没有缓存token')\r\n    }\r\n  } catch (error) {\r\n    const code = await wxLogin()\r\n    const loginRes: any = await login({\r\n      code\r\n      // ...(其他参数)\r\n    })\r\n    console.log('用户数据', loginRes)\r\n  }\r\n}\r\n\r\n复制代码最后在pages/index/index.tsx中引用就好了import { userLogin } from '../../utils/index'\r\n\r\n....\r\n\r\nasync componentDidMount() {\r\n    await userLogin()\r\n  }\r\n复制代码整个框架的使用大致就是这样了，react的书法风格还是挺舒服的，如果习惯了vue的写法可能刚开始会不习惯，有兴趣的可以尝试尝试，下面再简单的把一些小技巧给补上：一：图片以模块的方式的引入使用ts搭建的项目，引入静态资源，比如图片，会提示找不到模块，这时候就必须将图片声明为一个模块：在types目录的global.d.ts文件下:declare module ‘*.png’ {​ const img: any​ export default img}二：动态添加style<View style={{backgroundImage: `url(${bgImg})`}}></View>\r\n复制代码三：动态添加class1.<View className={data.length>0?’class-yes’: ’class-no'}></View>\r\n\r\n2.<View className={`common ${data.length>0?’class-yes’: ’class-no}`}></View>\r\n复制代码四：this的指向问题1）在 Taro 的页面和组件类中， this 指向的是 Taro 页面或组件的实例,如果我们要引用原生组件，需要使用到this的时候，如果如下引用：Taro.createCanvasContext(canvasId, this.$scope)\r\nwx.createLivePlayerContext(liveId, this.$scope)\r\n错误：wx.createLivePlayerContext(liveId, this)这样引入是没有效果的，this并不是指向 wx.createLivePlayerContext.(当前版本没有liveplayer的回调方法，所以直接用原生wx)"}
{"title": "Canvas绘图在微信小程序中的应用:生成个性化海报 ", "author": "Rolan", "time": "2018-9-30 00:36", "content": "一、Canvas应用的背景(个人理解)及基础语法背景从2012年开始，微信那个时候用户的积累的量已经非常大了，推出公众号，当然大屏智能手机在那个时候也流行，传统的大众媒体逐步消亡，像微信公众号这样的新媒体盛行。企业的广告投入开始从电视等传统媒体向基于圈层文化的新媒体精准营销转移，甚至很多企业尤其互联网企业开始思考如何利用用户的自传播这种方式去宣传企业、实现商业目标。而用户的自传播很好的途径就是生产个性化的海报。举个最常见的例子，我第一次使用Keep是因为在朋友圈看到朋友分享她运动量的一个截图，当时在我看来非常酷，有心率脉搏呀、时速运动量啊、消耗的卡路里等，还有一个二维码，然后我就点了下载了Keep，这整个获客成本几乎为0，秒秒钟就多了一个用户。而实现这一过程的技术手段就可以用canvas。所以，canvas的盛行，与企业的精准营销和用户的自传播有很大的关系。如极客时间的一些实现案例：大家看第一张图的话是在2017年末的时候，Qcon全球软件开发大会预热阶段的海报。然后我们为程序员做了一个生成2018年关键字的一张海报，文案都非常有趣啊。第二张的话是在2018年元旦的时候做的极客时间助手，这个小程序当初主要是为程序员做的2018年新年签。那面就是一些极客时间的专栏，包括用户留言，你留言随手可以生成一张海报，可以转发等等大概就是这样。基础语法Canvas本质是一个可以使用脚本(通常为JavaScript)来绘制图形的 HTML 元素，默认大小为300像素×150像素(宽×高，像素的单位是px),通过JavaScript上下文对象动态创建图像。比如，画线、画矩形、涂颜色甚至生成带二维码的海报。原理就是一笔一笔的画，画一条横线，再画一条横线等等，就是不断地创建路径、绘制路径，然后把这个路径封闭起来可以涂色之类的，他的底层的封装就是放到一个数组里形成一个路径的数组，将这个数组传到js底层的一个方法，然后去绘制。举个栗子：画一个头像首先，你需要把这张图片画canvas上面，比如说你画你这个头像就是正方形，就在(0,0)开始画一个图片。那么你在这个图片的中心，作为原点，然后你画一个圆形。然后你再利用canvas语法画一个圆弧，在这个圆弧路径以外设置不可见以内设置可见，这个时候就形成了一个圆形头像。  <canvas id=\"canvas\" width=\"300\" height=\"300\"></canvas>\r\n  <script>\r\n    const canvas = document.getElementById('canvas')\r\n    const ctx = canvas.getContext('2d')\r\n    const img = new Image()\r\n    img.onload = function() {\r\n      circleImg(ctx, img, 100, 100, 50)\r\n    }\r\n    img.src=\"https://avatar-static.segmentfault.com/289/811/2898115528-58c35e9b79717_big64\"\r\n    function circleImg(ctx, img, x, y, r) {\r\n      ctx.save()\r\n      let d = 2 * r\r\n      let cx = x + r\r\n      let cy = y + r\r\n      ctx.arc(cx, cy, r, 0, 2 * Math.PI)\r\n      ctx.stroke();\r\n      ctx.clip()\r\n      ctx.drawImage(img, x, y, d, d)\r\n      ctx.restore()\r\n    }\r\n    // 微信小程序中的[canvas](https://developers.weixin.qq.com/miniprogram/dev/component/canvas.html)与HTML5的canvas在语法有些区别，比如API就不一样，\r\n    // 另外小程序中的canvas因为是原生组件的层级是最高的，所以页面中的其他组件无论设置 z-index 为多少，都无法覆盖原生组件\r\n  </script>二、常用的\"生成海报\"的方式我们会经常在朋友圈看到什么算命、性格分析、测算你的智商、情商等等这些东西，都是由用户分享出一张图片(海报)，这个图片就是用canvas做成的，上面画了二维码，二维码是一个数组两个或循环嵌套画小黑点用户识别这个二维码之后就进入他的程序，经过程序跑出来的测试结果啊什么的，点保存的时候，就会生成一张个性海报明白。怎么生成这种个性化海报呢？2.1 字符串模板此处应有案例主要实现：与服务端约定好数据格式-->前端做好模板-->服务端用第三方工具渲染返回到客户端img首先与服务端约定好数据格式，比如关键字是什么、头像URL、昵称等等，把所有放数据格式的地方用{{{}}}嵌套，告诉后端位置；然后，将前端模拟数据抠去，比如user.tags，把这一段html的字符串模板给到服务端，最后服务端拿到数据通过html2canvas这样的第三方工具把图片渲染返回给客户端展示，让用户可以长按这张图片保存到手机相册。这是比较传统的方式早些年基本上都是通过这种方式。有什么弊端呢？一是第三方工具维护不及时、不支持flex布局、ES6等语法，二是调试不方便，三是高并发的时候会出问题，特别是生成的是高清无码的海报的时候2.2 canvas绘制案例: '极客时间小助手'小程序主要实现：前端直接通过canvas生成海报摇晃手机抽取新年签跳到第一个页面，需要绘制头像、关键字以及保存按钮，黄色的保存按钮其实就是呃一张透明的png图片，把它画上去。那在这个button上面儿需要固定一个宽高和它差不多大小的一个空的、透明的div，在这个div上加点击事件，这个事件就是调第二张要保存的那个canvas。第二张这个是没有保存按钮的但有二维码。带二维码的这张canvas放哪里呢？一种方案是定位，给一个特别大的top或left，让它不显示在屏幕里边；另一个方案是层级，预览的这张canvas在真正要保存canvas图片之上，但是会有问题。手机浏览器版本低的话，定了层级不管用，一些安卓手机也会有问题，有时候会浮上来没被盖住。当然，如果要实现保存高清图的话，还是需要处理的，那就是放大，不过这个是笨方法。最优的方法是拆解这张图像，确保导出的canvas是最高清的，而且对用户来说也是最省流量的。解析：进到首页其实关键字在本地就随机取完了，在首页index.js中的onShow方法中就通过wx.getStorageSync缓存了要画的元素，比如关键字(这里是图片)、关键字解析语(也是图片,毕竟微信小程序的canvas不支持字体)等等。摇一摇触发重力感应事件wx.onAccelerometerChange监听里面的事件，获取用户授权拿到头像并跳转到poster页面。直接就开始画两张图片，一张有二维码的(shakepage1)，一张有button的(shakepage2)，这里二维码是'死码',button也是在图片的基础上覆盖一个view，画完之后调canvasToTempFilePath保导出那张带码的，此时带码的这张通过css设置visibility: hidden隐藏起来。点击按钮触发saveImageToPhotosAlbum将导出的这张 图片保存到手机相册，这里需要授权相应的要做一些处理，比如用户拒绝授权之后再次点击需要 wx.showModal再次请用户授权。基本代码如下：(详细源码))      wx.canvasToTempFilePath({\r\n        x: 0,\r\n        y: 0,\r\n        width: this.data.screenWidth,\r\n        height: this.data.screenHeight,\r\n        destWidth: this.data.screenWidth * this.data.pixelRatio,  // pixelRatio为设备的像素比  \r\n        destHeight: this.data.screenHeight * this.data.pixelRatio,\r\n        canvasId: \"canvasid\",\r\n        success: function(e) {\r\n          console.log(e)\r\n          this.setData({\r\n            bjtempFilePath: e.tempFilePath  // 拿到要保存的图片路径\r\n          }, function() {});\r\n        },\r\n        fail: function(e) {\r\n          console.log(e);\r\n        }\r\n      })  onUserSaveImageRight: function () {\r\n    console.log(\"-click-\");\r\n    var _this = this;\r\n    if (!wx.saveImageToPhotosAlbum) return wx.showModal({\r\n      title: \"提示\",\r\n      content: \"当前微信版本过低，无法使用该功能，请升级到最新微信版本后重试。\"\r\n    }), void console.log(\"version low\");\r\n    wx.getSetting({\r\n      success: function (res) {\r\n        res.authSetting[\"scope.writePhotosAlbum\"] ? (console.log(\"1-已经授权《保存图片》权限\"), _this.saveimgfn()) : wx.authorize({\r\n          scope: \"scope.writePhotosAlbum\",\r\n          success: function () {\r\n            console.log(\"用户对相册-授权成功\"), _this.saveimgfn();\r\n          },\r\n          fail: function () {\r\n            wx.showModal({\r\n              title: \"提示\",\r\n              content: \"请您授权保存到系统相册\",\r\n              showCancel: !1,\r\n              success: function (res) {\r\n                res.confirm && wx.openSetting({\r\n                  success: function (res) {\r\n                    res.authSetting[\"scope.writePhotosAlbum\"] ? setTimeout(function () {\r\n                      _this.saveimgfn();\r\n                    }, 500) : wx.showModal({\r\n                      title: \"提示\",\r\n                      content: \"您未授权，无法将海报保存到相册，你可以截屏得到海报，或者再次点击'保存海报'按钮并授权\",\r\n                      showCancel: !1\r\n                    });\r\n                  }\r\n                });\r\n              }\r\n            });\r\n          }\r\n        });\r\n      }\r\n    });\r\n  },\r\n  saveimgfn: function () {\r\n    var filePath = this.data.bjtempFilePath;\r\n    console.log(filePath), filePath ? wx.saveImageToPhotosAlbum({\r\n      filePath: filePath,\r\n      success: function (res) {\r\n        wx.showToast({\r\n          title: \"保存成功\",\r\n          icon: \"success\",\r\n          duration: 1500\r\n        });\r\n      },\r\n      fail: function () {\r\n        wx.showToast({\r\n          title: \"保存失败\",\r\n          icon: \"fail\",\r\n          duration: 1500\r\n        });\r\n      }\r\n    }) : this.saveImage()三、极客时间小程序-生成各种海报的解决方案微信小程序canvas与HTM5的canvas对比微信小程序canvas中层级z-index失效，小程序中canvas拥有最高级，无法二次设置;微信小程序canvas不支持字体功能，特殊字体只能用图片代替;微信小程序canvas不支持绘制在线图片，需要下载再绘制(安全域名的锅)微信小程序canvas可以实现不同尺寸屏幕自适应    var rpx;\r\n    //获取屏幕宽度，获取自适应单位\r\n    wx.getSystemInfo({\r\n      success: function(res) {\r\n        rpx = res.windowWidth/750\r\n      },\r\n    })\r\n    // 在绘制方法中将参数乘以相对单位即可实现自适应\r\n    const s = wx.createCanvasContext(\"canvas\")\r\n    s.drawImage(Url, 0, 0, 265 * rpx, 262.5 * rpx) 如何导出高清海报、如何封装；wx.canvasToTempFilePath({\r\n    canvasId: 'image-save',\r\n    x: 0,\r\n    y: 0,\r\n    success: res => {\r\n       wx.saveImageToPhotosAlbum({\r\n         filePath: res.tempFilePath,\r\n         success: () => {\r\n           this.setData({saving: false})\r\n           utils.success('保存成功')\r\n           setTimeout(() => {wx.navigateBack()}, 500)\r\n         },\r\n         fail: err => {\r\n           this.setData({saving: false})\r\n           wx.getSetting({\r\n             success: res => {\r\n               if(!res.authSetting || !res.authSetting['scrop.writePhotoAlbum']){\r\n                 wx.openSetting()\r\n               }\r\n             }\r\n           })\r\n         }\r\n       })\r\n    }\r\n})"}
{"title": "微信小程序踩坑系列——从wx.request谈谈异步处理 ", "author": "Rolan", "time": "2018-9-30 00:40", "content": "见到wx.request的第一眼，就让我想起了$.ajax这东西，使用起来确实有很多不方便，不能忍，幸好小程序是支持ES6语法的，所以可以使用promise稍加改造。先来说说wx.request为什么不能忍。铺垫：“看得见却抓不住“的异步请求123456789101112131415161718192021222324Page({  data: {    myData: ''  },  // loadMyData函数用于打印myData的值  loadMyData () {    console.log('获取到的数据为：' + this.data.myData)  },  // 生命周期函数onload用于监听页面加载  onload: function () {    wx.request({      url: 'https://api',  // 某个api接口地址      success: res => {        console.log(res.data)        this.setData({          myData: res.data        })        console.log(this.data.myData)      }    })    // 调用之前的函数    this.loadMyData()  }})然后我们会在控制台到这样的结果：这其实是一个很简单的异步问题，wx.request是异步请求，JS不会等待wx.request执行完毕再往下执行，所以JS按顺序会先执行this.loadMyData()，等服务器返回数据以后，loadMyData()早就执行完了，当然也就没有拿到值啦。其实我们在同步流程中才说“返回”，异步没有“返回”这个概念（或者说异步返回是没有意义的），异步对应的是“回调”，也就是说，对于一个异步函数，我们应该传入一个“回调函数”来接收结果。初步解决：通过回调接收结果最简单的解决方案，就是把需要使用异步数据的函数写在回调里：123456789101112131415...onload: function () {  wx.request({    url: 'https://api',  // 某个api接口地址    success: res => {      console.log(res.data)      this.setData({        myData: res.data      })      console.log(this.data.myData)      // 把使用数据的函数写在回调函数success中      this.loadMyData()    }  })}这样就可以正确输出了：但是如果逻辑复杂，需要多层异步操作，会出现怎么样的情况呢？123456789101112131415asyncFn1(function(){  //...  asyncFn2(function(){    //...    asyncFn3(function(){      //...      asyncFn4(function(){        //...        asyncFn5(function(){           //...        });      });    });  });});有没有感觉头皮发麻？什么优雅什么可读性，瞬间荡然无存，这就是恐怖的“回调地狱”（Callback Hell）。而我们发现，微信小程序的网络请求wx.request，也正是这种依靠回调函数的形式，类似于以前的$.ajax，它在逻辑复杂、页面执行顺序要求多的情况下，弊端也是很明显的。不过好在小程序支持ES6，我们可以尽情地拥抱Promise！使用Promise包装wx.requestPromise这东西简单说来就是，它可以将异步的执行逻辑和结果处理分离，摒弃了一层又一层的回调嵌套，使得处理逻辑更加清晰。想具体了解的还请自行查找资料。现在我们就用Promise包装一下wx.request：12345678910111213141516/** * requestPromise用于将wx.request改写成Promise方式 * @param：{string} myUrl 接口地址 * @return: Promise实例对象 */const requestPromise = myUrl => {  // 返回一个Promise实例对象  return new Promise((resolve, reject) => {    wx.request({      url: myUrl,      success: res => resolve(res)    })  })}// 我把这个函数放在了utils.js中，这样在需要时可以直接引入module.exports = requestPromise现在再使用试试：123456789101112131415161718// 引用模块const utilApi = require('../../utils/util.js')Page({  ...  // 生命周期函数onload用于监听页面加载  onLoad: function () {    utilApi.requestPromise(\"https://www.bilibili.com/index/ding.json\")    // 使用.then处理结果    .then(res => {      console.log(res.data)      this.setData({        myData: res.data      })      console.log(this.data.myData)      this.loadMyData()    })  }})结果和使用回调函数一致。当有多个异步请求时，直接不断地.then(fn)去处理即可，逻辑清晰。当然，这里只是写了一个最简单的Promise函数，还不完整。更完整的Promise化wx.request，等以后业务需要再完善吧。另外各种小程序开发框架也都有了现成的promise化API，拿来即用。"}
{"title": "Westore 发布小程序插件开发模板和其他重大更新及原理 ", "author": "Rolan", "time": "2018-9-30 00:45", "content": "Westore 开源两天就突破了 1000 star，还登顶过Github日榜第一名。期间受到了海量关注，收到了大量的中肯和实用的反馈和意见。小程序插件开发的诉求是非常重要的意见之一。所以我马不停蹄地努力连夜更新，看 Github 提交记录就知道我凌晨 3 点钟有合并 PR，也有提交代码 = =！Github地址: github.com/dntzhang/we…先回顾一下小程序现有的痛点:使用 this.data 可以获取内部数据和属性值，但不要直接修改它们，应使用 setData 修改setData 编程体验不好，很多场景直接赋值更加直观方便setData 卡卡卡慢慢慢，JsCore 和 Webview 数据对象来回传浪费计算资源和内存资源组件间通讯或跨页通讯会把程序搞得乱七八糟，变得极难维护和扩展所以没使用 westore 的时候经常可以看到这样的代码:使用 Westore 对编程体验的改善:上面两种方式也可以混合使用。这里需要特别强调，虽然 this.update 可以兼容小程序的 this.setData 的方式传参，但是更加智能，this.update 会按需 Diff 或者 透传给 setData。原理:再举个例子：this.store.data.motto = 'Hello Store222'\r\nthis.store.data.b.arr.push({ name: 'ccc' })\r\nthis.update()\r\n复制代码等同于this.update({\r\n  motto:'Hello Store222',\r\n  [`b.arr[${this.store.data.b.arr.length}]`]:{name:'ccc'}\r\n})\r\n复制代码小程序插件小程序插件是对一组 js 接口、自定义组件或页面的封装，用于嵌入到小程序中使用。插件不能独立运行，必须嵌入在其他小程序中才能被用户使用；而第三方小程序在使用插件时，也无法看到插件的代码。因此，插件适合用来封装自己的功能或服务，提供给第三方小程序进行展示和使用。插件开发者可以像开发小程序一样编写一个插件并上传代码，在插件发布之后，其他小程序方可调用。小程序平台会托管插件代码，其他小程序调用时，上传的插件代码会随小程序一起下载运行。插件开发者文档插件使用者文档插件开发Westore 提供的目录如下:|--components\r\n|--westore\t\r\n|--plugin.json\t\r\n|--store.js\r\n复制代码创建插件:import create from '../../westore/create-plugin'\r\nimport store from '../../store'\r\n\r\n//最外层容器节点需要传入 store，其他组件不传 store\r\ncreate(store, {\r\n  properties:{\r\n    authKey:{\r\n      type: String,\r\n      value: ''\r\n    }\r\n  },\r\n  data: { list: [] },\r\n  attached: function () {\r\n    // 可以得到插件上声明传递过来的属性值\r\n    console.log(this.properties.authKey)\r\n    // 监听所有变化\r\n    this.store.onChange = (detail) => {\r\n      this.triggerEvent('listChange', detail)\r\n    }\r\n    // 可以在这里发起网络请求获取插件的数据\r\n    this.store.data.list = [{\r\n      name: '电视',\r\n      price: 1000\r\n    }, {\r\n      name: '电脑',\r\n      price: 4000\r\n    }, {\r\n      name: '手机',\r\n      price: 3000\r\n    }]\r\n\r\n    this.update()\r\n\r\n    //同样也直接和兼容 setData 语法\r\n    this.update(\r\n        { 'list[2].price': 100000 }\r\n    )\r\n  }\r\n})\r\n复制代码在你的小程序中使用组件：<list auth-key=\"{{authKey}}\" bind:listChange=\"onListChange\" />\r\n复制代码这里来梳理下小程序自定义组件插件怎么和使用它的小程序通讯:通过 properties 传入更新插件，通过 properties 的 observer 来更新插件通过 store.onChange 收集 data 的所有变更通过 triggerEvent 来抛事件给使用插件外部的小程序这么方便简洁还不赶紧试试 Westore插件开发模板 ！特别强调插件内所有组件公用的 store 和插件外小程序的 store 是相互隔离的。原理页面生命周期函数名称描述onLoad监听页面加载onShow监听页面显示onReady监听页面初次渲染完成onHide监听页面隐藏onUnload监听页面卸载组件生命周期函数名称描述created在组件实例进入页面节点树时执行，注意此时不能调用 setDataattached在组件实例进入页面节点树时执行ready在组件布局完成后执行，此时可以获取节点信息（使用 SelectorQuery ）moved在组件实例被移动到节点树另一个位置时执行detached在组件实例被从页面节点树移除时执行由于开发插件时候的组件没有 this.page，所以 store 是从根组件注入，而且可以在 attached 提前注入:export default function create(store, option) {\r\n    let opt = store\r\n    if (option) {\r\n        opt = option\r\n        originData = JSON.parse(JSON.stringify(store.data))\r\n        globalStore = store\r\n        globalStore.instances = []\r\n        create.store = globalStore\r\n    }\r\n\r\n    const attached = opt.attached\r\n    opt.attached = function () {\r\n        this.store = globalStore\r\n        this.store.data = Object.assign(globalStore.data, opt.data)\r\n        this.setData.call(this, this.store.data)\r\n        globalStore.instances.push(this)\r\n        rewriteUpdate(this)\r\n        attached && attached.call(this)\r\n    }\r\n    Component(opt)\r\n}\r\n复制代码"}
{"title": "小程序即时通讯demo ", "author": "Rolan", "time": "2018-10-10 00:21", "content": "前段时间写了一个小程序即时聊天demo,仿微信，效果如下:项目地址是： github.com/lirongrong/… ,大家可以自行下载，按照提示运行，就能看到效果；现在只是做了要给基本版的，要做复杂功能，可以继续添加。功能发送文字发送图片（图片可点击放大）发送拍摄照片 （图片可点击放大）发送位置 （map组件默认在最顶层，样式控制不了，bug还在修复中...）发送语音 （包括语音时长，可点击播放）websorket长连接是基于nodejs-websocket的服务，代码如下：(最基础版)var ws = require(\"nodejs-websocket\")\r\n\r\n// Scream server example: \"hi\" -> \"HI!!!\"\r\n//创建一个server\r\nvar server = ws.createServer(function (conn) {\r\n\tconsole.log(\"New connection\")\r\n\tconn.on(\"text\", function (str) { \r\n\t\t// console.log(\"Received \"+str)\r\n\t\t// conn.sendText(str.toUpperCase()+\"!!!\")\r\n\t\t//链接成功之后，发送欢迎语\r\n\t\tconsole.log(\"连接成功\")\r\n\t\t//欢迎语\r\n\t\tif(str == 'null'){\r\n\t\t\tconn.sendText(\"有什么能帮到您？\");\r\n\t\t}\r\n\t\t//输入文字\r\n\t\telse if(str != 'null' && str){\r\n\t\t\tconn.sendText(\"文字\")\r\n\t\t}\r\n\t\t//输入多媒体\r\n\t\telse{\r\n\t\t\tconn.sendText(\"多媒体文本\")\r\n\t\t}\r\n\t\tconsole.log(str);\r\n\t})\r\n\tconn.on(\"close\", function (code, reason) {\r\n\t\tconsole.log(\"Connection closed\")\r\n\t})\r\n}).listen(8001)\r\n复制代码在项目根目录下运行 npm run dev 服务就能启动了， 启动之后websorket地址为： ws://localhost:8001chat.js直接看代码，注释都写清楚了// pages/user/chat.js\r\nvar util = require('../utils/util.js');\r\nvar app = getApp();\r\n//websocket心跳重连对象\r\nlet heartCheck = {\r\n  timeout: 1000,//1s\r\n  timeoutObj: null,\r\n  serverTimeoutObj: null,\r\n  //重置\r\n  reset: function () {\r\n    clearTimeout(this.timeoutObj);\r\n    clearTimeout(this.serverTimeoutObj);\r\n    return this;\r\n  },\r\n  //开始\r\n  start: function () {\r\n    wx.sendSocketMessage({\r\n      data: \"null\",\r\n    });\r\n  }, \r\n}; \r\n//微信小程序新录音接口，录出来的是aac或者mp3，这里要录成mp3\r\nconst recorderManager = wx.getRecorderManager();\r\nconst options = {\r\n  duration: 600000,//录音时长，这里设置的是最大值10分钟\r\n  sampleRate: 44100,\r\n  numberOfChannels: 1,\r\n  encodeBitRate: 192000,\r\n  format: 'mp3',\r\n  //frameSize: 50 \r\n};\r\n\r\n//音频播放\r\nconst innerAudioContext = wx.createInnerAudioContext()\r\n\r\nPage({ \r\n  data: {  \r\n    taskId:'',\r\n    userId:'',\r\n    chatList:[],//聊天内容\r\n    isShowModelUp:false,//底部弹框显示true,隐藏为false \r\n    isLuYin:false,//没有录音false,开始录音true\r\n    luYinText:'按住说话',\r\n    audioUrl:'',//录音文件地址\r\n    isShowLuYin:false,//true为开始播放，false为取消播放\r\n    inputValue:'',//输入框内容\r\n    lockReconnect:false,//默认进来是断开链接的\r\n    limit:0,//重连次数\r\n  }, \r\n  onLoad: function (options) { \r\n    this.linkSocket(); \r\n  }, \r\n  //连接socket\r\n  linkSocket:function(){\r\n    let that = this;\r\n    wx.connectSocket({\r\n      //url: app.globalData.wsUrl + 'websocket?' + this.data.taskId + '&' + this.data.userId,\r\n      url:app.globalData.wsUrl,\r\n      success() {\r\n        console.log('连接成功')\r\n        wx.onSocketMessage((res) => {\r\n          console.log(res.data);\r\n          //收到消息\r\n          that.pushChatList(0, {\r\n            text: res.data\r\n          });\r\n        })\r\n        wx.onSocketOpen(() => {\r\n          console.log('WebSocket连接打开')\r\n          heartCheck.reset().start()\r\n        })\r\n        wx.onSocketError(function (res) {\r\n          console.log('WebSocket连接打开失败')\r\n          that.reconnect()\r\n        })\r\n        wx.onSocketClose(function (res) {\r\n          console.log('WebSocket已关闭！')\r\n          that.reconnect()\r\n        })\r\n      }\r\n    }) \r\n  }, \r\n  //断线重连\r\n  reconnect() { \r\n    var that = this;\r\n    if (that.lockReconnect) return;\r\n    that.lockReconnect = true;\r\n    clearTimeout(that.timer)\r\n    if (that.data.limit < 12) {\r\n      that.timer = setTimeout(() => {\r\n        that.linkSocket();\r\n        that.lockReconnect = false;\r\n      }, 5000);\r\n      that.setData({\r\n        limit: that.data.limit + 1\r\n      })\r\n    } \r\n  }, \r\n  //打开底部弹框\r\n  showModelUp:function(){ \r\n    var that=this; \r\n    if (that.data.isShowModelUp==false){\r\n      that.setData({\r\n        isShowModelUp: true, \r\n      })\r\n    }else{\r\n      that.setData({\r\n        isShowModelUp: false, \r\n      })\r\n    } \r\n  },\r\n  //关闭底部弹框\r\n  closeModelUp:function(){\r\n    var that=this;\r\n    that.setData({\r\n      isShowModelUp:false, \r\n    })\r\n  },\r\n  //选择照片\r\n  chooseImage:function(){\r\n    var that=this;\r\n    wx.chooseImage({ \r\n      count: 1, // 默认9\r\n      sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有\r\n      sourceType: ['album'], // 可以指定来源是相册还是相机，默认二者都有\r\n      success: function (res) { \r\n        // 返回选定照片的本地文件路径列表，tempFilePath可以作为img标签的src属性显示图片\r\n        var tempFilePaths = res.tempFilePaths;\r\n        console.log(res);\r\n        that.pushChatList(1,{\r\n          imgUrl: tempFilePaths,\r\n        }) \r\n        //关闭弹窗\r\n        that.closeModelUp();\r\n        that.pageScrollToBottom();\r\n      }\r\n    })\r\n  },\r\n  //界面滚到最底端\r\n  pageScrollToBottom: function () {\r\n    wx.createSelectorQuery().select('#bottom').boundingClientRect(function (rect) {\r\n      console.log(rect.top);\r\n      console.log(rect.bottom);\r\n      // 使页面滚动到底部\r\n      wx.pageScrollTo({\r\n        scrollTop: rect.bottom + 200\r\n      })\r\n    }).exec()\r\n  },\r\n  //预览图片\r\n  previewImage:function(e){\r\n    console.log(e);\r\n    var url=e.currentTarget.dataset.src;\r\n    var that=this;\r\n    wx.previewImage({\r\n      current: url[0], // 当前显示图片的http链接\r\n      urls: url // 需要预览的图片http链接列表\r\n    })\r\n  },\r\n  //拍摄\r\n  paishe:function(){\r\n    var that = this;\r\n    wx.chooseImage({\r\n      count: 1, // 默认9\r\n      sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有\r\n      sourceType: ['camera'], // 可以指定来源是相册还是相机，默认二者都有\r\n      success: function (res) {\r\n        // 返回选定照片的本地文件路径列表，tempFilePath可以作为img标签的src属性显示图片\r\n        var tempFilePaths = res.tempFilePaths;\r\n        console.log(res);\r\n        that.pushChatList(1,{\r\n          imgUrl: tempFilePaths,\r\n        })\r\n        //关闭弹窗\r\n        that.closeModelUp();\r\n        that.pageScrollToBottom();\r\n      }\r\n    })\r\n  },\r\n  //发送位置\r\n  getlocat: function () {\r\n    var that = this\r\n    wx.getLocation({\r\n      type: 'gcj02', //返回可以用于wx.openLocation的经纬度\r\n      success: function (res) {\r\n        that.setData({\r\n          latitude: res.latitude,\r\n          longitude: res.longitude,\r\n          markers: [{\r\n            latitude: res.latitude,\r\n            longitude: res.longitude,\r\n            name: '时代一号',\r\n            desc: '现在的位置'\r\n          }], \r\n        })\r\n        that.pushChatList(1,{\r\n          map: true\r\n        })\r\n      }\r\n    })\r\n    that.closeModelUp();\r\n    that.pageScrollToBottom();\r\n  },\r\n  //切换是否录音按钮\r\n  btnRecord:function(){ \r\n    var that=this;\r\n    if (that.data.isLuYin==false){\r\n      that.setData({\r\n        isLuYin: true\r\n      });\r\n    }else{\r\n      that.setData({\r\n        isLuYin: false,\r\n        luYinText: '按住说话'\r\n      });\r\n    }  \r\n  },\r\n  //开始录音\r\n  startRecord:function(e){ \r\n    var that=this;\r\n    that.setData({\r\n      luYinText:'录音中...', \r\n    }); \r\n    recorderManager.start(options); \r\n    recorderManager.onStart(() => {\r\n      console.log('recorder start')\r\n    })\r\n  },\r\n  //结束录音\r\n  stopRecord:function(){ \r\n    var that = this;\r\n    that.setData({\r\n      luYinText: '按住说话'\r\n    });\r\n    recorderManager.stop();  \r\n    recorderManager.onStop((res) => {\r\n      console.log('recorder stop', res)\r\n      const { tempFilePath } = res;\r\n      that.pushChatList(1,{\r\n        audioUrl: res.tempFilePath,\r\n        audioDuration: (res.duration / 60000).toFixed(2),//录音时长,转为分,向后取两位,\r\n      })\r\n      that.setData({\r\n        audioUrl: res.tempFilePath,\r\n        audioDuration: (res.duration / 60000).toFixed(2),//录音时长,转为分,向后取两位,\r\n      })\r\n    })\r\n    //关闭弹窗\r\n    that.closeModelUp();\r\n    that.pageScrollToBottom();\r\n  },\r\n  //录音、停止播放\r\n  playRecord:function(e){  \r\n    console.log(e);\r\n    var that=this;  \r\n    innerAudioContext.autoplay = true;\r\n    innerAudioContext.src = that.data.audioUrl\r\n    //innerAudioContext.src = 'http://ws.stream.qqmusic.qq.com/M500001VfvsJ21xFqb.mp3?guid=ffffffff82def4af4b12b3cd9337d5e7&uin=346897220&vkey=6292F51E1E384E061FF02C31F716658E5C81F5594D561F2E88B854E81CAAB7806D5E4F103E55D33C16F3FAC506D1AB172DE8600B37E43FAD&fromtag=46';//测试音频文件\r\n    if (!e.currentTarget.dataset.isshowluyin){//开始播放 \r\n      //innerAudioContext.play();//兼容起见用它\r\n      innerAudioContext.onPlay(() => {\r\n        console.log('开始播放');\r\n        that.setData({ \r\n          isShowLuYin: true\r\n        }); \r\n        return;\r\n      }); \r\n    }else{//暂停播放 \r\n      innerAudioContext.pause();\r\n      console.log(\"暂停\");\r\n      that.setData({\r\n        isShowLuYin: false\r\n      });\r\n      return; \r\n    } \r\n  },\r\n  //输入框点击完成按钮时触发\r\n  btnConfirm:function(e){\r\n    var that = this;\r\n    if (typeof (e) == 'undefined' || e.detail.value == ''){\r\n      return false;\r\n    }else {  \r\n      var value = e.detail.value;\r\n      that.pushChatList(1,{\r\n        text: value\r\n      });\r\n      that.setData({\r\n        inputValue:''//清空输入框\r\n      })\r\n      //发送数据\r\n      wx.sendSocketMessage({\r\n        data: value\r\n      })\r\n      //关闭弹窗\r\n      that.closeModelUp();\r\n      that.pageScrollToBottom();\r\n    }\r\n  },\r\n  //页面隐藏/切入后台时触发\r\n  onHide:function(){\r\n    wx.onSocketClose(function (res) {\r\n      console.log('WebSocket已关闭！') \r\n    })\r\n  },\r\n  //页面卸载时触发\r\n  onUnload:function(){\r\n    wx.onSocketClose(function (res) {\r\n      console.log('WebSocket已关闭！')\r\n    })\r\n  },\r\n  //pushchatList\r\n  //enu:0 是客服发送的消息\r\n  //enu:1 是我发送的消息\r\n  pushChatList:function(enu,options){\r\n    var that = this;\r\n    var defaults = {\r\n      userImage: '',\r\n      text: '',\r\n      isAdmin: false,\r\n    }\r\n    options = util.extendObj(defaults,options);\r\n    options.time = util.formatDateTime(util.getNowFormatDate());\r\n    console.log(options); \r\n    if(enu == 0){\r\n      options.userImage = '../images/admin.png';\r\n      options.isAdmin = false;  \r\n    }else if(enu==1){\r\n      options.userImage = app.globalData.wxUserInfo.avatarUrl;\r\n      options.isAdmin = true;\r\n    }\r\n    var t = that.data.chatList;\r\n    t.push(options)\r\n    that.setData({\r\n      chatList: t\r\n    });\r\n  }\r\n})\r\n复制代码需要优化的地方上传图片应该要支持多图上传并压缩一下，我做h5的聊天功能的时候压缩了，这个简版的小程序没做，大家可以自行加上这个demo只是实现了UI和文字的通讯，图片、视频、地图等的通讯还没完善发送消息之后滚到底部的方法需要改进，因为发送图片、地图、语音没有滚到底部需要改进的请大神指点"}
{"title": "利用云开发优化博客小程序（二）——评论功能 ", "author": "Rolan", "time": "2018-10-10 00:34", "content": "这几天陆陆续续抽了点时间迭代了一版我的小程序版博客，一来是因为云开发的出现，让很多功能成为了可能，二来正好也正好深度熟悉下云开发。这次迭代主要是完善了评论功能「不知道审核能不能过」，一开始觉得很快能搞定，然而真正开发的时候还是碰到很多问题，这篇文章既是回顾总结，也是记录下自己在开发过程中遇到的一些坑，仅供参考。开发回顾具体思路还是比较简单的，利用云开发中的数据库来保存评论数据，在文章详情页的底部呈现具体的评论数据。在上一篇云发开初体验中，我已经创建了 posts_statistics 集合，用来存储文章的 访问数 ， 喜欢数 和 评论数 ,这次新建了 posts_comments 集合用于存储具体的评论数据，结构如下：\"_id\": \"集合id\"\r\n\"_openid\": \"评论人openid\"\r\n\"cAvatarUrl\": \"头像url\"\r\n\"cNickName\": \"昵称\"\r\n\"comment\": \"评论内容\"\r\n\"createDate\": \"创建日期\"\r\n\"flag\": 0\r\n\"postId\": \"文章id\"\r\n\"timestamp\": \"时间戳\"\r\n\"childComment\":\r\n    [{\"cAvatarUrl\": \"评论人url\"\r\n    \"cNickName\": \"评论人昵称\"\r\n    \"cOpenId\": \"评论人openid\"\r\n    \"comment\": \"评论内容\"\r\n    \"createDate\": 2018-09-29\r\n    \"flag\": \"数据标识\"\r\n    \"tNickName\": \"对方昵称\"\r\n    \"tOpenId\": \"对方openid\"\r\n    \"timestamp\": \"时间戳\"}]在创建完集合之后，需要编写对应的查询，新增，和新增子评论的方法。主要说下查询和新增子评论。查询的话肯定需要分页加载，控制一次性数据的加载量，会用到 skip 和 limit ,大致写法如下：return db.collection('posts_comments')\r\n    .where({postId: postId})\r\n    .orderBy('timestamp', 'desc')\r\n    .skip((page - 1) * 10)\r\n    .limit(10)\r\n    .get()然后是新增子评论，相当于在主评论下回复别人，主要在集合中 childComment 下新增评论，这里使用 db.command.push 更新指令，往数组尾部添加一个或多个值。大致写法如下：const _ = db.command\r\nreturn db.collection('posts_comments').doc(id).update({\r\n    data: {\r\n      childComment: _.push(data)\r\n    }在文章详情底部功能栏的样式上，还是比较纠结的，参考了一些UI，最终还是使用这种折叠的方式，具体的样式代码就不贴了。其中有几个交互可以唠叨下。首先是点 加号 会上拉底部的功能按钮，这个没什么问题，但细节需要注意，通常情况下点空白处时会自动缩回去，但这个实现有点凌乱，于是我在功能菜单以外的视图外层套了层view:<view catchtap=\"hiddenMenubox\">\r\n...文章主题部分...\r\n</view>\r\n\r\n/**\r\n * 非评论区隐藏菜单\r\n*/\r\nhiddenMenubox: function() {\r\n\tthis.setData({\r\n\t  isShow: false,\r\n\t  menuBackgroup: false\r\n\t})\r\n},然后是评论输入框中的提示，默认是 评论... ，当点击回复具体某个人的评论时，默认修改成 回复*** 。然后是喜欢和收藏两个按钮，喜欢和收藏之后图标自动点亮。还有就是提交完评论之后默认重新刷新评论列表，最后一条评论之后停止刷新，没有评论友好提示等。总之一些小的交互点还是挺多的。这里就不一一说明了，有兴趣的可以浏览下我的小程序，并看看源码。问题点整理主要还是说说开发过程中的问题点和如何解决的。1.获取用户的openid首先是获取用户的openid问题，在没有云函数之前，获取用户的openid还是比较麻烦的，需要通过wx.login获取code，然后通过code和小程序的appid和secret请求接口从而获取到openid。而有云函数之后，可以简单调用下云函数，经过微信鉴权之后可直接获取到用户的openid：exports.main = (event, context) => {\r\n  return {\r\n    openid: event.userInfo.openId,\r\n  }\r\n}2. 数据库操作权限问题因为每月云函数有调用次数的限制，所以想直接在客户端调用数据库。一开始挺顺利的，但当更新子评论的时候出现问题了，由于客户端对于数据库最大权限是 所有用户可读，仅创建者及管理员可写 ,所以导致子评论无法更新进去「创建者和子评论者是两个用户」。所以没办法，只能包一层云函数，云函数中调用数据库，因为服务端调用数据库没有这个权限的限制。// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  return await db.collection('posts_comments').doc(event.id).update({\r\n    data: {\r\n      childComment: _.push(event.comments)\r\n    }\r\n  })\r\n}其实个人感觉数据库操作最好都放在服务端比较好，由云函数统一收口，设计好的话，云函数还能当作路由的作用。3.catchtap与bindtap一开始没有仔细看文档，所以猜了坑，稍微关注下就可以避免了，同为点击事件， bindtap 事件绑定不会阻止冒泡事件向上冒泡,而 catchtap 事件绑定可以阻止冒泡事件向上冒泡。所以在由多层嵌套的时候一定要注意下，是否需要冒泡。4.promise上一版本中的方法基本都采用的回调方式，之前功能简单感觉阅读起来还好。但这次改动之后发现代码就坑了，回调方法太多感觉有点眼花了。原本打算使用ES7的特性 async/await ，但发现目前微信web开发者工具还不支持，相信以后应该会支持吧，不太愿意引用其他插件了，所以还是使用了 promise ,使用下来代码可阅读性提高了很多，可以一直 then 下去。但毕竟不是专业前端，总感觉代码写的还是比较糟糕，后期打算再迭代优化下代码。5. 样式在样式上遇到的问题其实挺多的，主要还是自己的基本功不扎实，所以踩了很多的布局的坑，这里就不一一说了，也说不清楚，自己亲自搭建之后还是会有很深印象的。其他优化点在开发评论功能的同时，也优化了一些问题点，这里也说明下：引流公众号组件也是最近更新的功能，所以将此功能加上去了，比较简单，在公众平台中启用关注组件并绑定公众号，然后代码中引用下即可：<official-account></official-account>效果可以看下，还是挺有意思的：2. 授权原本的授权是跳转到单独的页面的，访问过我的小程序的知道，那个页面有个可爱的gif的萌妹子但发现体验不是很好，首先这个gif萌妹子体积比较大，影响首次加载。其次是跳转时效果也不是很理想。所以改成弹窗的方式，并首次使用了模板页：3. 修复wxParse的问题有网友反馈部分安卓机文章详情页加载不出来，后来发现是因为 wxParse 中 console.dir 的问题，部分安卓机不支持，注释掉即可。总结2.0的代码提交审核了，不懂能不能通过，希望在国庆节可以和大家见面吧。其实要优化的点和开发的功能还是有很多，比如生成海报还没有开发，发送的文本框不能换行，体验不太好等等。后期慢慢迭代吧，也欢迎大家使用体验，并多提宝贵意见。Ps.需要源码的可以关注我的微信公众号 Bug生活2048 ，平时会推送一些技术文章和职场趣事"}
{"title": "小程序解决方案 Westore - 组件、纯组件、插件开发 ", "author": "Rolan", "time": "2018-10-10 00:40", "content": "数据流转先上一张图看清 Westore 怎么解决小程序数据难以管理和维护的问题:非纯组件的话，可以直接省去 triggerEvent 的过程，直接修改 store.data 并且 update，形成缩减版单向数据流。Github: https://github.com/dntzhang/westore组件这里说的组件便是自定义组件，使用原生小程序的开发格式如下:Component({\r\n  properties: { },\r\n\r\n  data: { },\r\n\r\n  methods: { }\r\n})使用 Westore 之后:import create from '../../utils/create'\r\n\r\ncreate({\r\n  properties: { },\r\n\r\n  data: { },\r\n\r\n  methods: { }\r\n})看着差别不大，但是区别：Component 的方式使用 setData 更新视图create 的方式直接更改 store.data 然后调用 updatecreate 的方式可以使用函数属性，Component 不可以，如：export default {\r\n  data: {\r\n    firstName: 'dnt',\r\n    lastName: 'zhang',\r\n    fullName:function(){\r\n      return this.firstName + this.lastName\r\n    }\r\n  }\r\n}绑定到视图:<view>{{fullName}}</view>小程序 setData 的痛点:使用 this.data 可以获取内部数据和属性值，但不要直接修改它们，应使用 setData 修改setData 编程体验不好，很多场景直接赋值更加直观方便setData 卡卡卡慢慢慢，JsCore 和 Webview 数据对象来回传浪费计算资源和内存资源组件间通讯或跨页通讯会把程序搞得乱七八糟，变得极难维护和扩展没使用 westore 的时候经常可以看到这样的代码:使用完 westore 之后:上面两种方式也可以混合使用。可以看到，westore 不仅支持直接赋值，而且 this.update 兼容了 this.setData 的语法，但性能大大优于 this.setData，再举个例子：this.store.data.motto = 'Hello Westore'\r\nthis.store.data.b.arr.push({ name: 'ccc' })\r\nthis.update()等同于this.update({\r\n  motto:'Hello Westore',\r\n  [`b.arr[${this.store.data.b.arr.length}]`]:{name:'ccc'}\r\n})这里需要特别强调，虽然 this.update 可以兼容小程序的 this.setData 的方式传参，但是更加智能，this.update 会先 Diff 然后 setData。原理:纯组件常见纯组件由很多，如 tip、alert、dialog、pager、日历等，与业务数据无直接耦合关系。组件的显示状态由传入的 props 决定，与外界的通讯通过内部 triggerEvent 暴露的回调。triggerEvent 的回调函数可以改变全局状态，实现单向数据流同步所有状态给其他兄弟、堂兄、姑姑等组件或者其他页面。Westore里可以使用 create({ pure: true }) 创建纯组件（当然也可以直接使用 Component），比如 ：import create from '../../utils/create'\r\n\r\ncreate({\r\n  pure : true,\r\n  \r\n  properties: {\r\n    text: {\r\n      type: String,\r\n      value: '',\r\n      observer(newValue, oldValue) { }\r\n    }\r\n  },\r\n\r\n  data: {\r\n    privateData: 'privateData'\r\n  },\r\n\r\n  ready: function () {\r\n    console.log(this.properties.text)\r\n  },\r\n\r\n  methods: {\r\n    onTap: function(){\r\n      this.store.data.privateData = '成功修改 privateData'\r\n      this.update()\r\n      this.triggerEvent('random', {rd:'成功发起单向数据流' + Math.floor( Math.random()*1000)})\r\n    }\r\n  }\r\n})需要注意的是，加上 pure : true 之后就是纯组件，组件的 data 不会被合并到全局的 store.data 上。组件区分业务组件和纯组件，他们的区别如下：业务组件与业务数据紧耦合，换一个项目可能该组件就用不上，除非非常类似的项目业务组件通过 store 获得所需参数，通过更改 store 与外界通讯业务组件也可以通过 props 获得所需参数，通过 triggerEvent 与外界通讯纯组件与业务数据无关，可移植和复用纯组件只能通过 props 获得所需参数，通过 triggerEvent 与外界通讯大型项目一定会包含纯组件、业务组件。通过纯组件，可以很好理解单向数据流。小程序插件小程序插件是对一组 JS 接口、自定义组件或页面的封装，用于嵌入到小程序中使用。插件不能独立运行，必须嵌入在其他小程序中才能被用户使用；而第三方小程序在使用插件时，也无法看到插件的代码。因此，插件适合用来封装自己的功能或服务，提供给第三方小程序进行展示和使用。插件开发者可以像开发小程序一样编写一个插件并上传代码，在插件发布之后，其他小程序方可调用。小程序平台会托管插件代码，其他小程序调用时，上传的插件代码会随小程序一起下载运行。插件开发者文档插件使用者文档插件开发Westore 提供的目录如下:|--components\r\n|--westore  \r\n|--plugin.json  \r\n|--store.js创建插件:import create from '../../westore/create-plugin'\r\nimport store from '../../store'\r\n\r\n//最外层容器节点需要传入 store，其他组件不传 store\r\ncreate(store, {\r\n  properties:{\r\n    authKey:{\r\n      type: String,\r\n      value: ''\r\n    }\r\n  },\r\n  data: { list: [] },\r\n  attached: function () {\r\n    // 可以得到插件上声明传递过来的属性值\r\n    console.log(this.properties.authKey)\r\n    // 监听所有变化\r\n    this.store.onChange = (detail) => {\r\n      this.triggerEvent('listChange', detail)\r\n    }\r\n    // 可以在这里发起网络请求获取插件的数据\r\n    this.store.data.list = [{\r\n      name: '电视',\r\n      price: 1000\r\n    }, {\r\n      name: '电脑',\r\n      price: 4000\r\n    }, {\r\n      name: '手机',\r\n      price: 3000\r\n    }]\r\n\r\n    this.update()\r\n\r\n    //同样也直接和兼容 setData 语法\r\n    this.update(\r\n        { 'list[2].price': 100000 }\r\n    )\r\n  }\r\n})在你的小程序中使用组件：<list auth-key=\"{{authKey}}\" bind:listChange=\"onListChange\" />这里来梳理下小程序自定义组件插件怎么和使用它的小程序通讯:通过 properties 传入更新插件，通过 properties 的 observer 来更新插件通过 store.onChange 收集 data 的所有变更通过 triggerEvent 来抛事件给使用插件外部的小程序这么方便简洁还不赶紧试试 Westore插件开发模板 ！特别强调插件内所有组件公用的 store 和插件外小程序的 store 是相互隔离的。原理页面生命周期函数组件生命周期函数由于开发插件时候的组件没有 this.page，所以 store 是从根组件注入，而且可以在 attached 提前注入:export default function create(store, option) {\r\n    let opt = store\r\n    if (option) {\r\n        opt = option\r\n        originData = JSON.parse(JSON.stringify(store.data))\r\n        globalStore = store\r\n        globalStore.instances = []\r\n        create.store = globalStore\r\n    }\r\n\r\n    const attached = opt.attached\r\n    opt.attached = function () {\r\n        this.store = globalStore\r\n        this.store.data = Object.assign(globalStore.data, opt.data)\r\n        this.setData.call(this, this.store.data)\r\n        globalStore.instances.push(this)\r\n        rewriteUpdate(this)\r\n        attached && attached.call(this)\r\n    }\r\n    Component(opt)\r\n}总结组件 - 对 WXML、WXSS 和 JS 的封装，与业务耦合，可复用，难移植纯组件 - 对 WXML、WXSS 和 JS 的封装，与业务解耦，可复用，易移植插件 - 小程序插件是对一组 JS 接口、自定义组件或页面的封装，与业务耦合，可复用Star & Fork 小程序解决方案https://github.com/dntzhang/westoreLicenseMIT @dntzhang"}
{"title": "Serverless实战驾校小程序【考题练习】二 ", "author": "Rolan", "time": "2018-10-11 00:32", "content": "准备工作做完后，今天我们从核心模块，分类与题目练习开始做。由于开发时间比较紧，这里主要写实习思路，与核心代码。image.png页面一、首页这里我们主要优先实现功能逻辑，UI后面调整，我们用iview 拖一个大致结构的页面。这里用了以下组件{  \"usingComponents\": {    \"i-tab-bar\": \"../../dist/tab-bar/index\",    \"i-tab-bar-item\": \"../../dist/tab-bar-item/index\",    \"i-grid\": \"../../dist/grid/index\",    \"i-grid-item\": \"../../dist/grid-item/index\",    \"i-grid-icon\": \"../../dist/grid-icon/index\",    \"i-grid-label\": \"../../dist/grid-label/index\",    \"i-tabs\": \"../../dist/tabs/index\",    \"i-tab\": \"../../dist/tab/index\"  }}页面二、专项练习页面这个页面，我们从数据库里取出数据，首先建立好数据表，这个表结构昨天有讲。我们导入一个CSV格式数据到表里CSV文件内容bSubjects,title 1,时间题 1,速度题 1,距离题 1,罚款题 1,记分题 1,标志题 1,标线题 1,手势题 1,信号灯 1,灯光题 1,仪表题 1,装置题 1,路况题 1,酒驾题 1,动画题 1,情景题 然后我们取出这里的数据，在小程序里面显示核心代码// 库文件const getQuestionTypeList=()=>{    return new Promise((resolve, reject) => {      const query = wx.Bmob.Query('questionType');      query.find().then(res => {          console.log(res)          resolve(res)      }).catch(err=>{        console.error(err)        reject(err)      })    });}// 页面js文件wechatApp-questions2/pages/topic/index.jsonLoad(e){    wx.u.getQuestionTypeList().then(r=>{      console.log(r,`k`)      this.setData({        result:r      })    })  },  // wxml文件  <i-panel title=\"题型列表\" hide-top>    <!-- <view style=\"padding: 15px;\">头部距离为 0 的 Panel</view> -->    <i-row>        <i-col wx:for=\"{{result}}\" span=\"12\" i-class=\"col-class\">            <i-panel bindtap=\"handleTabClick\" data-id=\"{{item.objectId}}\" class=\"cell-panel-demo\" title=\"\">                <i-cell title=\"{{item.title}}\" value=\"\">                     <i-icon type=\"enterinto\" slot=\"icon\" />                </i-cell>            </i-panel>        </i-col>    </i-row></i-panel>首页点击到分类，分类点击到题目页面，下一个是题目页面，这个页面是整个项目的核心， 所以的题目都在这个页面进行计算，判断。页面三、答题页面 这个页面会是最复杂的一个页面， 涉及到，计时，判断、记录历史等等操作。之前只想到模拟考试，没考虑到这种按照顺序练习， 第二次进入，可以继续之前的题目练习。 这里建个学习表，记录他的顺序练习相关数据，以下是数据表暂定的结构学习表 learning第一步：还是一样，用iview 复制出对应组件第二步：查询出此类别的题目， 并且默认显示一道题，点击下一题，显示数组下一个元素第三步：先做单选题，点击选择，判断是否正确， 如果正确，记录到结果对象 [{\" id \":\" XXX ', '0'}, {\" id \":\" XXX \", \"1\"}] ，0代表回答错误，1正确第四步：点击下一题计算进度条位置，判断当前是否选择了题目，否则提示请选择结果。目前做到这个一步，明天继续。作者：微信小程序开发 链接：https://www.jianshu.com/p/19283a793c60 來源：简书 简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。"}
{"title": "io.Reader游标引发的血案 ", "author": "Rolan", "time": "2018-10-12 00:05", "content": "背景线上运行了一个图片合成程序，默认的小程序二维码中奖是小程序LOGO，不满足需求，所以将微信小程序二维码和用户头像合成在一张图片。由于微信图片有时候返回的Content-Type不对应（比如内容是PNG的，头确是image/jpeg）所以使用jpeg/png/gif的顺序进行图片数据解析，哪个成功就返回解析结果。问题总是出现诸如 invalid JPEG format: missing SOI marker解决过程我去查看jpeg.Decode的源码，如下：func (d *decoder) decode(r io.Reader, configOnly bool) (image.Image, error) {\r\n    d.r = r\r\n\r\n    // Check for the Start Of Image marker.\r\n    if err := d.readFull(d.tmp[:2]); err != nil {\r\n        return nil, err\r\n    }\r\n    if d.tmp[0] != 0xff || d.tmp[1] != soiMarker {\r\n        return nil, FormatError(\"missing SOI marker\")\r\n    }\r\n...soiMarker常量soiMarker  = 0xd8 // Start Of Image.可以看到判断了第1个字节如果不是 0xff 或者第2个字节不是 0xd8 就报错。打印图片的bytes前几个字节如下：[]byte{0xff, 0xd8, 0xff, 0xe0, 0x0, 0x10}可以看到第1个字节和第2个字节满足要求，按理说不会出现这个问题，无奈只能求助于Google,搜索了invalid JPEG format: missing SOI marker 关键字出现一篇 Covert base64 string to JPG 引起了我的注意。打开看到答案You need to create a new reader for each decoder:pngI, errPng := png.Decode(bytes.NewReader(unbased))\r\n\r\n// ...\r\n\r\njpgI, errJpg := jpeg.Decode(bytes.NewReader(unbased))原来需要重新创建读取器，重新创建读取器后问题解决。后续抱着打破砂锅问到底的心态，查看了一下 bytes.Reader 的源码，发现游标读取完后并未重置// Read implements the io.Reader interface.\r\nfunc (r *Reader) Read(b []byte) (n int, err error) {\r\n    if r.i >= int64(len(r.s)) {\r\n        return 0, io.EOF\r\n    }\r\n    r.prevRune = -1\r\n    n = copy(b, r.s[r.i:])\r\n    r.i += int64(n)\r\n    return\r\n}Reader定义type Reader struct {\r\n    s        []byte\r\n    i        int64 // current reading index\r\n    prevRune int   // index of previous rune; or < 0\r\n}可以看到 r.i 就是游标了。问题圆满解决"}
{"title": "小程序源码反编译实战笔记 ", "author": "Rolan", "time": "2018-10-12 00:21", "content": "分分钟上手小程序源码反编译最近在做微信小程序开发，看到一些做的比较有意思的小程序，想看一看他们的源码，于是研究了一下小程序源码反编译相关的技术。结合本次经历，总结如下。手机root要拿到小程序在手机上的源码包，需要有一台越狱的iphone或者一台拥有root权限的android机，正好我手里有一台闲置的小米4，就拿来用了，试过很多种方式给小米4root，差点搞成板砖机，一直在recorvy模式启动不了，最后尝试了小米官网的刷机方法，把系统刷成了开发版，完美root。小米4刷机教程： https://www.miui.com/shuaji-305.html手机刷机成功后，开启root权限，并打开USB调试模式小米4开发版开启root权限： http://www.miui.com/thread-9625466-1-1.htmlMIUI9开启USB调试： https://jingyan.baidu.com/article/49711c6196e728fa441b7c37.html电脑操作以 MacOS 操作系统为例，通过USB连接操作Android手机安装 adb 工具在 MacOS 系统上可以通过 brew 安装 adb 工具brew cask install android-platform-tools\r\n手机连电脑通过USB数据线将手机连接到电脑，并在手机端开启USB调试，通过下面的命令测试是否连接成功adb devices\r\n连接成功的情况下查看小程序源码进入 adb shell 模式adb shell\r\n切换到root权限su\r\n进入小程序源码目录先进入 MicroMsg 文件夹，通过 ls 命令查看文件夹，找到 63c92a20722afef36b525ecb04706c15 这样的文件夹（不同的微信登录用户，这个文件夹的名称不同），然后再进入 appbrand/pkg目录cd /data/data/com.tencent.mm/MicroMsg\r\nls\r\ncd 63c92a20722afef36b525ecb04706c15/appbrand/pkg\r\n查看小程序源码可以先执行 rm -rf ./* 删除掉当前目录下所有缓存的小程序源码包，然后通过手机端点击进入需要获取源码的小程序，再执行 ls -l 即可看到最新操作的小程序源码包rm -rf ./*\r\nls -l\r\n将小程序源码拷贝到手机SD卡cp _1038319936_4.wxapkg /sdcard\r\n新开一个终端窗口，将源码拷贝到电脑adb pull sdcard/_1038319936_4.wxapkg /data/weapp/a.wxapkg\r\n操作过程截图反编译源码下载 nodejs 版本的反编译工具并安装相关 npm 包git clone https://github.com/qwerty472123/wxappUnpacker.git\r\n\r\ncd wxappUnpacker\r\n\r\nnpm install esprima -g\r\nnpm install css-tree -g\r\nnpm install cssbeautify -g\r\nnpm install vm2 -g\r\nnpm install uglify-es -g\r\n反编译小程序源码node wuWxapkg.js /data/weapp/a.wxapkg\r\n最后进入反编译成功的文件，即可看到需要的小程序文件"}
{"title": "在小程序开发中使用 npm ", "author": "Rolan", "time": "2018-10-12 00:37", "content": "本文介绍了如何在微信小程序开发中使用 npm 中包的功能，大大提高微信小程序的开发效率，同时也是微信小程序系列教程的视频版更新。微信小程序在发布之初没有对 npm 的支持功能，这也是目前很多前端开发人员在熟悉了 npm 生态环境后，对微信小程序诟病的地方。微信小程序在 2.2.1 版本后增加了对 npm 包加载的支持，使得小程序支持使用 npm 安装第三方包。微信小程序的功能更新最近更新的也非常给力，如之前给大家介绍的 微信小程序开发平台新功能「云开发」快速上手体验 。1. 在小程序中加载 npm 包微信小程序关于 npm 包的加载使用官方文档在 这里 ，此实战部分我们通过加载一个 npm 的第三方库 miniprogram-datepicker ，此类库用于实现公历与农历的日期选择功能，而微信小程序官方的组件只能简单地选择一个公历时间。在终端中定位到微信小程序的项目文件夹，通过 npm 的安装命令安装。此处请务必使用 –production 选项，可以减少安装一些业务无关的 npm 包，从而减少整个小程序包的大小。2. 构建 npm 包在微信小程序开发工具的「工具」菜单下点击「构建 npm」命令，进行 npm 包的构建，此构建可以将 npm 包构建成在小程序中可加载使用的包。为了帮助大家更好的理解发布 npm 包中提到的各种要求，这里简单介绍一下原理：首先 node_modules 目录不会参与编译、上传和打包中，所以小程序想要使用 npm 包必须走一遍“构建 npm”的过程，在最外层的 node_modules 的同级目录下会生成一个 miniprogram_npm 目录，里面会存放构建打包后的 npm 包，也就是小程序真正使用的 npm 包。构建打包分为两种：小程序 npm 包会直接拷贝构建文件生成目录下的所有文件到 miniprogram_npm 中；其他 npm 包则会从入口 js 文件开始走一遍依赖分析和打包过程（类似 webpack）。寻找 npm 包的过程和 npm 的实现类似，从依赖 npm 包的文件所在目录开始逐层往外找，直到找到可用的 npm 包或是小程序根目录为止。构建完成后还需要确认项目已勾选了「使用 npm 模块」。3. 在项目中使用第三方模块在我们之前实战项目中，在首页中测试下此 npm 模块的加载。<view class=\"doc-container\">\r\n  <view class=\"doc-title\">今日精选</view>\r\n\r\n  <datepicker value=\"\" bindchange=\"bindSolarChange\">\r\n    <button type=\"default\">公历</button>\r\n  </datepicker>\r\n  <datepicker value=\"\" chinese=\"true\" bindchange=\"bindLunarChange\">\r\n    <button type=\"default\">农历</button>\r\n  </datepicker>\r\n\r\n  <block wx:for=\"\" wx:key=\"\">\r\n    <view class=\"list\" data-para=\"\" bindtap=\"tapItem\">\r\n      <view class=\"view_preinfo\">\r\n        <text class=\"list_preinfo\"> / </text>\r\n      </view>\r\n      <text class=\"list_title\"></text>\r\n      <view>\r\n        <block wx:for=\"\" wx:key=\"\">\r\n          <text class=\"list_tag\" style=\"border: solid 1px ;\"></text>\r\n        </block>\r\n      </view>\r\n    </view>\r\n  </block>\r\n</view>在页面中布局完 datepicker 后，保存并完成项目的编译后，点击按钮即可看到组件的加载情况。"}
{"title": "微信小程序裁剪图片成圆形 ", "author": "Rolan", "time": "2018-10-12 10:00", "content": "前言最近在开发小程序，产品经理提了一个需求，要求微信小程序换头像，用户剪裁图片必须是圆形，也在github上看了一些例子，一般剪裁图片用的都是方形，所以自己打算写一个小组件，可以把图片剪裁成圆形，主要思路就是使用canvas绘图，把剪裁的图片绘制成圆形，另外剪裁图片的窗口还可以移动放大缩小，这个功能就用了微信组件movable-view，好了，该说的也说完了，下面咱们开始撸代码。movable-view组件可移动的视图容器，在页面中可以拖拽滑动\r\n会有好多个属性，在这里不一一介绍，只说我们能用到的就可以。\r\n我们用到的属性主要有：direction：movable-view的移动方向，属性值有all、vertical、horizontal、nonescale：是否支持双指缩放，默认缩放手势生效区域是在movable-view内scale-min\t定义缩放倍数最小值scale-max\t定义缩放倍数最大值bindchange\t拖动过程中触发的事件，event.detail = {x: x, y: y, source: source}，其中source表示产生移动的原因，值可为touch（拖动）、touch-out-of-bounds（超出移动范围）、out-of-bounds（超出移动范围后的回弹）、friction（惯性）和空字符串（setData）bindscale\t缩放过程中触发的事件，event.detail = {x: x, y: y, scale: scale}，其中x和y字段在2.1.0之后开始支持返回主要用到的就是这几个值另外使用movable-view的时候必须在外边加一个movable-area的父元素，不然的话没有移动区域。movable-view 的可移动区域，属性只有：scale-area\t当里面的movable-view设置为支持双指缩放时，设置此值可将缩放手势生效区域修改为整个movable-area，是个boolean值，默认false截取区域的移动已经说完了，详情请看developers.weixin.qq.com/miniprogram…canvas绘图画布。该组件是原生组件可以绘制图像，分享朋友圈生成海报就经常用到这个属性，就简单的说下：在wxml中必须要有canvas这个标签，才可以绘制图像，而且要有canvas-id属性，代表canvas 组件的唯一标识符，还有许多API我就不一一介绍了，底下用的API代码当中都会用注释。详情请看微信小程序画布APIhttps://developers.weixin.qq.com/miniprogram/dev/api/canvas/wx.canvasGetImageData.html代码实现首先是选择图片wxml就是初始化一个按钮点击的时候选择图片，而且需要引入我们封装的截取图片组件，并把图片作为参数传进去，封装组件方法请看我另一篇文章juejin.im/post/5afcee…index.wxmlTip: 必须把canvas放到引入剪裁组件的wxml中，否则绘制不成功，因为canvas是原生组件脱离在 WebView 渲染流程外。<view class=\"container\">\r\n  <button wx:if=\"{{!imgSrc}}\" bindtap=\"getImgurl\"> 选择图片 button>\r\n  <view class=\"clip-box\" wx:if=\"{{imgSrc}}\">\r\n      <ClipImg imgSrc=\"{{imgSrc}}\">ClipImg>\r\n  view>\r\nview>\r\n<canvas canvas-id=\"myCanvas\" style=\"position:absolute; width:100%;height:100%;border: 1px solid red;left: -9999px; top: -9999px;\">canvas>\r\n复制代码index.json引入截取图片的组件{\r\n    \"component\": true,\r\n    \"usingComponents\": {\r\n        \"ClipImg\": \"../../component/clipImg/clipImg\"\r\n    }\r\n}\r\n复制代码index.js上传图片显示const app = getApp()\r\n\r\nPage({\r\n  data: {\r\n    imgSrc: ''\r\n  },\r\n  //选择图片\r\n  getImgurl: function () {\r\n    wx.chooseImage({\r\n      count: 1, // 默认9\r\n      sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有\r\n      sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有\r\n      success:  (res) => {\r\n        // 返回选定照片的本地文件路径列表，tempFilePath可以作为img标签的src属性显示图片\r\n        const tempFilePaths = res.tempFilePaths;\r\n        //启动上传等待中...  \r\n        wx.showToast({  \r\n          title: '正在上传...',  \r\n          icon: 'loading',  \r\n          mask: true,  \r\n          duration: 1000 \r\n        }) \r\n        this.setData({\r\n          imgSrc: res.tempFilePaths\r\n        })\r\n      }\r\n    })\r\n  },\r\n  onLoad: function () {\r\n  }\r\n})\r\n复制代码接下来就是剪裁图片组件的封装首先是页面布局，也就是clipImg.wxml<view class=\"clip\">\r\n    <image class=\"head-img\" style=\"width:{{cropperW}}rpx;height:{{cropperH}}rpx\" src=\"{{imageUrl}}\">image>\r\n    <movable-area scale-area style=\"width:{{cropperW}}rpx;height:{{cropperH}}rpx\">\r\n        <movable-view bindchange=\"move\" bindscale=\"scale\" direction=\"all\" scale scale-min=\"0.5\" scale-max=\"1.8\">\r\n        movable-view>\r\n    movable-area>\r\n    <view class=\"btn\">\r\n        <text bindtap=\"cancel\">取消text>\r\n        <text bindtap=\"getImageInfo\">保存text>\r\n    view>\r\nview>\r\n复制代码大概就是这个样子上边的圆就是截取就是截取框。然后就是clipImg.js文件主要就是对图片截取的一些操作Component({\r\n  /**\r\n   * 组件的属性列表\r\n   */\r\n  properties: {\r\n    imgSrc: {\r\n      type: 'String',\r\n      value: ''\r\n    }\r\n  },\r\n\r\n  /**\r\n   * 组件的初始数据\r\n   * imageUrl string 初始化图片\r\n   * cropperW string 缩小图宽度\r\n   * cropperH  string 缩小图高度,\r\n   * img_ratio string  图片比例,\r\n   * IMG_W string 原图高度,\r\n   * IMG_H string 原图高度,\r\n   * left string 图片距离左边距离,\r\n   * top string 图片距离上边距离,\r\n   * clipW number 默认截取框\r\n   */\r\n  data: {\r\n    imageUrl: '',\r\n    cropperW: '',\r\n    cropperH: '',\r\n    img_ratio: '',\r\n    IMG_W: '',\r\n    IMG_H: '',\r\n    left: '',\r\n    top: '',\r\n    clipW: 200\r\n  },\r\n\r\n  /**\r\n   * 组件的方法列表\r\n   */\r\n  methods: {\r\n    //点击取消\r\n    cancel: function () {\r\n      var myEventDetail = {} // detail对象，提供给事件监听函数\r\n      var myEventOption = {} // 触发事件的选项\r\n      this.triggerEvent('myevent', myEventDetail, myEventOption)\r\n    },\r\n    //拖拽事件\r\n    move: function ({ detail }) {\r\n      this.setData({\r\n        left: detail.x * 2,\r\n        top: detail.y * 2\r\n      })\r\n    },\r\n    //缩放事件\r\n    scale: function ({ detail }) {\r\n      console.log(detail.scale)\r\n      this.setData({\r\n        clipW: 200 * detail.scale\r\n      })\r\n    },\r\n    //生成图片\r\n    getImageInfo: function () {\r\n      wx.showLoading({\r\n        title: '图片生成中...',\r\n      })\r\n      const img_ratio = this.data.img_ratio;\r\n      //要截取canvas的宽\r\n      const canvasW = (this.data.clipW / this.data.cropperW) * this.data.IMG_W\r\n      //要截取canvas的高\r\n      const canvasH = (this.data.clipW / this.data.cropperH) * this.data.IMG_H\r\n      //要截取canvas到左边距离\r\n      const canvasL = (this.data.left / this.data.cropperW) * this.data.IMG_W\r\n      //要截取canvas到上边距离\r\n      const canvasT = (this.data.top / this.data.cropperH) * this.data.IMG_H\r\n      // 将图片写入画布\r\n      const ctx = wx.createCanvasContext('myCanvas');\r\n      //绘制图像到画布\r\n      ctx.save(); // 先保存状态 已便于画完圆再用        \r\n      ctx.beginPath(); //开始绘制  \r\n      ctx.clearRect(0, 0, 1000, 1000)\r\n      //先画个圆      \r\n      ctx.arc(this.data.clipW / 2, this.data.clipW / 2, this.data.clipW / 2, 0, 2 * Math.PI, false)\r\n      ctx.clip();//画了圆 再剪切  原始画布中剪切任意形状和尺寸。一旦剪切了某个区域，则所有之后的绘图都会被限制在被剪切的区域内    \r\n      ctx.drawImage(this.data.imageUrl, canvasL, canvasT, canvasW, canvasH, 0, 0, this.data.clipW, this.data.clipW); // 推进去图片        \r\n      ctx.restore(); //恢复之前保存的绘图上下文 恢复之前保存的绘图上下午即状态 可以继续绘制\r\n      ctx.draw(true, () => {\r\n        // 获取画布要裁剪的位置和宽度   \r\n        wx.canvasToTempFilePath({\r\n          x: 0,\r\n          y: 0,\r\n          width: this.data.clipW,\r\n          height: this.data.clipW,\r\n          destWidth: this.data.clipW,\r\n          destHeight: this.data.clipW,\r\n          quality: 0.5,\r\n          canvasId: 'myCanvas',\r\n          success: (res) => {\r\n            wx.hideLoading()\r\n            /**\r\n             * 截取成功后可以上传的服务端直接调用\r\n             * wx.uploadFile();\r\n             */\r\n            //成功获得地址的地方\r\n            wx.previewImage({\r\n              current: '', // 当前显示图片的http链接\r\n              urls: [res.tempFilePath] // 需要预览的图片http链接列表\r\n            })\r\n          }\r\n        })\r\n      })\r\n    }\r\n  },\r\n  ready: function () {\r\n    this.setData({\r\n      imageUrl: this.data.imgSrc[0]\r\n    })\r\n    //获取图片宽高\r\n    wx.getImageInfo({\r\n      src: this.data.imageUrl,\r\n      success: (res) => {\r\n        console.log('图片信息', res);\r\n        //图片实际款高\r\n        const width = res.width;\r\n        const height = res.height;\r\n        //图片宽高比例\r\n        const img_ratio = width / height\r\n        this.setData({\r\n          img_ratio,\r\n          IMG_W: width,\r\n          IMG_H: height,\r\n        })\r\n        if (img_ratio >= 1) {\r\n          //宽比较大，横着显示\r\n          this.setData({\r\n            cropperW: 750,\r\n            cropperH: 750 / img_ratio,\r\n          })\r\n        } else {\r\n          //竖着显示\r\n          this.setData({\r\n            cropperW: 750 * img_ratio,\r\n            cropperH: 750\r\n          })\r\n        }\r\n      } \r\n    })\r\n  }\r\n})\r\n复制代码到现在为止一个截取图片就完成了，可能会有些问题，比如截取的图片的框没有居中，自己可以再次封装这个组件，因为现在已经适合我们公司自己项目了。我们来预览下。另外这个组件支持双指放大截取框来截取图片，不过微信开发者工具不能展示，自己可以把代码下载下来，在自己手机上扫码查看效果。另外我把项目放到了github上边，希望小哥哥小姐姐们多多点赞，多多支持。使用的时候直接把component里边的组件直接引进去就行，有什么疑问可以在github底下留言问我，谢谢。点赞的小哥哥小姐姐最可爱，哈哈哈。。。项目地址github.com/Mr-MengBo/i…"}
{"title": "微信小程序如何开发跑马灯效果？ ", "author": "Rolan", "time": "2018-10-15 00:06", "content": "跑马灯效果比较常见，一般做电商类的小程序，都会用到，所以代码君今天特地写一篇文章，来教一下大家，如何去实现跑马灯效果，下面是代码君实现的效果，可以先看一下！跑马灯效果的制作制作方式很简单，先方上代码，后面会对代码详细讲解一、wxml界面的实现<!-- 跑马灯效果  -->\r\n    <view class=\"example\">\r\n      <view class=\"marquee_box\">\r\n        <view class=\"marquee_text\" style=\"{{orientation}}:{{marqueeDistance}}px;font-size: {{size}}px;\">\r\n          <image src=\"{{adUrl}}\" class='ad-image' />{{text}}\r\n        </view>\r\n      </view>\r\n    </view>\r\n复制代码界面布局很简单，一个底部背景容器，加入一个广播图片和对应的跑马灯文字二、wxss样式.example {\r\n  display: block;\r\n  width: 100%;\r\n  height: 70rpx;\r\n  background-color: #f2f2f2;\r\n  line-height: 70rpx;\r\n}\r\n\r\n.marquee_box {\r\n  width: 100%;\r\n  position: relative;\r\n}\r\n\r\n.marquee_text {\r\n  white-space: nowrap;\r\n  position: absolute;\r\n  top: 0;\r\n  display: flex;\r\n  flex-direction: row;\r\n}\r\n\r\n.ad-image {\r\n  width: 40rpx;\r\n  height: 40rpx;\r\n  margin-right: 10rpx;\r\n  margin-top: 15rpx;\r\n}\r\n复制代码样式就这些，这里代码君要带着大家回顾一下以前教程里讲解的内容文字居中css样式要如何设置？只需要将属性height与line-height设置成一样高度即可display属性none:此元素不会被显示block：两个元素自动换行inline：两个元素靠在一起inherit：继承父类flex：多栏多列三、xxx.jsPage({\r\n  data: {\r\n     text: '51淘甄貨,一个可以省钱的购物平台',\r\n    marqueePace: 1,//滚动速度\r\n    marqueeDistance: 0,//初始滚动距离\r\n    size: 14,\r\n    orientation: 'left',//滚动方向\r\n    interval: 20, // 时间间隔\r\n    adUrl: '../../images/ic_home_msg.png',\r\n  },\r\n  onShow: function () {\r\n    // 页面显示\r\n    var that = this;\r\n    var length = that.data.text.length * that.data.size;//文字长度\r\n    var windowWidth = wx.getSystemInfoSync().windowWidth;// 屏幕宽度\r\n    that.setData({\r\n      length: length,\r\n      windowWidth: windowWidth,\r\n    });\r\n    that.runMarquee();// 水平一行字滚动完了再按照原来的方向滚动\r\n  },\r\n runMarquee: function () {\r\n    var that = this;\r\n    var interval = setInterval(function () {\r\n      //文字一直移动到末端\r\n      if (-that.data.marqueeDistance < that.data.length) {\r\n        that.setData({\r\n          marqueeDistance: that.data.marqueeDistance - that.data.marqueePace,\r\n        });\r\n      } else {\r\n        clearInterval(interval);\r\n        that.setData({\r\n          marqueeDistance: that.data.windowWidth\r\n        });\r\n        that.runMarquee();\r\n      }\r\n    }, that.data.interval);\r\n  }\r\n})\r\n复制代码js里面需要讲解的比较多1. setInterval 计时器如何使用？setInterval(function(){\r\nconsole.log(\"interval\")\r\n},1000)\r\n复制代码这个方法是微信小程序的api，直接使用即可，和正常的定时器一样，setInterval需要传入两个参数，一个是回调的方法，另一个是每隔多久执行一次，在此项目中，我们用的是字段参数interval，值设置为202. settimeout和setinterval()这两个都是腾讯提供的API，他们有什么区别吗？settimeout隔一段时间执行函数且执行一次，场景是我们可能希望一个任务隔一段时间后再执行etinterval()函数是 每 隔一段时间便执行，就是会一直循环执行，如果想停止的话可以使用clearinterval3.跑马灯实现原理第一步：计算跑马灯文字长度第二步：每隔一段时间，移动一点距离，产生移动第三步：当移出屏幕，重置跑马灯的距离为屏幕宽度，然后就可以继续循环第一步操作了根据代码君说的这几步，读者可以去一一对照代码，方法函数runMarquee里面的代码逻辑就是执行以上三步，在此代码君就不过多解释了总结以上就是跑马灯效果的整个流程，原理也不是很难，一个计时器，轻松就可以实现，如果还想学习更多教程，关注《代码集中营》公众号获取最新教程"}
{"title": "微信小程序及各种平台对接常用可逆加密算法aes256 ", "author": "Rolan", "time": "2018-10-15 00:21", "content": "不同程序之间经常会交换数据,我们经常采用的套路是:假设要传输的信息是json,我们假设其为json_data,通过http传递信息为json_data_encode=json_data&sign=md5(json_data+key)接收方通过验证sign就知道内容有没有被篡改.但是,这样json_data作为明码传送会让我们不太开心,所以今天的我们要介绍的aes256出马了,他是一强度很高的可逆加密算法!aes256加密出来的内容是二进制的,不好通过http协议传输,所以我们再配合上base64转成ascii码加密前,aes256要求字节数必须是32字节的倍数,所以使用pkcs7进行填充可以解决问题..介绍完原理,直接贴代码写了3个版本,openresty及python和php的...请查收local aes = require 'resty.aes' local base64_encode = ngx.encode_base64 local base64_decode = ngx.decode_base64 local key = \"a12e93c9edadeaa47eb1aeabe27dabef\" local iv = \"a12e93c9edadeaa4\" -- AES 128 CBC with IV and no SALT local cipher = aes.cipher(256,\"cbc\") local aes_256_cbc_with_iv = aes:new(key,nil,cipher,{iv=iv}) local function decrypt(input)     input = base64_decode(input)     input = aes_256_cbc_with_iv:decrypt(input)     -- 取最后一个字符的ascii值     --local padding = string.byte(input,-1)     --return string.sub(input,-padding)     return input end local function pkcs7_padding(text)     local text_length = string.len(text)     local amount_to_pad = 32 - (text_length % 32)     if amount_to_pad == 0 then         amount_to_pad = 32     end     local pad = string.char(amount_to_pad) return text .. string.rep(pad,amount_to_pad) end local function encrypt (text)     text = pkcs7_padding(text)     text = aes_256_cbc_with_iv:encrypt(text)     return base64_encode(text) end print(decrypt(encrypt('linbc')))接着是python版本的#!/usr/bin/env python# -*- coding: utf-8 -*-import base64from Crypto.Cipher import AESimport binasciiimport StringIOclass PKCS7Encoder(object):    '''    RFC 2315: PKCS#7 page 21    Some content-encryption algorithms assume the    input length is a multiple of k octets, where k > 1, and    let the application define a method for handling inputs    whose lengths are not a multiple of k octets. For such    algorithms, the method shall be to pad the input at the    trailing end with k - (l mod k) octets all having value k -    (l mod k), where l is the length of the input. In other    words, the input is padded at the trailing end with one of    the following strings:             01 -- if l mod k = k-1            02 02 -- if l mod k = k-2                        .                        .                        .          k k ... k k -- if l mod k = 0    The padding can be removed unambiguously since all input is    padded and no padding string is a suffix of another. This    padding method is well-defined if and only if k < 256;    methods for larger k are an open issue for further study.    '''    def __init__(self, k=16):        self.k = k    ## @param text The padded text for which the padding is to be removed.    # @exception ValueError Raised when the input padding is missing or corrupt.    def decode(self, text):        '''        Remove the PKCS#7 padding from a text string        '''        nl = len(text)        val = int(binascii.hexlify(text[-1]), 16)        if val > self.k:            raise ValueError('Input is not padded or padding is corrupt')        l = nl - val        return text[:l]    ## @param text The text to encode.    def encode(self, text):        '''        Pad an input string according to PKCS#7        '''        l = len(text)        output = StringIO.StringIO()        val = self.k - (l % self.k)        for _ in xrange(val):            output.write('%02x' % val)        return text + binascii.unhexlify(output.getvalue())# 使用256位的AES，Python会根据传入的Key长度自动选择，长度为16时使用128位的AESkey = 'a12e93c9edadeaa47eb1aeabe27dabef'mode = AES.MODE_CBC#iv = '1234567812345678'  # AES的CBC模式使用IViv = 'a12e93c9edadeaa4'  # AES的CBC模式使用IVencoder = PKCS7Encoder()text = \"This is for test.\"def encrypt(data):    encryptor = AES.new(key, AES.MODE_CBC, iv)    padded_text = encoder.encode(data)    encrypted_data = encryptor.encrypt(padded_text)    return base64.b64encode(encrypted_data)def decrypt(data):    cipher = base64.b64decode(data)    decryptor = AES.new(key, AES.MODE_CBC, iv)    plain = decryptor.decrypt(cipher)    return encoder.decode(plain)#encrypted_text = encrypt(text)encrypted_text = 'MD1ZOvuyvut4VEed4rf+8YKaOHyECJK/RWLcfVsJwjAEZp8Hhi1zi7oH3PLSygjFCAxCRJqMBzm/qhreznkg34Vgbho+zwprTgl4M0c0lRkvLzWzXmSYG8pcqth1qnbNSwQeS3MPuofgVXR0SGMTIzicCXDlmwQV9uvIJekgES2LMse4pVndcrftI9f6UbIiT085DhAaiV9yGsV3r4FES+LnwP9ZNi58TButNC9owyKh9RuRn7z04LfNy++7iLjzk/HurOkBkJewHSchLER+pK94qhg6Lj8mW7dl+y5j3wbXY9SodNK+S8LDRYCa1JyZ/w8rffUK8YCY+jCT3ZmV8G5vdUENTqsrB4jX87C+XQCY9WEG+VQ5MK5XlhhvMPZyn2NLZUi6gW1HjqE6i/uefzq/LFl47cL2Hmr/cLbfI5rF+d1hMAIZGNnRxjYkVVvipEwRSlkD47ZVFLiWRKPusB7Lke3mnGJ1O+5eQnREL7Q/xpRT+3JuCcOqZIZJFFrJXMj9CXsJGMXxFkfnKT3UAhOi/lRA65Vwt1BEswHuZzLLHquyEYQMc3cOW1vy1Fv4zpYkjHYmxB1g50gwVryrEW2kY58sDdxwDYua3jLwERk='clean_text = decrypt(encrypted_text)print \"encrypted_text:\", encrypted_textprint \"clean_text: \", clean_text再来个php版本的<?php//function aes256EcbPkcs7PaddingEncrypt($key, $data) {//    $padding = 16 - (strlen($data) % 16);//    $data .= str_repeat(chr($padding), $padding);//    return mcrypt_encrypt(MCRYPT_RIJNDAEL_256, hash('SHA256', $key, true), $data, MCRYPT_MODE_ECB);//}////function aes256EcbPkcs7PaddingDecrypt($key, $data) {//    $data = mcrypt_decrypt(MCRYPT_RIJNDAEL_256, hash('SHA256', $key, true), $data, MCRYPT_MODE_ECB);//    $padding = ord($data[strlen($data) - 1]); //    return substr($data, 0, -$padding); //}$txt=\"MD1ZOvuyvut4VEed4rf+8YKaOHyECJK/RWLcfVsJwjAEZp8Hhi1zi7oH3PLSygjFCAxCRJqMBzm/qhreznkg34Vgbho+zwprTgl4M0c0lRkvLzWzXmSYG8pcqth1qnbNSwQeS3MPuofgVXR0SGMTIzicCXDlmwQV9uvIJekgES2LMse4pVndcrftI9f6UbIiT085DhAaiV9yGsV3r4FES+LnwP9ZNi58TButNC9owyKh9RuRn7z04LfNy++7iLjzk/HurOkBkJewHSchLER+pK94qhg6Lj8mW7dl+y5j3wbXY9SodNK+S8LDRYCa1JyZ/w8rffUK8YCY+jCT3ZmV8G5vdUENTqsrB4jX87C+XQCY9WEG+VQ5MK5XlhhvMPZyn2NLZUi6gW1HjqE6i/uefzq/LFl47cL2Hmr/cLbfI5rF+d1hMAIZGNnRxjYkVVvipEwRSlkD47ZVFLiWRKPusB7Lke3mnGJ1O+5eQnREL7Q/xpRT+3JuCcOqZIZJFFrJXMj9CXsJGMXxFkfnKT3UAhOi/lRA65Vwt1BEswHuZzLLHquyEYQMc3cOW1vy1Fv4zpYkjHYmxB1g50gwVryrEW2kY58sDdxwDYua3jLwERk=\";$txt=base64_decode($txt);$key=\"a12e93c9edadeaa47eb1aeabe27dabef\";$iv ='a12e93c9edadeaa4';$module = mcrypt_module_open(MCRYPT_RIJNDAEL_128, '', MCRYPT_MODE_CBC, '');mcrypt_generic_init($module, $key, $iv);$data = mdecrypt_generic($module, $txt);mcrypt_generic_deinit($module);mcrypt_module_close($module);$padding = ord($data[strlen($data) - 1]); $result = substr($data, 0, -$padding); echo $result;exit();?>php果然是...很省事的语言..看他多简短啊."}
{"title": "小程序国际化实现机制 ", "author": "Rolan", "time": "2018-10-15 00:34", "content": "需求可手动设置使用语言根据不同的语言显示不同的语言文字（目前是支持中英文，如需其他语言，可直接配置即可） 如果没有配置相应语言的信息，则使用默认的数据 国际化分为文字和图片（有的图片上有文字信息）两类 限制因素小程序2m的限制所以图片网络化\" style=\"margin: 20px 0px; font-family: \"PingFang SC\", \"Hiragino Sans GB\", \"Helvetica Neue\", \"Microsoft Yahei\", \"WenQuanYi Micro Hei\", sans-serif; font-weight: 500; line-height: 40px; color: rgb(44, 62, 80); text-rendering: optimizeLegibility; font-size: 21px; background-color: rgb(249, 249, 245);\">因小程序2M的限制，所以图片网络化地图上的图片（如markers、controls、polyline等），不能使用网络图片，只能使用本地图片；所以图片的话分为本地图片和网络图片两种实现机制目录结构信息res │ resUtils.js │ ├─values │ img.js │ strings.js│ ├─values_en │ img.js │ strings.js │└─values_zh_CN strings.js values中是默认的是数据配置，values_en是英文坏境下的配置，values_zh_CN中文简体环境下的配置 后面如果需要配置其他的语言（如zh_TW，中文繁体，台湾地区），只需要新建文件名 values_zh_TW即可 resUtils.js是国际化的核心代码位置，这个文件会根据不同的语言来引用引用对应的文件； 首次如果没有设置过语言，或跟从当前手机的语言环境，后面如果设置过语言的话，跟从设置的语言来（暂定，具体的需求还未出） 具体配置文字国际化，直接在对应的环境下strings.js中添加要用的文字信息，文件会自动导出module.exports = {  LOGIN_STATUS_INVALID: '登录失效',  LOGIN_LOG_AGAIN: '请重新登录',}module.exports = {  LOGIN_STATUS_INVALID: 'Login status invalid',  LOGIN_LOG_AGAIN: 'Log in again',}图片国际化（分为本地和网络图片两种）； 网络图片直接调用getImg('drawableName.png')，即可； 本地图片，使用绝对路径即可/** * 默认环境图片配置 * @author Shirley.jiang  */const ICON_URL = 'https://***';let env = 'zh_CN';let getImg = (name) => {  return ICON_URL + '/' + env + '/' + name;}module.exports = {  IC_BTN_PHONE: getImg('btn_phone.png'), // 网络图片  ICON_LOCATION: '/imgs/icon_location.png', // 本地图片}/** * en环境图片配置 * @author Shirley.jiang  */const ICON_URL = 'https://***';let env = 'en';let getImg = (name) => {  return ICON_URL + '/' + env + '/' + name;}module.exports = {  IC_CHANGE_LANGUAGE: getImg('ic_change_language.png')};使用方式const resUtils = require('../../res/resUtils.js'); // 引入resUtils.strings.LOGIN_STATUS_INVALID; // 文字调用resUtils.imgs.IC_CHANGE_LANGUAGE； // 图片调用注意事项因wxml 文件不能应用js文件，所以数据全部通过data进行中转 data的加载比生命周期要早，导致切换语言的时候，data数据没有更新；所以在Page和Component中的ready方法之后，手动setData一次（因未找到更好的解决方案，暂定这种方式） 附带[resUtils.js]代码const localStorage = require('../utils/LocalStorage.js');/*** 国际化* @author Shirley.jiang*/class ResUtils {  static mInstance;  mStrings = {};  mImgs = {};  mEnv;  static getInstance() {    if (!ResUtils.mInstance) {      ResUtils.mInstance = new ResUtils();    }    return ResUtils.mInstance;  }  init(env) {      this.mEnv = env;      this.initStrings();          this.initImgs();  }   /**   * 引用字符配置   */  initStrings() {       this.mStrings = {};       let strings;       let defaultStrings;       try {      strings = require('./values_' + this.mEnv + '/strings.js');   } catch (err) { }       try {      defaultStrings = require('./values/strings.js');   } catch (err) { }       // 初始化默认的数据   for (let key in defaultStrings) {             if (!defaultStrings.hasOwnProperty(key)) {                   continue;       }             this.mStrings[key] = defaultStrings[key];   }       // 如果当前语言文件中定义的有，则直接覆盖   for (let key in strings) {             if (!this.mStrings.hasOwnProperty(key)) {                   continue;       }             this.mStrings[key] = strings[key];    }  }     /**   * 引用图片配置   */  initImgs() {       this.mImgs = {};       let imgs;       let defaultImgs;       try {      imgs = require('./values_' + this.mEnv + '/img.js');    } catch (err) { }       try {      defaultImgs = require('./values/img.js');    } catch (err) { }       // 初始化默认的数据   for (let key in defaultImgs) {             if (!defaultImgs.hasOwnProperty(key)) {                   continue;       }             this.mImgs[key] = defaultImgs[key];    }        // 如果当前语言文件中定义的有，则直接覆盖    for (let key in imgs) {              if (!this.mImgs.hasOwnProperty(key)) {                    continue;        }              this.mImgs[key] = imgs[key];    }  }     /**   * 切换语言   * @param {string} env 语言值   */  changeLanguage(env) {    localStorage.setEnv(env);        this.init(env);  }}/*** zh_CN 中文* zh_TW 中文繁体(台湾)* en 英文环境*/let env = localStorage.getEnv();ResUtils.getInstance().init(env);module.exports = ResUtils.getInstance();感谢《小程序开发一群》的Shirley.jiang投稿。"}
{"title": "小程序产品设计中的坑 ", "author": "Rolan", "time": "2018-10-16 00:01", "content": "本文系统地罗列了微信小程序在产品设计上的出现的问题，并提出了相应的建议。资质不是所有功能都可以做，根据不同主体，会有不同的开放类目。主体分为「非个人主体」「个人主体」「海外主体」。有些类目需要有资质，比如社交类（包括社区、笔记等），都要 ICP 证。如果做了功能提交审核，发现的话会被拒绝，要求添加相关分类。官方文档： 小程序开放的服务类目对策：做服务端开关，审核时把功能隐藏（暂时貌似没有程序静态检查，只有人工审核），审核后再打开，但要承担被下架的风险。虚拟支付18年5月，由于苹果公司要求，iOS的小程序虚拟商品支付被禁止，即内容付费、工具服务类等，不包括外卖、电商这些；如果被发现，会屏蔽支付接口。对策：加入实体商品的性质，比如购买课程变成购买课程+书，加入收货地址等信息。模版消息推送可以给用户推送模版消息，会在「服务通知」里提醒，对留存比较有帮助（唤起用户）。有次数和时间限制，两种方式可以获得下发次数：支付：每次支付有 3 条下发次数，可以在 7 天内推送。提交表单：每次提交有 1 条下发次数，可以在 7 天内推送。官方文档： 模版消息大部分小程序都没有支付，主要靠提交表单，即需要用 <form/> 组件，让用户手动触发确认。常见做法会把 <form/> 伪装成一个列表项、某个按钮等，用户在使用过程中就获得了下发次数，但有违规风险。Tab bar 的 action button有的产品想要在 tab bar 加上 action button，比如：发布内容、新建文章等。但小程序原生 tab bar 目前不支持跳转新页面，只支持在当前打开页面。而如果自己实现 tab bar，性能会很差（切换 tab 时卡顿、页面闪烁）。有种做法，依然用原生 tab bar，但把 icon 素材做成 action button 的样式，然后在当前打开页面，列出一些选项让用户选择，再进入子页面。比如可以参考「美篇」的开始创作，先让用户选择文字、图片、视频，然后再进入文章编辑的子页面。自定义导航栏例如「知乎热榜」小程序，搜索框在导航栏。怎么做到的？其实是微信版本 6.6.0 后支持的特性，navigationStyle 可以设置为 custom，设置后顶栏就消失了，页面会自动顶到最顶部。所以「知乎热榜」那个搜索栏不是属于顶栏，而是属于页面内容，这下就好理解了。 ​​​​官方文档： 全局配置 – windowWebview小程序中可以使用 webview 组件，直接把 mobile web 套到小程序里，比如「多抓鱼」就是以 webview 为主的。好处：节省工作量，已有的 mobile web 不用重复开发。不需要等审核，随时部署更新。直接兼容一些小程序不支持的原生标签，比如 <pre/>。坏处：一个页面里只能有一个 <webview/> 组件，不能有其它。比如想用原生的 <button/> 来调起支付、分享，就不可以。只有绑定为业务域名的 url 才能跳转，不可以随便打开什么网页，上限 20 个。其它杂七杂八绑定的服务器域名，需要国内 ICP 备案，所以想做个 dribbble 客户端，直接利用 dribbble API 是不行的，只能想办法用自己服务器做数据转发。小程序之间可以互相跳转，但必须绑定在同一公众号下，而且具体跳转的是哪个小程序、哪个页面，要手动配置小程序 AppID 和路径。不能长按别二维码，也没办法下载 app。如果需要绑定手机号，可以使用小程序的 获取手机号 接口，调的是微信绑定了的手机号，很方便。作者：刘英滕链接：https://www.jianshu.com/p/f36e0aceed98本文由 @刘英滕 授权发布于人人都是产品经理，未经作者许可，禁止转载。题图来自Unsplash，基于CC0协议"}
{"title": "微信小程序onLaunch异步，首页onLoad先执行? ", "author": "Rolan", "time": "2018-9-20 00:32", "content": "本来按照事件顺序，小程序初始化时触发App里的onLaunch，后面再执行页面Page里的onLoad，但是在onLaunch里请求获取是否有权限，等待返回值的时候Page里的onLoad事件就已经执行了。//app.jsApp({  onLaunch: function () {    console.log('onLaunch');    wx.request({      url: 'test.php', //仅为示例，并非真实的接口地址      data: {      },      success: function(res) {        console.log('onLaunch-request-success');        // 将employId赋值给全局变量，提供给页面做判断        this.globalData.employId = res.employId;         }    })  },  globalData: {    employId: ''  }})//index.js//获取应用实例const app = getApp()Page({  data: {    albumDisabled: true,    bindDisabled: false  },  onLoad: function () {    console.log('onLoad');    console.log('onLoad app.globalData.employId = ' + app.globalData.employId);    //判断是用户是否绑定了    if (app.globalData.employId && app.globalData.employId != '') {      this.setData({        albumDisabled: false,        bindDisabled: true      });  }})控制台打印的结果是onLaunchonLoadonLoad app.globalData.employId = onLaunch-request-success要是能等完onLaunch请求完再执行Page的onLoad方法那该多好。 这里采用的方法是定义一个回调函数。 Page页面判断一下当前app.globalData.employId是否有值，如果没有（第一次）则定义定义一个app方法（回调函数）app.employIdCallback = employId => {...}。 App页面在请求success后判断时候有Page页面定义的回调方法，如果有就执行该方法。因为回调函数是在Page里面定义的所以方法作用域this是指向Page页面。//app.jsApp({  onLaunch: function () {    wx.request({      url: 'test.php', //仅为示例，并非真实的接口地址      data: {      },      success: function(res) {        this.globalData.employId = res.employId;        //由于这里是网络请求，可能会在 Page.onLoad 之后才返回        // 所以此处加入 callback 以防止这种情况        if (this.employIdCallback){           this.employIdCallback(res.employId);        }      }    })  },  globalData: {    employId: ''  }})//index.js//获取应用实例const app = getApp()Page({  data: {    albumDisabled: true,    bindDisabled: false  },  onLoad: function () {    //判断是用户是否绑定了    if (app.globalData.employId && app.globalData.employId != '') {      this.setData({        albumDisabled: false,        bindDisabled: true      });    } else {      // 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回      // 所以此处加入 callback 以防止这种情况      app.employIdCallback = employId => {        if (employId != '') {          this.setData({            albumDisabled: false,            bindDisabled: true          });        }      }    }  }})这样的话，就能实现想要的结果。执行顺序就是：[App] onLaunch -> [Page] onLoad -> [App] onLaunch sucess callback作者：mipaifu328 链接：https://www.jianshu.com/p/aaf65625fc9d"}
{"title": "小程序挖坑之路 ", "author": "Rolan", "time": "2018-9-21 00:05", "content": "小程序出来那么久一直没有深入的开发，这次借着公司要做小程序，深入探索了一番，结果挖坑无数，当然，仅限挖坑，并没有填完。哈哈，就先mark一下。因为公司业务需求，这次小程序用的是 mpvue + typescript 进行开发。mpvue 相关的坑关于 input 问题因为设计想把输入框的交互做成这个样子：那用原生的输入框是满足不了的，只能自己写组件咯。那么就用vue的方式写了个组件，结果发现， mpvue 关于 input 的问题还真不少。input 用v-modal输入时候闪烁组件嵌套slot有问题input 不支持:type 和v-modalslot等标签不支持添加class，无法编译成wxss嵌套组件，props有问题修改slot时，不能热更新，只能重新npm run dev这是github上相关的issue：inout闪烁issue嵌套组件slot问题11嵌套组件slot问题222关于这个问题，试了上述的解决方法，但没有很好的解决（摔）。所以，自己用原生的方式重新撸了个组件。小程序相关的坑原生组件 canvas 问题因为公司因为，小程序里有不少的图表数据需要展现，自然就是需要用到 cavas ，而 canvas是属于原生组件，它的 z-index 无限大，一出现有弹窗内容需要把它覆盖就gg。实际上是能解决的，只要使用 cover-view 当做遮罩层（一开始我还以为，需要把 cover-view嵌套到原生组件的节点里），把弹窗内容一并放入 cover-view 里，但是很鸡肋的是， cover-view 里面包含的节点问题，以及一些样式问题是没办法实现。如果是弹窗内容很酷炫的话，那我只能建议让设计改设计稿。<view>\r\n    <canvas canvas-id=\"test\"></canvas>\r\n    // 这是一个遮罩层，为了覆盖住原生组件（ 1.9.0及以上才支持 ）\r\n    <cover-view>\r\n        这是一个遮罩层balabala\r\n    </cover-view>\r\n    \r\n    // 官方给的demo\r\n    <video>\r\n        <cover-view>\r\n            这里也可以覆盖video里的内容\r\n        </cover-view>\r\n    </video>\r\n<view>\r\n复制代码下面是我遇到的相关bug:文本都要套上 cover-view 标签，不然排版错误。cover-view 里的内容不支持设置 渐变，阴影 等样式。自定义组件嵌套 cover-view 时，自定义组件的 slot 及其父节点暂不支持通过 wx:if 控制显隐，否则会导致 cover-view 不显示canvas 不能放在可滚动的列表里，在页面滑动时，在真机效果下， canvas 不能很好的跟着滚动，会出现刚开始滚动不动，再滚动就会卡着突然消失的非常糟糕的效果cover-image 不支持 bindtouchstart 等touch事件总的来说，小程序的原生组件问题还是很多的，具体的实现都要在真机上测试才能看出各种问题。使用echart-for-wx 的坑解决弹窗覆盖canvas的问题，同样的是用上面的方法解决方法：echart使用 cover-view 是要在节点 ec-canvas 后面添加，通过样式控制 cover-view 的对应位置<ec-canvas class=\"canvas\" id=\"mychart-dom-line\" canvas-id=\"mychart-line\" :ec=\"ecLine\">\r\n</ec-canvas>\r\n<cover-view class=\"cover-view\">cover-vdddddddddddddiew</cover-view>\r\n复制代码echart 在使用 rpx 为单位时，出现机型适配问题echart 在不同机型上适配问题，使用单位为 px 时，适配是没问题的，但是使用 rpx 时，就会出现小机型适配问题，而使用mpvue的话，单位为 px 会转换成 rpx ，就会出现如下问题：实际效果：预期效果：解决方法：在 mpvue 里，使用内联样式（内联样式不会把 px 转成 rpx ），最好只固定高 emmmm....结果发现，大屏小屏手机下都会有适配问题，所以不能单纯的用内联样式写死 px 的大小(在GitHub上提了个issue，至今未回，怕死石沉大海啦)canvas生成图片适配问题因为不同手机大小以及其设备像素比devicePixelRatio不一致，再来小程序还出了自己的单位 rpx ，所以如果生成canvas是固定写死其宽高，这样是用问题的。基本算法是：canvas 绘制使用的是 px 单位，但不同设备的 px 是需要换算的，所以在组件中统一使用rpx单位，这里就涉及到单位怎么换算问题。 通过 wx.getSystemInfoSync 获取设备屏幕尺寸，从而得到比例，进而做转换，代码如下：const sysInfo = wx.getSystemInfoSync();\r\nconst screenWidth = sysInfo.screenWidth;\r\nthis.factor = screenWidth / 750; // 获取比例\r\nfunction toPx(rpx) { // rpx转px\r\n    return rpx * this.factor;\r\n}\r\nfunction toRpx(px) { // px转rpx\r\n    return px / this.factor;\r\n},\r\n复制代码但我知道大家都很懒，有轮子干嘛不用实在不想算，可以用现成的轮子 小程序canvas生成图片再来就是， cavans 转图片的问题需要使用 canvasToTempFile 方法，因为 canvas 节点一定要存在才能获取到 canvas 的上下文进行绘图，所以只能把 canvas 放到页面可视区域之外。而且转换成图片时，要加个神奇的 setTimeout 的延时。最小延时为 300ms ，再小就不管用了。（为什么，我也不知道，o(╥﹏╥)o）最后这只是一点挖坑心得记录而已，还有更多的坑需要继续发掘。"}
{"title": "小程序 lazy-load 不生效的问题 ", "author": "Rolan", "time": "2018-9-21 00:17", "content": "最近在开发家里喵喵的小程序（娱乐），本想抽一小部分时间做个懒加载。看了小程序官网 API，给 image 标签加上 lazy-load 就能实现懒加载。但从微信开发者工具看，似乎并没有生效。搜了一下，很多小伙伴似乎都遇到了问题，并没有解决。但经过我的验证， 懒加载确实是生效了 。只不过， 小程序会提前加载当前屏幕和下一屏的图片，导致感知不到懒加载的存在。个人认为，这样的懒加载比传统懒加载的体验更加好。我的验证过程：验证过程wxml部分（用 scroll-view 并且加上 bindload）：<scroll-view class=\"container\" scroll-y>  \r\n  <view wx:for=\"{{list}}\" class=\"list-item\"> \r\n    <image class=\"list-img\" lazy-load src=\"{{item.img}}\" bindload='onLazyLoad'></image>\r\n    <view>{{item.desc}}</view>\r\n  </view>\r\n</scroll-view>js部分：const app = getApp()  \r\nPage({  \r\n  data: {\r\n    list: []\r\n  },\r\n  onLazyLoad(info) {\r\n    console.log(info)\r\n  }\r\n})最终效果首屏输出日志：清空首屏输出日志后，滑动过程中输出的日志：整张页面一共有 13 张图。因此，确实是进行了懒加载。魁拔喵喵喵最后，介绍下我的小程序：魁拔喵喵喵（已经能搜到啦）。功能目前比较简陋，欢迎交流和意见。"}
{"title": "小程序的全栈开发新时代 ", "author": "Rolan", "time": "2018-9-21 00:26", "content": "什么是小程序·云开发小程序·云开发是微信团队和腾讯云团队共同研发的一套小程序基础能力，简言之就是：云能力将会成为小程序的基础能力。整套功能是基于腾讯云全新推出的云开发(Tencent Cloud Base)所研发出来的一套完备的小程序后台开发方案。小程序·云开发为开发者提供完整的云端流程，简化后端开发和运维概念，无需搭建服务器，使用平台提供的 API 进行核心业务开发，即可实现快速上线和迭代。该解决方案目前提供三大基础能力支持：存储：在小程序前端直接上传/下载云端文件，在小程序云控制台可视化管理数据库：一个既可在小程序前端操作，也能在云函数中读写的文档型数据库云函数：在云端运行的代码，微信私有协议天然鉴权，开发者只需编写业务逻辑代码未来，我们还会集成更多的服务能力，为小程序提供更强有力的云端支持。如何使用小程序·云开发上面就是小程序·云开发简单的使用图谱：在小程序端，直接用官方提供的接口，在云函数端，直接用官方提供的 Node SDK，就可以操作你云的资源。以前开发小程序所担忧的数据库搭建、文件系统部署，通通没有。你只需要有在小程序开发 IDE 里面的 云开发，开通一下，填写环境 ID，便可以拥有小程序的云能力！当然，其实用云开发，并不排斥原有的后台架构，通过下面的架构，你也可以无缝与原有的后台服务兼容，也简化了一些小程序鉴权的逻辑：接下来，我会分别从小程序端、服务端讲述如何使用这些云资源。使用云能力小程序端客户端，这里是指在小程序端中。如果要使用云开发能力，请做以下配置：在 app.json / game.json 中， 中增加字段 \"cloud\": trueproject.config.json 中增加了字段 cloudfunctionRoot 用于指定存放云函数的目录初始化云开发能力：//app.js\r\nApp({\r\n  onLaunch: function () {\r\n    wx.cloud.init({\r\n        traceUser: true // 用户信息会显示在云开发控制台的用户面板中\r\n    });\r\n  }\r\n});\r\n小程序端初始化能力文档在用户管理中会显示使用云能力的小程序的访问用户列表，默认以访问时间倒叙排列，访问时间的触发点是在小程序端调用 wx.cloud.init 方法，且其中的 traceUser 参数传值为 true。服务端如果你想在云函数中，操作文件、数据库和云函数资源，你可以使用我们提供的服务端 SDK 进行操作。首先，进入到你的某个云函数中，安装以下依赖包：npm i --save tcb-admin-node\r\n在云函数中初始化// 初始化示例\r\nconst app = require('tcb-admin-node');\r\n\r\n// 初始化资源\r\n// 云函数下不需要secretId和secretKey。\r\n// env如果不指定将使用默认环境\r\napp.init({\r\n  secretId: 'xxxxx',\r\n  secretKey: 'xxxx', \r\n  env: 'xxx'\r\n});\r\n\r\n//云函数下使用默认环境\r\napp.init()\r\n\r\n//云函数下指定环境\r\napp.init({\r\n  env: 'xxx'\r\n});\r\n服务端初始化文档存储云开发提供存储空间、上传文件、下载文件、CDN加速文件访问等能力,开发者可以在小程序端与服务端通过 API 使用这些能力。小程序端// 选择图片\r\nwx.chooseImage({\r\n    success: dRes => {\r\n        // 上传图片\r\n        const uploadTask = wx.cloud.uploadFile({\r\n            cloudPath: `${Date.now()}-${Math.floor(Math.random(0, 1) * 10000000)}.png`, // 随机图片名\r\n            filePath: dRes.tempFilePaths[0], // 本地的图片路径\r\n            success: console.log,\r\n            fail: console.error\r\n        });\r\n    },\r\n    fail: console.error,\r\n});\r\n小程序端存储文档服务端const app = require('tcb-admin-node');\r\napp.init();\r\n\r\napp.uploadFile({\r\n    cloudPath: \"cover.png\",\r\n    fileContent: fs.createReadStream(`${__dirname}/cover.png`)\r\n}).then((res) => {\r\n    console.log(res);\r\n}).catch((err) => {\r\n    console.error(err);\r\n});;\r\n控制台上传好的文件，就会出现在控制台中，如下图。你可以在控制台里删除、下载或者查看图片的详情。你还可以控文件整体的权限，这里还有一些具体的介绍。服务端存储文档数据库小程序云提供文档型数据库 ( document-oriented database )，数据库包含多个集合（相当于关系型数据中的表），集合近似于一个 JSON 数组，数组中的每个对象就是一条记录，记录的格式是 JSON 文档。每条记录都有一个 _id 字段用以唯一标志这条记录、一个 _openid 字段用以标志记录的创建者，即小程序的用户。开发者可以自定义 _id，但不可在小程序端自定义（在服务端可以） _openid 。_openid 是在文档创建时由系统根据小程序用户默认创建的，开发者可使用其来标识和定位文档。数据库 API 分为小程序端和服务端两部分，小程序端 API 拥有严格的调用权限控制，开发者可在小程序内直接调用 API 进行非敏感数据的操作。对于有更高安全要求的数据，可在云函数内通过服务端 API 进行操作。云函数的环境是与客户端完全隔离的，在云函数上可以私密且安全的操作数据库。数据库 API 包含增删改查的能力，使用 API 操作数据库只需三步：获取数据库引用、构造查询/更新条件、发出请求。切记，在操作数据库前，请先在控制台中创建 collection。小程序端const db = wx.cloud.database();\r\n\r\n// 插入数据\r\ndb.collection('photo').add({\r\n    data: {\r\n        photo: 'cloud://tcb-xxx/05ca1d38f86f90d66d4751a730379dfa6584dde05ab4-Ma9vMN_fw658.jpg',\r\n        title: '风景'\r\n    }\r\n});\r\n\r\n// 提取数据\r\ndb.collection('photo').get().then((res) => {\r\n    let data = res.data;\r\n    console.log(data);\r\n});\r\n\r\n// 输出\r\n// 在小程序端， _openid 会自动插入到数据库中\r\n{\r\n    photo: 'cloud://tcb-xxx/05ca1d38f86f90d66d4751a730379dfa6584dde05ab4-Ma9vMN_fw658.jpg',\r\n    title: '风景',\r\n    _openid: 'oLlMr5FICCQJV-QgVLVzKu1212341'\r\n}\r\n小程序端数据库文档服务端const app = require('tcb-admin-node');\r\napp.init();\r\nconst db = app.database();\r\n\r\ndb.collection('photo').limit(10).get().then((res) => {\r\n    console.log(res);\r\n}).catch((err) => {\r\n    console.error(err);\r\n});\r\n\r\n// 输出\r\n// 因为是在服务端，其它用户的也可以提取出来\r\n{\r\n    photo: 'cloud://tcb-xxx/05ca1d38f86f90d66d4751a730379dfa6584dde05ab4-Ma9vMN_fw658.jpg',\r\n    title: '风景',\r\n    _openid: 'oLlMr5FICCQJV-QgVLVzKu1342121'\r\n}\r\n{\r\n    photo: 'cloud://tcb-xxx/0dc3e66fd6b53641e328e091ccb3b9c4e53874232e6bf-ZxSfee_fw658.jpg',\r\n    title: '美女',\r\n    _openid: 'DFDFEX343xxdf-QgVLVzKu12452121'\r\n}\r\n{\r\n    photo: 'cloud://tcb-xxx/104b27e339bdc93c0da15a47aa546b6e9c0e3359c315-L8Px2Y_fw658.jpg',\r\n    title: '动物',\r\n    _openid: 'DFDFEX343xxdf-QgVLVzKu1342121'\r\n}\r\n服务端数据库文档控制台可以在控制台里，看到用户操作的数据，你也可以自己在控制台上添加、更新或删除数据。如果数据量庞大，可以设置索引提供查询的效率。数据库也可以通过设置权限，管控每个 collection。云函数云函数是一段运行在云端的代码，无需管理服务器，在开发工具内一键上传部署即可运行后端代码。开发者可以在云函数内获取到每次调用的上下文（appid、openid 等），无需维护复杂的鉴权机制，即可获取天然可信任的用户登录态（openid）。小程序端wx.cloud.callFunction({\r\n    name: 'addblog', // 云函数名称\r\n    data: { // 传到云函数处理的参数\r\n        title: '云开发 TCB',\r\n        content: '存储、数据库存、云函数'\r\n    }\r\n}).then(res => {\r\n    console.log(res)\r\n}).catch((err) => {\r\n    console.error(err);\r\n});\r\n小程序端云函数文档服务端const app = require(\"tcb-admin-node\");\r\napp.init();\r\n\r\napp.callFunction({\r\n    name: 'addblog', // 云函数名称\r\n    data: { // 传到云函数处理的参数\r\n        title: '云开发 TCB',\r\n        content: '存储、数据库存、云函数'\r\n    }\r\n}).then((res) => {\r\n    console.log(res);\r\n}).catch((err) => {\r\n    console.error(err);\r\n});\r\n服务端云函数文档控制台上传好之后的云函数，都会在这里罗列出来。每次调用云函数，都可以在这里看到日志，还可以构造测试的参数，用于调试。语法糖大部份的接口，目前都支持两种写法，分别是Promise 和 Async/Await，本节以 callFunction作为例子，在云函数中介绍这两种写法。 Async/Await 本质上是基于 Promise 的一种语法糖，它只是把 Promise 转换成同步的写法而已。Promiseconst app = require(\"tcb-admin-node\");\r\napp.init();\r\n\r\nexports.main = (event, context, callback) => {\r\n    app.callFunction({\r\n        name: 'addblog', // 云函数名称\r\n        data: { // 传到云函数处理的参数\r\n            title: '云开发 TCB',\r\n            content: '存储、数据库存、云函数'\r\n        }\r\n    }).then((res) => {\r\n        console.log(res);\r\n        callback(null, res.data);\r\n    }).catch((err) => {\r\n        callback(err);\r\n    });\r\n};\r\nAsync/Awaitconst app = require(\"tcb-admin-node\");\r\napp.init();\r\n\r\nexports.main = async (event, context) => {\r\n    let result = null;\r\n\r\n    try {\r\n        result = await app.callFunction({\r\n            name: 'addblog', // 云函数名称\r\n            data: { // 传到云函数处理的参数\r\n                title: '云开发 TCB',\r\n                content: '存储、数据库存、云函数'\r\n            }\r\n        });\r\n    }\r\n    catch (e) {\r\n        return e;\r\n    }\r\n\r\n    return result;\r\n};\r\n在云函数里使用，由于是 Node 8.9 或以上的环境，因此天然支持 Async/Await 诘法，但在小程端要使用的话，需要额外引入 Polyfill，比如这个开源的项目：regenerator开发者资源由于小程序·云开发是基于腾讯云的云开发开发的功能，因此在腾讯云与小程序两边都有不少的开发者资源，这里供大家参阅读：腾讯云开发者资源及文档腾讯云云开发平台官方 Github微信小程序·云开发文档"}
{"title": "微信小程序 - 选取搜索地点并且显示（map） ", "author": "Rolan", "time": "2018-9-21 00:38", "content": "演示如下，使用时，你也许会配合它：腾讯地图路线规划wxml:1 <view class='address' bindtap='onChangeAddress'>2   <input class='choose-address' placeholder='请选取地点' value='{{chooseAddress}}'></input>3  </view>wxss:1 .choose-address{2   border: 1px solid #000;3 }js 1 Page({ 2   data: { 3     4   }, 5   //移动选点 6   onChangeAddress: function() { 7     var _page = this; 8     wx.chooseLocation({ 9       success: function(res) {10         _page.setData({11           chooseAddress: res.name12         });13       },14       fail: function(err) {15         console.log(err)16       }17     });18   }19 });"}
{"title": "小程序入口构造工具&二维码测试工具 ", "author": "Rolan", "time": "2018-9-25 00:28", "content": "本文将介绍我们小程序中隐藏的两个工具页面。原理虽不复杂，收益却实实在在，或许也能给诸君带来启发。入口构造工具痛点PM&运营 投放链接 PM&运营每次投放新入口时，都需要找FE要页面链接。投放多少链接就要找FE多少次，一方面相互之间的沟通等待会耗掉不少时间，另一方面询问/回复过程会打断对方手头的工作，影响状态。 关键是大多时候这些链接只是需要改个渠道参数，并不涉及结构上的调整，完全可以由PM/运营自行修改。 然而要向所有PM&运营全面科普url构造规则，并没有想象中容易；各种链接构造需求就这样在无形中不断消耗双方的精力。FE&QA 开发/测试线下功能 开发/测试没有线上入口的新功能时，经常需要构造一个临时入口供以访问。 可以修改线下接口配置运营位作为访问入口，但是一则运营位有限，二则不能一站式操作；也可以修改代码加个临时入口，但是会污染代码，难保不会带到线上。 这样的情形反复出现也是挺麻烦的。idea开发一个专门的入口构造页面，直接提供给PM、运营、FE、QA等各方使用。需要什么链接需要什么入口，直接自助生成，无需一次次反复沟通/构造。效果通用入口构造： 如图所示，在入口构造页面中，用户可以直接输入FE提供的url模板并自助修改链接参数，从而获得所需链接。同时支持：直接打开该链接，进行查看、自测；生成以该链接作为落地链接的分享卡片，从而以落地页的形式打开查看；将该链接复制到剪贴板，供以投放；生成以该链接作为落地链接的二维码，供以投放。内嵌M页入口构造： 如图所示，内嵌M页的小程序链接构造同样支持类似功能。实现需求转译 将链接参数以普通用户能理解的形式展现出来，并允许其直接修改，再配以说明文案。以此抹平url构造规则造成的技术门槛。入口构造 页内入口 直接以按钮跳转实现，外部入口 以分享卡片进行模拟。链接输出 使用wx.setClipboardData接口经由剪贴板粘贴使用。初始入口 生成二维码作为入口构造页面自身的初始入口；将工具页面分享出去，保留分享卡片作为初始入口。意义效率入口构造工具使得PM、运营、FE、QA等各方可以自助、高效地构造所需链接/入口，有效节省了重复沟通成本，并在一定程度上提高了开发、测试、投放效率。质量入口构造工具提供的链接生成功能和预览功能可以在一定程度上避免/发现链接拼接失误等人工疏漏，提高整体交付质量。二维码测试工具痛点扫描二维码时会直接进入线上版小程序，导致在开发/测试阶段难以对二维码相关功能进行有效的检测和把控。 早期只能先冒险上线，然后进行线上验证，万一有问题再修复再重新上线，导致二维码相关功能调试效率低、上线风险高。 后来开发者工具支持通过二维码编译，管理后台也支持回滚，相对来说，二维码相关功能可控性强了很多；但是对于QA、PM、运营、第三方接入业务等小伙伴来说，二维码的检查、测试还是很无力。idea开发一个专门的二维码测试页面，支持在当前开发版/体验版/线上版小程序中对二维码进行查看和预览。效果如图所示，在二维码测试页面中，用户可以：直接查看二维码的编码信息，包括落地链接、参数等；在当前开发版/体验版/线上版小程序中打开二维码落地链接；生成与二维码拥有相同落地链接的当前开发版/体验版/线上版小程序的分享卡片。实现查看二维码信息 使用wx.scanCode接口可以读取二维码信息，包括落地页、参数等。在当前开发版/体验版/线上版中打开二维码 使用wx.scanCode接口获取落地链接，使用wx.navigateTo等接口在当前开发版/体验版/线上版小程序中打开目标页面。在当前开发版/体验版/线上版中以落地页的形式打开二维码 使用wx.scanCode接口获取落地链接，生成相同落地链接的分享卡片，访问分享卡片以模拟开发版/体验版下扫码打开小程序。意义效率 查看二维码信息可以有效提高相关功能调试效率； 直接在当前开发版/体验版中打开二维码可以有效提高相关功能测试效率，特别是对于QA等非前端人员。质量 二维码测试工具便于QA在稳定环境充分测试二维码相关功能，从而提高小程序交付质量。值得一提的是，这两个工具都是FE自发思考自发实现的，产出时小伙伴们表示“很惊喜”。 很多时候，主动去思考、发现、分析、解决痛点，能让你贡献出意料之外的价值，共勉。"}
{"title": "小程序·云开发的云函数路由高级玩法 ", "author": "Rolan", "time": "2018-9-25 00:38", "content": "李成熙，腾讯云高级工程师。2014年度毕业加入腾讯AlloyTeam，先后负责过QQ群、花样直播、腾讯文档等项目。2018年加入腾讯云云开发团队。专注于性能优化、工程化和小程序服务。微博 | 知乎 | Github概念回顾在掘金开发者大会上，在推荐实践那里，我有提到一种云函数的用法，我们可以将相同的一些操作，比如用户管理、支付逻辑，按照业务的相似性，归类到一个云函数里，这样比较方便管理、排查问题以及逻辑的共享。甚至如果你的小程序的后台逻辑不复杂，请求量不是特别大，完全可以在云函数里面做一个单一的微服务，根据路由来处理任务。用下面三幅图可以概括，我们来回顾一下：比如这里就是传统的云函数用法，一个云函数处理一个任务，高度解耦。第二幅架构图就是尝试将请求归类，一个云函数处理某一类的请求，比如有专门负责处理用户的，或者专门处理支付的云函数。最后一幅图显示这里只有一个云函数，云函数里有一个分派任务的路由管理，将不同的任务分配给不同的本地函数处理。tcb-router 介绍及用法为了方便大家试用，咱们腾讯云 Tencent Cloud Base 团队开发了 tcb-router，云函数路由管理库方便大家使用。那具体怎么使用 tcb-router 去实现上面提到的架构呢？下面我会逐一举例子。架构一：一个云函数处理一个任务这种架构下，其实不需要用到 tcb-router，像普通那样写好云函数，然后在小程序端调用就可以了。云函数// 函数 router\r\nexports.main = (event, context) => {\r\n    return {\r\n        code: 0,\r\n        message: 'success'\r\n    };\r\n}；小程序端wx.cloud.callFunction({\r\n      name: 'router',\r\n      data: {\r\n        name: 'tcb',\r\n        company: 'Tencent'\r\n      }\r\n    }).then((res) => {\r\n      console.log(res);\r\n    }).catch((e) => {\r\n      console.log(e);\r\n});架构二： 按请求给云函数归类此类架构就是将相似的请求归类到同一个云函数处理，比如可以分为用户管理、支付等等的云函数。云函数// 函数 user\r\nconst TcbRouter = require('tcb-router');\r\n\r\nexports.main = async (event, context) => {\r\n    const app = new TcbRouter({ event });\r\n    \r\n    app.router('register', async (ctx, next) => {\r\n        await next();\r\n    }, async (ctx, next) => {\r\n        await next();\r\n    }, async (ctx) => {\r\n        ctx.body = {\r\n            code: 0,\r\n            message: 'register success'\r\n        }\r\n    });\r\n\r\n    app.router('login', async (ctx, next) => {\r\n        await next();\r\n    }, async (ctx, next) => {\r\n        await next();\r\n    }, async (ctx) => {\r\n        ctx.body = {\r\n            code: 0,\r\n            message: 'login success'\r\n        }\r\n    });\r\n\r\n    return app.serve();\r\n}；\r\n\r\n// 函数 pay\r\nconst TcbRouter = require('tcb-router');\r\n\r\nexports.main = async (event, context) => {\r\n    const app = new TcbRouter({ event });\r\n    \r\n    app.router('makeOrder', async (ctx, next) => {\r\n        await next();\r\n    }, async (ctx, next) => {\r\n        await next();\r\n    }, async (ctx) => {\r\n        ctx.body = {\r\n            code: 0,\r\n            message: 'make order success'\r\n        }\r\n    });\r\n\r\n    app.router('pay', async (ctx, next) => {\r\n        await next();\r\n    }, async (ctx, next) => {\r\n        await next();\r\n    }, async (ctx) => {\r\n        ctx.body = {\r\n            code: 0,\r\n            message: 'pay success'\r\n        }\r\n    });\r\n\r\n    return app.serve();\r\n}；小程序端// 注册用户\r\nwx.cloud.callFunction({\r\n      name: 'user',\r\n      data: {\r\n        $url: 'register',\r\n        name: 'tcb',\r\n        password: '09876'\r\n      }\r\n    }).then((res) => {\r\n      console.log(res);\r\n    }).catch((e) => {\r\n      console.log(e);\r\n});\r\n\r\n// 下单商品\r\nwx.cloud.callFunction({\r\n      name: 'pay',\r\n      data: {\r\n        $url: 'makeOrder',\r\n        id: 'xxxx',\r\n        amount: '3'\r\n      }\r\n    }).then((res) => {\r\n      console.log(res);\r\n    }).catch((e) => {\r\n      console.log(e);\r\n});架构三： 由一个云函数处理所有服务云函数// 函数 router\r\nconst TcbRouter = require('tcb-router');\r\n\r\nexports.main = async (event, context) => {\r\n    const app = new TcbRouter({ event });\r\n    \r\n    app.router('user/register', async (ctx, next) => {\r\n        await next();\r\n    }, async (ctx, next) => {\r\n        await next();\r\n    }, async (ctx) => {\r\n        ctx.body = {\r\n            code: 0,\r\n            message: 'register success'\r\n        }\r\n    });\r\n\r\n    app.router('user/login', async (ctx, next) => {\r\n        await next();\r\n    }, async (ctx, next) => {\r\n        await next();\r\n    }, async (ctx) => {\r\n        ctx.body = {\r\n            code: 0,\r\n            message: 'login success'\r\n        }\r\n    });\r\n\r\n    app.router('pay/makeOrder', async (ctx, next) => {\r\n        await next();\r\n    }, async (ctx, next) => {\r\n        await next();\r\n    }, async (ctx) => {\r\n        ctx.body = {\r\n            code: 0,\r\n            message: 'make order success'\r\n        }\r\n    });\r\n\r\n    app.router('pay/pay', async (ctx, next) => {\r\n        await next();\r\n    }, async (ctx, next) => {\r\n        await next();\r\n    }, async (ctx) => {\r\n        ctx.body = {\r\n            code: 0,\r\n            message: 'pay success'\r\n        }\r\n    });\r\n\r\n    return app.serve();\r\n}；小程序端// 注册用户\r\nwx.cloud.callFunction({\r\n      name: 'router',\r\n      data: {\r\n        $url: 'user/register',\r\n        name: 'tcb',\r\n        password: '09876'\r\n      }\r\n    }).then((res) => {\r\n      console.log(res);\r\n    }).catch((e) => {\r\n      console.log(e);\r\n});\r\n\r\n// 下单商品\r\nwx.cloud.callFunction({\r\n      name: 'router',\r\n      data: {\r\n        $url: 'pay/makeOrder',\r\n        id: 'xxxx',\r\n        amount: '3'\r\n      }\r\n    }).then((res) => {\r\n      console.log(res);\r\n    }).catch((e) => {\r\n      console.log(e);\r\n});借鉴 Koa2 的中间件机制实现云函数的路由管理小程序·云开发的云函数目前更推荐 async/await 的玩法来处理异步操作，因此这里也参考了同样是基于 async/await 的 Koa2 的中间件实现机制。从上面的一些例子我们可以看出，主要是通过 use 和 router 两种方法传入路由以及相关处理的中间件。use 只能传入一个中间件，路由也只能是字符串，通常用于 use 一些所有路由都得使用的中间件// 不写路由表示该中间件应用于所有的路由\r\napp.use(async (ctx, next) => {\r\n\r\n});\r\n\r\napp.use('router', async (ctx, next) => {\r\n\r\n});router 可以传一个或多个中间件，路由也可以传入一个或者多个。app.router('router', async (ctx, next) => {\r\n\r\n});\r\n\r\napp.router(['router', 'timer'], async (ctx, next) => {\r\n    await next();\r\n}, async (ctx, next) => {\r\n    await next();\r\n}, async (ctx, next) => {\r\n\r\n});不过，无论是 use 还是 router，都只是将路由和中间件信息，通过 _addMiddleware 和 _addRoute 两个方法，录入到 _routerMiddlewares 该对象中，用于后续调用 serve 的时候，层层去执行中间件。最重要的运行中间件逻辑，则是在 serve 和 compose 两个方法里。serve 里主要的作用是做路由的匹配以及将中间件组合好之后，通过 compose 进行下一步的操作。比如以下这段节选的代码，其实是将匹配到的路由的中间件，以及 * 这个通配路由的中间件合并到一起，最后依次执行。let middlewares = (_routerMiddlewares[url]) ? _routerMiddlewares[url].middlewares : [];\r\n// put * path middlewares on the queue head\r\nif (_routerMiddlewares['*']) {\r\n    middlewares = [].concat(_routerMiddlewares['*'].middlewares, middlewares);\r\n}组合好中间件后，执行这一段，将中间件 compose 后并返回一个函数，传入上下文 this 后，最后将 this.body 的值 resolve，即一般在最后一个中间件里，通过对 ctx.body 的赋值，实现云函数的对小程序端的返回：const fn = compose(middlewares);\r\n\r\nreturn new Promise((resolve, reject) => {\r\n    fn(this).then((res) => {\r\n        resolve(this.body);\r\n    }).catch(reject);\r\n});那么 compose 是怎么组合好这些中间件的呢？这里截取部份代码进行分析function compose(middleware) {\r\n    /**\r\n     * ... 其它代码 \r\n     */\r\n    return function (context, next) {\r\n        // 这里的 next，如果是在主流程里，一般 next 都是空。\r\n        let index = -1;\r\n\r\n        // 在这里开始处理处理第一个中间件\r\n        return dispatch(0);\r\n\r\n        // dispatch 是核心的方法，通过不断地调用 dispatch 来处理所有的中间件\r\n        function dispatch(i) {\r\n            if (i <= index) {\r\n                return Promise.reject(new Error('next() called multiple times'));\r\n            }\r\n\r\n            index = i;\r\n\r\n            // 获取中间件函数\r\n            let handler = middleware[i];\r\n\r\n            // 处理完最后一个中间件，返回 Proimse.resolve\r\n            if (i === middleware.length) {\r\n                handler = next;\r\n            }\r\n\r\n            if (!handler) {\r\n                return Promise.resolve();\r\n            }\r\n\r\n            try {\r\n                // 在这里不断地调用 dispatch, 同时增加 i 的数值处理中间件\r\n                return Promise.resolve(handler(context, dispatch.bind(null, i + 1)));\r\n            }\r\n            catch (err) {\r\n                return Promise.reject(err);\r\n            }\r\n        }\r\n    }\r\n}看完这里的代码，其实有点疑惑，怎么通过 Promise.resolve(handler(xxxx)) 这样的代码逻辑可以推进中间件的调用呢？首先，我们知道，handler 其实就是一个 async function，next，就是 dispatch.bind(null, i + 1) 比如这个：async (ctx, next) => {\r\n    await next();\r\n}而我们知道，dispatch 是返回一个 Promise.resolve 或者一个 Promise.reject，因此在 async function 里执行 await next()，就相当于触发下一个中间件的调用。当 compose 完成后，还是会返回一个 function (context, next)，于是就走到下面这个逻辑，执行 fn 并传入上下文 this 后，再将在中间件中赋值的 this.body resolve 出来，最终就成为云函数数要返回的值。const fn = compose(middlewares);\r\n\r\nreturn new Promise((resolve, reject) => {\r\n    fn(this).then((res) => {\r\n        resolve(this.body);\r\n    }).catch(reject);\r\n});看到 Promise.resolve 一个 async function，许多人都会很困惑。其实撇除 next 这个往下调用中间件的逻辑，我们可以很好地将逻辑简化成下面这段示例：let a = async () => {\r\n    console.log(1);\r\n};\r\n\r\nlet b = async () => {\r\n    console.log(2);\r\n\r\n    return 3;\r\n};\r\n\r\n\r\nlet fn = async () => {\r\n    await a();\r\n    return b();\r\n};\r\n\r\nPromise.resolve(fn()).then((res) => {\r\n    console.log(res);\r\n});\r\n\r\n// 输出\r\n// 1\r\n// 2\r\n// 3"}
{"title": "微信小程序onLaunch异步，首页 onLoad 先执行 ? ", "author": "Rolan", "time": "2018-9-26 00:18", "content": "本来按照事件顺序，小程序初始化时触发App里的onLaunch，后面再执行页面Page里的onLoad，但是在onLaunch里请求获取是否有权限，等待返回值的时候Page里的onLoad事件就已经执行了。//app.js\r\nApp({\r\n  onLaunch: function () {\r\n    console.log('onLaunch');\r\n    wx.request({\r\n      url: 'test.php', //仅为示例，并非真实的接口地址\r\n      data: {\r\n      },\r\n      success: function(res) {\r\n        console.log('onLaunch-request-success');\r\n        // 将employId赋值给全局变量，提供给页面做判断\r\n        this.globalData.employId = res.employId;   \r\n      }\r\n    })\r\n  },\r\n  globalData: {\r\n    employId: ''\r\n  }\r\n})\r\n//index.js\r\n//获取应用实例\r\nconst app = getApp()\r\n\r\nPage({\r\n  data: {\r\n    albumDisabled: true,\r\n    bindDisabled: false\r\n  },\r\n  onLoad: function () {\r\n    console.log('onLoad');\r\n    console.log('onLoad app.globalData.employId = ' + app.globalData.employId);\r\n    //判断是用户是否绑定了\r\n    if (app.globalData.employId && app.globalData.employId != '') {\r\n      this.setData({\r\n        albumDisabled: false,\r\n        bindDisabled: true\r\n      });\r\n  }\r\n})\r\n控制台打印的结果是onLaunch\r\nonLoad\r\nonLoad app.globalData.employId = \r\nonLaunch-request-success\r\n要是能等完onLaunch请求完再执行Page的onLoad方法那该多好。这里采用的方法是定义一个回调函数。Page页面判断一下当前app.globalData.employId是否有值，如果没有（第一次）则定义定义一个app方法（回调函数）app.employIdCallback = employId => {...}。App页面在请求success后判断时候有Page页面定义的回调方法，如果有就执行该方法。因为回调函数是在Page里面定义的所以方法作用域this是指向Page页面。//app.js\r\nApp({\r\n  onLaunch: function () {\r\n    wx.request({\r\n      url: 'test.php', //仅为示例，并非真实的接口地址\r\n      data: {\r\n      },\r\n      success: function(res) {\r\n        this.globalData.employId = res.employId;\r\n        //由于这里是网络请求，可能会在 Page.onLoad 之后才返回\r\n        // 所以此处加入 callback 以防止这种情况\r\n        if (this.employIdCallback){\r\n           this.employIdCallback(res.employId);\r\n        }\r\n      }\r\n    })\r\n  },\r\n  globalData: {\r\n    employId: ''\r\n  }\r\n})\r\n//index.js\r\n//获取应用实例\r\nconst app = getApp()\r\n\r\nPage({\r\n  data: {\r\n    albumDisabled: true,\r\n    bindDisabled: false\r\n  },\r\n  onLoad: function () {\r\n    //判断是用户是否绑定了\r\n    if (app.globalData.employId && app.globalData.employId != '') {\r\n      this.setData({\r\n        albumDisabled: false,\r\n        bindDisabled: true\r\n      });\r\n    } else {\r\n      // 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回\r\n      // 所以此处加入 callback 以防止这种情况\r\n      app.employIdCallback = employId => {\r\n        if (employId != '') {\r\n          this.setData({\r\n            albumDisabled: false,\r\n            bindDisabled: true\r\n          });\r\n        }\r\n      }\r\n    }\r\n  }\r\n})\r\n这样的话，就能实现想要的结果。执行顺序就是：[App] onLaunch -> [Page] onLoad -> [App] onLaunch sucess callback"}
{"title": "微信小程序通过ip获取用户所在城市 ", "author": "Rolan", "time": "2018-9-26 00:37", "content": "在微信小程序中, 获取用户的地理位置是需要权限的, 如果只是获取用户所在的城市信息, 那只需查看用户ip所在的城市就好了, 下面我们就完成获取用户ip的小程序逻辑~根据用户ip获取地理位置根据用户ip获取用户地理位置, 用爬虫实现! 博主所用的api:\"http://www.ip138.com/ips138.asp?ip=\"+ ip_addr查询ip的函数import requestsfrom lxml import etree# 查询ip归属地def query_ip_attribution(ip_addr):    # 设置用户代理头    headers = {        # 设置用户代理头(为狼披上羊皮)        \"User-Agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36\",    }    target_url = \"http://www.ip138.com/ips138.asp?ip=\"+ ip_addr    response = requests.get(target_url, headers = headers).content    data_etree = etree.HTML(response)    ip_attr = data_etree.xpath('//tr[3]/td/ul/li[1]//text()')    ip_attr = ip_attr[0].strip(\"本站数据：\")    return {\"ip_attr\": ip_attr, \"ip\": ip_addr}nginx配置nginx负责将请求转发到django(django在9000端口开启了服务)proxy_set_header Host $http_host;proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;proxy_set_header X-Forwarded-Proto $scheme;Host包含客户端真实的域名和端口号； X-Real-IP表示客户端真实的IP； X-Forwarded-For这个Header和X-Real-IP类似，但它在多层代理时会包含真实客户端及中间每个代理服务器的IP。 X-Forwarded-Proto表示客户端真实的协议（http还是https）；Django读取用户ip, 查询并返回结果from django.http import JsonResponse# 获取用户ipdef get_ip(request):    if 'HTTP_X_FORWARDED_FOR' in request.META:        ip =  request.META['HTTP_X_FORWARDED_FOR']    else:        ip = request.META['REMOTE_ADDR']    return JsonResponse(query_ip_attribution(ip))微信小程序获取返回的数据可以作为开源接口调用 (支持http, https, 无需参数) 返回ip归属接口1: http://fangyuanxiaozhan.com/get_ip 返回ip归属接口2: https://fangyuanxiaozhan.com/get_ip小结:网页云音乐, 非常注重分析自己的用户, 并对用户的歌单进行个性化定制, 收获了大量好评, 对于个人开发者, 用复杂的算法分析用户, 不太现实,但通过分析用户所在城市, 对软件定位做一些优化, 还是很容易实现的。"}
{"title": "微信小程序 授权登录 41003 ", "author": "Rolan", "time": "2018-9-26 00:43", "content": "最近遇到这么个坑，偶然请求己方服务器授权登录失败，百度上一堆复制黏贴的文章并不靠谱，最终在微信论坛上看到解决方案。 网上有些是说iv内空格导致解密失败，我出错的情况下并没有出现空格，排除这种情况。 有说是因为请求顺序，但是按照微信官方文档，似乎并不是最新的，至少我授权方式不完全跟文档一样。我的授权方式 通过添加一个按钮并且设置 open-type=\"getUserInfo\"<button class='wxBtn'         open-type=\"getUserInfo\"         bindgetuserinfo=\"wechatAction\">使用微信账号登录</button>在按钮点击事件里，会返回一些授权登录需要用到的字段如：iv、encryptedData、signature、rawData 这个时候再调用 wx.login() 去获取code，整合以上数据向己方服务器发送请求获取用户唯一标识 token。 通过以上的方式是可以成功登录，但是偶然会出现请求己方服务器授权登录失败，再一次就会成功。 原因在于请求顺序，这里的请求顺序是先请求 wx.getUserInfo(按钮) 再请求 wx.login()。有时候获取code后iv已经失效，所以失败。 解决方案：在请求 wx.login() 后，调用一次 wx.getUserInfo(废弃接口) ，更新iv等信息。注意：这里调用的废弃接口只是不再弹出授权请求窗口，但还是能够获取到 iv 等信息，授权接口弹窗已将在点击按钮的时候弹出，并且授权了，所以没毛病。 再总结一下，正确的顺序：wx.getUserInfo(按钮) -> wx.login() -> wx.getUserInfo(废弃接口)，整合以上操作获取到的最近数据 code、iv、encryptedData、signature、rawData 传给己方服务器，授权登录成功。以下贴上我的业务代码  // 点击微信登录  wechatAction: function(e) {      // 用户点击授权    // 先保存获取到的微信用户信息    const { nickName, avatarUrl } = JSON.parse(e.detail.rawData)     this.setData({      nickName: nickName,      avatarUrl: avatarUrl    })    // 获取微信code    this.reqWechatCode()  },  // 微信登录：获取code  reqWechatCode: function() {    // 授权接口登录接口    let that = this     // 从微信获取code    wx.showLoading({      title: '获取code',    })    wx.login({      success: function (res) {         if (res.code) {          wx.getUserInfo({            success: function (res) {              // 保存微信登录参数              const { encryptedData, iv, signature, rawData } = res              that.setData({                encryptedData: encryptedData,                iv: iv,                signature: signature,                rawData: rawData              })               that.wxLoginReq(res.code)            }          })        } else {          wx.showToast({            title: '获取code失败,请重试',            icon: 'none'          })        }        wx.hideLoading()      }    })   },  // 根据获取到的code 向服务器发送登录请求 获取token  wxLoginReq: function (code) {    let that = this     wx.showLoading({      title: '获取token中',    })    // 拿到code 再加上 encryptedData, iv, rawData, signature 等参数，请求token    let encryptedData = that.data.encryptedData    let iv = that.data.iv    let signature = that.data.signature    let rawData = that.data.rawData    var req = require('../../util/Request.js')    // 请求成功    let success = function(res) {      // console.log(res)      wx.hideLoading()      // 缓存token      const { token, user_id } = res.data.data      let userInfo = {        token: token,        user_id: user_id,        nickName: that.data.nickName,        avatarUrl: that.data.avatarUrl      }      getApp().setUserInfo(userInfo)      // 同步用户信息       getApp().loginSuccess(function () {        wx.navigateBack({})      })    }    // 请求失败    let fail = function(res) {      wx.hideLoading()      wx.showToast({        title: '获取token失败,请重试',        icon: 'none'      })    }     // 登录请求    req.reqLogin(code, encryptedData, iv, rawData, signature, success, fail)   },"}
{"title": "小程序应用中WebView中原生组件限制问题解析 ", "author": "Rolan", "time": "2018-9-26 00:46", "content": "背景在微信的文档中有一个章节说明了『 原生组件的使用限制 』有这么一段话『由于原生组件脱离在 WebView 渲染流程外，因此在使用时有以下限制：原生组件的层级是最高的，所以页面中的其他组件无论设置 z-index 为多少，都无法盖在原生组件上。 后插入的原生组件可以覆盖之前的原生组件。 原生组件还无法在 scroll-view、swiper、picker-view、movable-view 中使用。 部分CSS样式无法应用于原生组件，例如： 无法对原生组件设置 CSS 动画 无法定义原生组件为 position: fixed 不能在父级节点使用 overflow: hidden 来裁剪原生组件的显示区域 原生组件的事件监听不能使用 bind:eventname 的写法，只支持 bindeventname。原生组件也不支持 catch 和 capture 的事件绑定方式 在iOS下，原生组件暂时不支持触摸相关事件。 在工具上，原生组件是用web组件模拟的，因此很多情况并不能很好的还原真机的表现，建议开发者在使用到原生组件时尽量在真机上进行调试。』解析所谓的原生组件，即非Web组件系统扩展Native组件。因为小程序在视图渲染层面使用了WebView，而在Video，Map这类组件，使用WebView的WebCore渲染之后体验不佳的诟病一直存在，而且标准不一。小程序上因使用原生的WebView进行渲染，而不是用修改的WebView内核（至少在iOS上没有这么干），而无法对web原生标签扩展。基于用户体验，和坑爹的技术限制，小程序提出了原生组件的概念，也就是在WebView上面使用原生组件填充占位元素的方式修补这类组件用户体验问题。因为WebView和原生组件在应用层本身就不是一个渲染层级，于是出现Web上面的标签无法浮于Video之上(直播应用的恶梦)，在不修改技术思路的前提下，position: fixed， overflow: hidden这样的属性是不可能用于原生组件的样式的。不过伪同层渲染也不是说不可能，即在渲染原生组件时候根据层级镂空面积。特别在Map上使用WebView作为渲染之后体验不佳的诟病一直存在，特别是地图上marker标记过多的重度场景下，笔者所在的公司的在使用高德地图Web端提供出来的C端具备反人类的体验，地图拖拉龟速，点击响应缓慢，加载loading地图区域等待时间过长。而Video则支持的格式有限，列出部分浏览器的支持的如下：Firefox：支持 Ogg Vorbis和WAV Opera ：支持Ogg Vorbis和WAV Safari ：支持MP3，AAC格式 ，和MP4 Chrome ：支持Ogg Vorbis，MP3，WAV，AAC和MP4 Internet Explorer 9+ ：支持MP3，AAC格式 ，和MP4 IOS ：支持MP3，AAC格式 ，和MP4 Android ：支持AAC和MP3 上述，可以知道视频支持有限（限于版权）。而就我们关注的移动端iOS和Andoroid，实现一个视频播放，我们可能都会有以下几点的需求：1、全屏处理； 2、覆盖层效果； 3、自动播放； 4、播放控制； 5、隐藏播放控件；在iOS上如果使用WebView，你无法修改全屏下的工具这一点体验已经足够让所有的产品经理抓狂，更不用说Android的这么多的机型。覆盖层效果在微信上不得不使用微信提供原生组件cover-view实现，而限于原生实现限制，cover-view的支持有限。设计方案1、组件层于WebView层之上 这也应该是微信小程序团队现阶段使用的方案，通过特殊的占位标签，使用getBoundingClientRect获取组件位置，而原生组件跟随Webview滚动。 Talking is cheap. Show me your code，那么用代码实现的效果的如下。now_lowest_gif.gif从图中可见，覆盖层确实位于原生组件之下。2、组件层于WebView层之下 此方式略微复杂。需要通过与Webview scroll联动的置于Webview之下的Component Layer实现，而Webview背景设置为透明。至于事件，通过Webview的事件透传，传递到Component Layer，需要通过缓存webview中元素再计算是否被点中通过重写hitTest方法实现。通过此技术方案实现的好处也是明显的，因为原生组件层很多时候都是置于最底层，而Web上的组件可以轻松覆盖于Native之上，无需使用cover-view之类的hack方法。 效果如下所示图片发自简书App Tips 在iOS上还特别需要注意一点UIWebview的坑。在使用-webkit-overflow-scrolling 使用，你会发现momentum scroll阶段并不会触发scroll事件，而且 scrollTop 属性不会变化，当然getBoundingClientRect也同样失效。如果考虑使用touchmove 这样事件你也仅仅在手指还在屏幕上的时候触发，检测滚动区域内部元素的getBoundingClientRect 同样无效。当然幸运的是，这么大一个坑只是发生在UIWebview，对WKWebview并没有影响。"}
{"title": "优化小程序自身的Storage ", "author": "Rolan", "time": "2018-9-27 00:16", "content": "1、小程序中的存储只有 Storage ，特性如下：上限为 10MB 以用户纬度隔离，同一个设备，A 无法访问 B 用户的数据。 持久缓存，只有在用户关掉小程序才会删除，如果空间不足，会进行 LRU ，也就是不经常使用的小程序的数据缓存区域会被全部清空。在体验版、开发版、和线上版都共用一套，并不会隔离。没有 Cookie2、因此我们要在 Storage 中隔离一个 Cookie ，用来模拟浏览器中的 Cookie ，解析接口返回的 Header，设置 Cookie，在发送接口请求前，自动带上 Cookie。从上面知道，storage 不会自动销毁，而是在小程序销毁的时候再销毁。我们先了解一下小程序的运行机制。小程序运行机制：小程序没有重启的概念 当小程序进入后台，客户端会维持一段时间的运行状态，超过一定时间后（目前是5分钟）会被微信主动销毁 置顶的小程序不会被微信主动销毁 当收到系统内存告警也会进行小程序的销毁代码实现：const storage = {   set(){}, //设置缓存   get(){}, //获取缓存   remove(){}, // 移除缓存   checkAndClearExpired(){}, //将过期缓存清理掉 　　isExpired() {} //判断是否过期}在 storage 中隔离一个字段，用来做 cookielet cookie = (function(){    return wx.getStorageSync('cookies');}())const Cooke = {  getCookie(){}, //从内存中获取cookie  setCookie(){}, // 设置cookie  setCookieInHeader(){}, //根据response的Header设置cookie  removeCookie() {},  //删除cookie  isExpired() {} //判断是否过期}在设置storage的时候，增加一个字段 expire 用来表示过期时间。简化代码如下：function isExpired (expires) {    // 小于等于现在时间为过期    if (new Date(expires) <= new Date()) {        return true;    }}这样子，整体的流程如下：到底了，不知道是不是越来越懒了，博文写得越来越短。。。"}
{"title": "利用云开发优化博客小程序（一）——浏览量统计 ", "author": "Rolan", "time": "2018-9-27 00:23", "content": "最近小程序云发开的开放让我又有了更新我的微信小程序版博客的动力。背景由于我的博客是基于开源博客框架ghost搭建的，虽然相较于wordpress轻量了很多，但在功能上远没有wordpress丰富，像基本的网站统计，文章统计，点评之类的通通没有。我的pc端博客是通过接入第三方组件来实现的，但小程序端一直无法实现「需要自己再搭建个服务端」。但有了云开发之后，这一切就变得有可能啦。想了解我的博客搭建和小程序版博客可以参考下面两篇文章：搭建Ghost 博客详细教程（总）微信小程序版博客——开发汇总总结（附源码）统计实现最想实现的还是统计功能啦，每篇文章的 浏览量 ， 点评数 ， 点赞数 之类的，这个应该是比较基本的。所以利用小程序云开发提供的数据库功能来存储这类数据，还是很方便可以实现该功能的。这里先简单说下浏览量的实现。首先需要改变下文件夹结构，因为会用到云函数的功能，所以我将云函数的文件夹和项目文件夹平级，同时小程序配置文件中新增 cloudfunctionRoot 节点，用于指向云函数文件夹，指定完之后文件夹的图标也会默认改变。创建集合接下来利用云开发的数据库创建一个集合，用于保存文章的统计数据，集合的字段如下：{\r\n    \"_id\": W5y6i7orBK9ufeyD //主键id\r\n    \"comment_count\": 0 //评论数\r\n    \"like_count\": 14 //点赞数\r\n    \"post_id\": 5b3de6b464546644ae0b7eb4 //文章id\r\n    \"view_count\": 113 //访问数\r\n}同时，最好加上索引，避免后续集合数据变多而影响查询效率，通常都是根据文章id进行查询：云函数编写集合创建完之后，需要编写云函数，用于操作数据库，当然你也可以直接在小程序端直接操作数据库。这里需要两个接口，一个用于查询文章数据，代码如下：// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init()\r\n\r\nconst db = cloud.database()\r\nconst _ = db.command\r\n\r\n// 根据文章Id集合批量查询统计数据\r\nexports.main = async (event, context) => {\r\n  try {\r\n    var result= await db.collection('posts_statistics').where({\r\n      post_id: _.in(event.post_ids)\r\n    }).get(); \r\n    return result.data \r\n  }\r\n  catch(e)\r\n  {\r\n    console.error(e)\r\n    return []\r\n  }\r\n}另一个用于新增或者更新文章统计数据,由于可能第一次访问，集合中不存在该文章ID的数据，所以加了一段默认新增的动作，代码如下：// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init()\r\n\r\nconst db = cloud.database()\r\n\r\n// 更新文章统计数据，没有则默认初始化一笔\r\nexports.main = async (event, context) => {\r\n  try {\r\n    var posts = await db.collection('posts_statistics').where({\r\n      post_id:event.post_id\r\n    }).get()\r\n\r\n    if (posts.data.length>0) {\r\n      await db.collection('posts_statistics').doc(posts.data[0]['_id']).update({\r\n        data: {\r\n          view_count: posts.data[0]['view_count'] + event.view_count ,//浏览量\r\n          comment_count: posts.data[0]['comment_count']+event.comment_count,//评论数\r\n          like_count: posts.data[0]['like_count'] + event.like_count//点赞数\r\n        }\r\n      })\r\n    }\r\n    else {\r\n      //默认初始化一笔数据\r\n      await db.collection('posts_statistics').add({\r\n        data: {\r\n          post_id: event.post_id,//文章id\r\n          view_count: 100 + Math.floor(Math.random() * 40),//浏览量\r\n          comment_count: 0,//评论数\r\n          like_count: 10 + Math.floor(Math.random() * 40)//点赞数\r\n        }\r\n      })\r\n    }\r\n    return true\r\n  } catch (e) {\r\n    console.error(e)\r\n    return false\r\n  }\r\n}小程序端接入数据库的操作编写完成之后，小程序端就可以接入了，在列表页增加对应的UI及样式：对应的代码也比较简单，在获取到文章信息之后，再调用下查询的云函数，获取到对应文章的统计数据渲染到页面，核心代码如下：//wxml部分\r\n<view class=\"icon-review\">\r\n  <view class=\"zan-icon zan-icon-browsing-history zan-pull-left zan-font-12 \"></view>\r\n  <view class=\"zan-pull-left zan-font-12\">\r\n    <text>{{item.view_count}}</text>\r\n  </view>\r\n</view>\r\n<view class=\"icon-comment\">\r\n  <view class=\"zan-icon zan-icon-records zan-pull-left zan-font-12 \"></view>\r\n  <view class=\"zan-pull-left zan-font-12\">\r\n    <text>{{item.comment_count}}</text>\r\n  </view>\r\n</view>\r\n<view class=\"icon-like\">\r\n  <view class=\"zan-icon zan-icon-like zan-pull-left zan-font-12 \"></view>\r\n  <view class=\"zan-pull-left zan-font-12\">\r\n    <text>{{item.like_count}}</text>\r\n  </view>\r\n</view>\r\n\r\n//js部分-详情页onLoad时\r\n//浏览数+1不需要知道调用结果，失败了不影响\r\nwx.cloud.callFunction({\r\n  name: 'upsert_posts_statistics',\r\n  data: {\r\n    post_id:blogId,\r\n    view_count:1,\r\n    comment_count:0,\r\n    like_count:0\r\n  }\r\n})\r\n\r\n//js部分-展示统计数据时\r\nwx.cloud.callFunction({\r\n  name: 'get_posts_statistics',\r\n  data: {\r\n    post_ids: postIds\r\n  }\r\n}).then(res => {\r\n  //访问数\r\n  post.view_count = res.result[0].view_count;\r\n  //点评数\r\n  post.comment_count = res.result[0].comment_count;\r\n  //点赞数\r\n  post.like_count = res.result[0].like_count;\r\n\r\n  this.setData({\r\n    post: post\r\n  });到这里，文章浏览量的统计接入基本就完成啦。总结目前还在开发评论功能，同时在开发的时候发现第一版的代码写的还是挺乱的，在开发新功能的同时也准备重构一下，有兴趣的小伙伴可以参考一下。"}
{"title": "微信小程序-canvas绘制文字实现自动换行 ", "author": "Rolan", "time": "2018-9-27 00:32", "content": "在使用微信小程序canvas绘制文字时，时常会遇到这样的问题：因为canvasContext.fillText参数为我们只能设置文本的最大宽度，这就产生一定的了问题。如果我们绘制的文本长度不确定或者我们希望文本超出自动换行或者用省略号表示，光靠这个API是无法完成的。下面本人就讲下我在开发中是如何解决这个问题的。1 wxml代码。<canvas canvas-id=\"myCanvas\" style=\"border: 1px solid;\"/>12 wxss代码canvas {  width: 99%;  height: 600rpx;}12343 js代码Page({  data: {  },  onLoad: function (options) {    const context = wx.createCanvasContext('myCanvas')    var text = '这是一段文字用于文本自动换行文本长度自行设置欢迎大家指出缺陷';//这是要绘制的文本    var chr =text.split(\"\");//这个方法是将一个字符串分割成字符串数组    var temp = \"\";    var row = [];    context.setFontSize(18)    context.setFillStyle(\"#000\")    for (var a = 0; a < chr.length; a++) {      if (context.measureText(temp).width < 250) {        temp += chr[a];      }      else {        a--; //这里添加了a-- 是为了防止字符丢失，效果图中有对比        row.push(temp);        temp = \"\";      }    }    row.push(temp);     //如果数组长度大于2 则截取前两个    if (row.length > 2) {      var rowCut = row.slice(0, 2);      var rowPart = rowCut[1];      var test = \"\";      var empty = [];      for (var a = 0; a < rowPart.length; a++) {        if (context.measureText(test).width < 220) {          test += rowPart[a];        }        else {          break;        }      }      empty.push(test);      var group = empty[0] + \"...\"//这里只显示两行，超出的用...表示      rowCut.splice(1, 1, group);      row = rowCut;    }    for (var b = 0; b < row.length; b++) {      context.fillText(row[b], 10, 30 + b * 30, 300);    }    context.draw()      } })123456789101112131415161718192021222324252627282930313233343536373839404142434445464748494 效果展示添加了a- -和没有a- -的对比以上就是换行的方法，如果想设置为不换行超出用省略号显示，也可参照上面的方法，将数组截取为一行再设置，道理是一样的。本文来自 优雅的勒布朗 的CSDN 博客 ，全文地址请点击：https://blog.csdn.net/weixin_41941325/article/details/80274969?utm_source=copy"}
{"title": "微信小程序 短信验证码登录 倒计时 setInterval ", "author": "Rolan", "time": "2018-9-14 00:19", "content": "需求：输入手机号 -> 点击获取验证码 -> 进入60s倒计时 短信验证码登录  data: {     seconds: 0, // 读秒    timer: '' // 计时器  },       let that = this      // 开始倒计时      that.setData({         seconds: 60,        timer: setInterval(function(){          let seconds = that.data.seconds          that.setData({ seconds: seconds - 1 })          if (that.data.seconds == 0) {            // 读秒结束 清空计时器            clearInterval(that.data.timer)          }        }, 1000)      })"}
{"title": "微信小程序云开发初体验 ", "author": "Rolan", "time": "2018-9-14 00:22", "content": "9.10号微信重磅推出小程序云开发功能，该功能方便了很多逻辑上的问题，至于安全嘛，腾讯的，如果腾讯不看你的，没人看得到，话不多说，跟着腾讯文档进行第一个demo 首先要升级一个开发者工具版本，更新到最新，下载地址：https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html1、下载到最新的工具之后打开，先创建一个存储我们自己云函数的文件夹命名：functions2、找到project.config.json文件，添加 \"cloudfunctionRoot\": \"functions/\" 配置我们的云函数目录{    \"description\": \"项目配置文件。\",    \"cloudfunctionRoot\": \"functions/\",    \"setting\": {        \"urlCheck\": true,        \"es6\": true,        \"postcss\": true,        \"minified\": true,        \"newFeature\": true    },    \"compileType\": \"miniprogram\",    \"libVersion\": \"2.1.3\",    \"appid\": \"asdaaaaaa\",    \"projectname\": \"\",    \"condition\": {        \"search\": {            \"current\": -1,            \"list\": []        },        \"conversation\": {            \"current\": -1,            \"list\": []        },        \"plugin\": {            \"current\": -1,            \"list\": []        },        \"game\": {            \"current\": -1,            \"list\": []        },        \"miniprogram\": {            \"current\": -1,            \"list\": []        }    }}3、发现云函数的目录是不是别具一格，是的话就右键选择：新建node.js云函数，这时候系统会配置一个基础版的云函数给我们，我们就拿这个基础的云函数走一个流程// 云函数入口文件const cloud = require('wx-server-sdk')cloud.init() //初始化，小程序调用函数前必须要要先调用初始化// 云函数入口函数exports.main = async (event, context) => {  return {    sum: event.a + event.b,//event里面放的都是一些用户传递过来的数据，参数a和参数b    userInfo: event.userInfo //还可以直接获取到用户的openid，这些是腾讯给出来的，并不需要用户去授权，很安全。  }}4、在我们的functions目录中，右键我们的add，选择：上传并部署，然后就开始调用： wx.cloud.callFunction({    name: 'add',    data: {      a: 1,      b: 9    }  }).then((res)=>{    console.log(res)  })5、是不是很激动，如果按照官方给出的文档，可能会遇到下面几个问题：问题①：Cannot read property 'callFunction' of undefined; 遇到该问题很好解决，这个问题一般都是调试基础库版本太低的原因，可以往上调一下。 问题②：发现版本库调高了之后发现了另外一个问题，errCode: -1  | errMsg: Cloud API isn't enabled, please call wx.cloud.init first请先调用 wx.cloud.init() 完成初始化后再调用其他云 API。init 方法可传入一个对象用于设置默认配置，详见文档。;at pages/test/test page getData functionError: errCode: -1  | errMsg: Cloud API isn't enabled, please call wx.cloud.init first请先调用 wx.cloud.init() 完成初始化后再调用其他云 API。init 方法可传入一个对象用于设置默认配置，详见文档。这个问题，就是调用云函数之前需要先进行初始化。wx.cloud.init()就可以了。再去调用云函数。成功获取返回来的数据。官方提供的一个最初的简单小demo就算走通了，剩下的基本上都是此类操作，只是需要对照官方数据库操作进行特别的操作。"}
{"title": "微信小程序之callout自定义气泡 ", "author": "Rolan", "time": "2018-9-14 10:46", "content": "最近闲着踩踩地图的坑一脚下去差点没从坑里爬起来，然后由于某个原因，去研究了 微信小程序里面地图 callout 这个属性callout呢，是在标记的点上面显示 一个 气泡，作为提示用最后展示下 效果  可以展示 顶部气泡以及监听被点击 废话不多说，直接上代码wxml[AppleScript] 纯文本查看 复制代码?1234<map id=\"map\"  scale=\"{{scale}}\" bindcontroltap=\"controltap\" markers=\"{{markers}}\" bindmarkertap=\"markertap\"latitude=\"{{latitude}}\" bindcallouttap = \"bindcallouttap\"longitude =\"{{longitude}}\"controls=\"{{controls}}\" show-location bindregionchange=\"regionchange\" style=\"width: 100%; height: {{view.Height}}px;\"></map>js[AppleScript] 纯文本查看 复制代码?001002003004005006007008009010011012013014015016017018019020021022023024025026027028029030031032033034035036037038039040041042043044045046047048049050051052053054055056057058059060061062063064065066067068069070071072073074075076077078079080081082083084085086087088089090091092093094095096097098099100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147var app = getApp(); Page({  data: {    url: '',[color=#0800][backcolor=rgb(255, 255, 254)][font=Consolas]//测试的时候把下面listData换成身边的点就行[/font][/backcolor][/color]    listData: [{      \"id\": 1,      \"placeName\": \"测试地址1\",      \"placeImageUrl\": \"\",      \"placeOpenTime\": 1506200400,      \"placeCloseTime\": 1506265200,      \"placeAddress\": \"测试地址1啊\",      \"placeLongitude\": \"114.08190678985596\",      \"placeLatitude\": \"22.544808209639864\"    }, {      \"id\": 2,      \"placeName\": \"测试地址2\",      \"placeImageUrl\": \"\",      \"placeOpenTime\": 1506200400,      \"placeCloseTime\": 1506265200,      \"placeAddress\": \"测试地址2啊\",      \"placeLongitude\": \"114.0938372555542\",      \"placeLatitude\": \"22.53953655390022\"    }, {      \"id\": 3,      \"placeName\": \"测试地址3\",      \"placeImageUrl\": \"\",      \"placeOpenTime\": 1506243600,      \"placeCloseTime\": 1506265200,      \"placeAddress\": \"测试地址3啊\",      \"placeLongitude\": \"114.05454\",      \"placeLatitude\": \"22.52291\"    }],    scale: '15',    Height: '0',    controls: '40',    latitude: '',    longitude: '',    markers: [],  },  onReady: function(e) {    // 使用 wx.createMapContext 获取 map 上下文     this.mapCtx = wx.createMapContext('myMap')  },  onLoad: function() {    var that = this;    that.setData({      url: app.globalData.url    })     // var data = JSON.stringify({    //   page: 1,    //   pageSize: 10,    //   request: {    //     placeLongitude: app.globalData.longitude,    //     placeLatitude: app.globalData.latitude,    //     userId: app.globalData.userId    //   }    // })     wx.getLocation({      type: 'gcj02', //返回可以用于wx.openLocation的经纬度      success: (res) => {        console.log(res);        that.setData({          markers: that.getSchoolMarkers(),          scale: 12,          longitude: res.longitude,          latitude: res.latitude        })      }    });     wx.getSystemInfo({      success: function(res) {        //设置map高度，根据当前设备宽高满屏显示        that.setData({          view: {            Height: res.windowHeight          }        })      }    })  },  bindcallouttap: function(e) {    console.log(\"头上文字被点击\", e)  },  markertap: function(e) {    console.log(\"定位的点被点击\", e)  },  controltap: function(e) {    console.log(\"111\")    this.moveToLocation()  },  getSchoolMarkers() {     var market = [];     for (let item of this.data.listData) {       let marker1 = this.createMarker(item);       market.push(marker1)    }    console.log(\"market===========\", market)    return market;  },  moveToLocation: function() {    this.mapCtx.moveToLocation()  },  strSub: function(a) {    var str = a.split(\".\")[1];    str = str.substring(0, str.length - 1)    return a.split(\".\")[0] + '.' + str;  },  createMarker(point) {     let latitude = this.strSub(point.placeLatitude);    let longitude = point.placeLongitude;    let marker = {      iconPath: \"../images/here.png\",      id: point.id || 0,      name: point.placeName || '',      title: point.placeName || '',      latitude: latitude,      longitude: longitude,      label: {        x: -24,        y: -26,        content: point.placeName      },      width: 50,      height: 50,      callout: {        content: point.placeName || '',        fontSize: 14,        bgColor: \"#FFF\",        borderWidth: 1,        borderColor: \"#CCC\",        padding: 4,        display: \"ALWAYS\",        textAlign: \"center\"      }    };    return marker;  }})wxss[AppleScript] 纯文本查看 复制代码?123456789.map_container{    height: 300px;     width: 100%; }  .map {    height: 100%;     width: 100%; }\r\ntip：\r\n1、如有遇到新问题，可以在下方留言（回的比较慢）或者加QQ群437729329 进行咨询\r\n\r\n\r\nmap.rar"}
{"title": "Taro下利用Decorator快速实现小程序分享 ", "author": "Rolan", "time": "2018-9-17 00:06", "content": "在Page的 onLoad 里面定义 wx.showShareMenu() 显示当前页面的转发按钮使用 button 的 open-type=share 让用户点击按钮触发转发如果需要对当前页面转发进行自定义编辑，则需要再当前页面 Page 中定义 onShareAppMessage 事件处理函数，自定义该页面的转发内容。官方相关文档转发 · 小程序痛点使用原生微信转发主要有以下痛点:wx.showShareMenu()\r\nformat\r\n举个例子在每次分享的卡片的链接上，都需要带上当前分享用户的 userId ，方便日后对于用户拉新分析，助力，团购等行为进行处理，这个时候就需要对分享卡片的路径进行一次处理解决方式利用 Decorator 以及React的高阶组件 HOC ，在 willMount 的时候往页面注入 wx.showShareMenu() ，然后可通过参数或者在当前页面触发响应的设置函数进行相应的分享配置设置代码分享分享修饰器withShare.jsimport Taro from '@tarojs/taro';\r\nimport { connect } from '@tarojs/redux';\r\nimport defaultShareImg from 'xxx.jpg';\r\n\r\nfunction withShare(opts = {}) {\r\n  \r\n  // 设置默认\r\n  const defalutPath = 'pages/index/index?';\r\n  const defalutTitle = '默认标题';\r\n  const defaultImageUrl = defaultShareImg;\r\n\r\n  return function demoComponent(Component) {      \r\n    // redux里面的用户数据\r\n    @connect(({ user }) => ({\r\n      userInfo: user.userInfo\r\n    }))\r\n    class WithShare extends Component {\r\n      async componentWillMount() {\r\n        wx.showShareMenu({\r\n          withShareTicket: true\r\n        });\r\n\r\n        if (super.componentWillMount) {\r\n          super.componentWillMount();\r\n        }\r\n      }\r\n\r\n      // 点击分享的那一刻会进行调用\r\n      onShareAppMessage() {\r\n        const { userInfo } = this.props;\r\n\r\n        let { title, imageUrl, path = null } = opts;\r\n\t\t\r\n        // 从继承的组件获取配置\r\n        if (this.$setSharePath && typeof this.$setSharePath === 'function') {\r\n          path = this.$setSharePath();\r\n        }\r\n\t\t\r\n        // 从继承的组件获取配置\r\n        if (this.$setShareTitle && typeof this.$setShareTitle === 'function') {\r\n          title = this.$setShareTitle();\r\n        }\r\n\r\n        // 从继承的组件获取配置\r\n        if (\r\n          this.$setShareImageUrl &&\r\n          typeof this.$setShareImageUrl === 'function'\r\n        ) {\r\n          imageUrl = this.$setShareImageUrl();\r\n        }\r\n\r\n        if (!path) {\r\n          path = defalutPath;\r\n        }\r\n\t\t\r\n        // 每条分享都补充用户的分享id\r\n        // 如果path不带参数，分享出去后解析的params里面会带一个{''： ''}\r\n        const sharePath = `${path}&shareFromUser=${userInfo.shareId}`; \r\n\r\n        return {\r\n          title: title || defalutTitle,\r\n          path: sharePath,\r\n          imageUrl: imageUrl || defaultImageUrl\r\n        };\r\n      }\r\n\r\n      render() {\r\n        return super.render();\r\n      }\r\n    }\r\n\r\n    return WithShare;\r\n  };\r\n}\r\n\r\nexport default withShare;\r\n\r\n复制代码使用的页面pages/xxx/xxx.jsimport Taro, { Component } from '@tarojs/taro';\r\nimport { connect } from '@tarojs/redux';\r\nimport { View } from '@tarojs/components';\r\nimport withShare from './withShare';\r\n\r\n@withShare({\r\n    title: '可设置分享标题', \r\n    imageUrl: '可设置分享图片路径', \r\n    path: '可设置分享路径'\r\n})\r\nclass Index extends Component {\r\n  \r\n  // $setSharePath = () => '可设置分享路径(优先级最高)'\r\n\r\n  // $setShareTitle = () => '可设置分享标题(优先级最高)'\r\n\r\n  // $setShareImageUrl = () => '可设置分享图片路径(优先级最高)'\r\n  \r\n  render() {\r\n     return <View />\r\n  }\r\n}\r\n复制代码由于是继承传入的组件，所以获取分享配置除了可以从函数的参数获取，还可以通过定义的一些方法，通过继承的组件获取到继承的参数，这样可以再某些业务场景下，根据需要动态生成分享参数配置，例如代码里面的 this.$setSharePath() 等就是从父级组件动态获取到分享的参数"}
{"title": "玩Android微信小程序版 ", "author": "Rolan", "time": "2018-9-17 00:12", "content": "最近开始针对项目性全面学习了一点js，和同事一起用MUI写了个项目，就敢拿出来献丑，我也是diaodiao的。经过几十个工时业余时间*（最近两周有点忙，周期拖得有点长，本来计划五一之前发出来的） ，在 仿知乎微信小程序demo 基础上，结合玩Android开源API，完成了玩Android小程序版的初版 （和群里基佬们做得比感觉做的太简单了，大家就当练练手）*，扫码或者关注微信公众号 Android精推 即可体验：本项目主要包含以下几大模块：首页项目体系我的登录先上预览图：首页：项目：体系：我的：为什么要写这个？学了点js就飘了，群里大佬们写的都是Android版本的，微信小程序大家似乎都有接触但是可能都觉得比较简单，也是为了便于手持iPhone的基佬们随时点赞刷玩Android。说几点：1. 微信小程序开发入门注意事项这里就不赘述太多，看我基友 阿汤哥 的一篇文章小程序基本介绍就差不多了。简单归简单，不过微信小程序在开发过程中坑还是很多的，我也是边学边百度，我这个人踩坑踩惯了，建议大家初学的时候，找个优质一点的demo照葫芦画瓢，学着写很容易上手。2. 未实现的功能首页文章列表搜索*（计划V1.1实现）*收藏列表*（计划V1.1实现）*查看文章详情等需要跳转h5页面的功能*（计划搞到企业账号实现）*收藏项目等*（目前已实现收藏文章）*剩下的你们提，我做不出来*（或者没时间）*你们fork去3. 微信小程序代码写法的一些特点工具类等输出对公共方法写方法体还是一样function formatNumber(n) {\r\n   n = n.toString()\r\n   return n[1] ? n : '0' + n\r\n}\r\n复制代码或者function getData(url) {\r\n     XXXXXX\r\n}\r\n复制代码都和我们原生js写法、jquery等几乎一致，然鹅要注意一点就是如果该方法需要外部调用，需要多加一个：module.exports = {\r\n   formatTime: formatTime\r\n};\r\n复制代码在文件里加上这个，或者也可以写成：module.exports.getData = getData;\r\n复制代码####js页面数据刷新html（wxml） 微信小程序绑定js数据不像angular那样，在每个页面的js文件中，都有个类似oncreat的方法，即Page() 函数，它是用来注册一个页面。接受一个 object 参数，其指定页面的初始数据、生命周期函数、事件处理函数等这里每个页面的WXML 中的动态数据均来自对应 Page 的 data。给页面初始赋值可以在data里面直接放置：data: {\r\n      motto: 'Hello World',\r\n      userInfo: {},\r\n      wanUserName: '登录玩Android账户',\r\n   }\r\n复制代码而我们经过数据处理以后，需要实时更新页面则可以直接调用：//更新数据\r\n         that.setData({\r\n            userInfo: userInfo\r\n         })\r\n复制代码对，就是键值对的方式，和data一样。这里需要注意的是 that 这个，我们一般会在方法体内部先var一个参数that去获取全局实例 this ，这样避免方法自己的实例取代了页面的全局实例。this代表着当前对象，会随着程序的执行过程中的上下文改变，例如在wx.request({});方法的回调函数中，对象已经发生改变，所以已经不是wx.request({});方法对象了，data属性也不存在了。页面销毁与返回那么在微信小程序里我们怎么管理页面呢。微信小程序固然没有AMS这些东西，那么我们可以判断page来管理：// 返回上个页面\r\n         setTimeout(function () {\r\n            wx.navigateBack({\r\n               delta: 1\r\n            })\r\n         }, 1500);\r\n复制代码这里我设置了一个延迟，核心的代码是wx.navigateBack(),这里面的参数delta指的是退回页面的层数，比如我这里是返回上一页，那么值就是1，以此类推。。。但是我们一般返回上个页面的时候也会带一定的参数，这里就有三种*（可能更多） 介绍给大家： 1、利用本地存储 （类似Android的sp）*方式存储起来，这里去看看官方文档很简单，都是wx.XXX的。 2、利用生命周期传递，例如：var pages = getCurrentPages();\r\nvar currPage = pages[pages.length - 1];   //当前页面\r\nvar prevPage = pages[pages.length - 2];  //上一个页面\r\n//直接调用上一个页面的setData()方法，把数据存到上一个页面中去\r\nprevPage.setData({\r\n  mydata: {a:1, b:2}\r\n})\r\n复制代码这里是在简书的 微信小程序从子页面退回父页面时的数据传递 学习到的。这种方式在逻辑上要清晰得多，也不存在对数据的销毁有额外的管理工作，看起来十分优雅，从一定的角度说类似于Android的ActivityForResult方式。当然有利也是有弊的，比如使用这个页面的有多个入口，这样做很可能会导致获取到的页面实例不正确。当然如果对于逻辑层次简单的、耦合少的页面还是比较方便的。3、使用fire传递，这个方式是类似于我们EventBus的方式，后面有详解。利用第三方工具fire实现类似EventBus全局事件通知之前说到，fire是一个非常轻量级的第三方的组件库，在微信小程序限制项目大小2MB的情况下，在js调用中可以实现类似EventBus的全局事件订阅管理，非常简单好用。 1、首先，导fire文件，这个去网上下载一个*（不到1KB）*就可以，直接把onfire.js文件拷过来。 2、写订阅事件和接受者的时候：A 页面先订阅一个事件，并定义处理方法；从 B 页面返回时，发送消息；A 页面卸载时，解除订阅。是不是一毛一样的？不仅仅在微信小程序中，包括vue、React等都可以使用，具体使用*（无非是一行代码发送消息，接收消息的时候写一个方法）*可以去自行百度。列表单个Item点击控件冲突焦点冲突什么的在Android里面问题多多，在这里就要简单太多了。之前我曾尝试使用Android的方式去做，发现总是碰壁。无奈又要求助一波百度*（文档看的太少）*。在点击事件的时候，我们一般是给被点击View添加一个bindtap方法，后面写上方法名即可：bindtap=\"bindItemTap\"\r\n复制代码而如果这个View里面包含了其他的子View需要添加点击事件的时候，我们需要使用另一种写法了：catchtap=\"clickCollect\"\r\n复制代码这里的点击事件也很有趣，包括手指的手势都有涉及，包括手指点下去的时候、抬起来的时候、移动的时候等等，和Android的ACTION_DOWN及 ACTION_UP等异曲同工。####URL的限制， 不论什么请求必须Https 微信小程序对于网络请求有一定的限制，比如我们的玩Android是仅支持http的，但是微信是要求必须使用https请求才被许可，这也简单。我采用的方法是利用第三方搭建的网站进行url桥接。把网络管理类里面的baseUrl前面加上 wxapi.hotapp.cn/proxy/ ，然后拼上你在网站申请的key*（可以写死）*，然后拼上你http协议的url即可。提到微信的url限制，不得不说微信目前限制个人开发者和海外开发者使用webview打开第三方h5页面。所以，咱们在预览的时候只能用编译器去预览，想看具体的文章目前还是有限制的，我就不求赞助申请企业认证了。当然也欢迎有企业账户的基佬把代码fork过去给大家提供个福利*（别犯法哦）*。其他的就不多赘述了再一次感谢您花费时间看我啰嗦了这么久，觉得还不错可以 star star star 一波。微信小程序我并不打算深耕太多，后面会把重心转移到其他技术方面。如果您对本项目有什么想法欢迎 去提issue ，有兴趣可以自己参与进来迭代维护。祝您生活愉快！作者@samhaus2018 年 05月 01日"}
{"title": "微信小程序的手机通讯录点击本页面跳转位置的代码详解 ", "author": "Rolan", "time": "2018-9-17 00:15", "content": "最近开始做小程序，通读一遍文档再上手并不算难，但不得不说小程序里还是有一些坑。这里说一下如何实现页面锚点跳转，一个城市列表的效果示意图如下：因为在微信小程序的环境中不能想在浏览器里设置标签，或者操作dom滚动，传统做法就行不通了，一切都得按小程序的文档来。一开始我们的做法是使用boundingClientRect()方法获取每个锚点的坐标，然后再用wx.pageScrollTo()方法滑动过去。结果发现效果不是很好，因为boundingClientRect方法返回的每个点的坐标会随着屏幕滑动而变化，可能还会引起页面抖动，最后还是选择scroll-view(可滚动视图区域)组件来实现锚点效果。具体实现具体API就不赘述了，可以去看官方文档，这里讲几个需要注意的地方，下面是一个示意的scroll-view组件代码，上面的几个属性是必须的：复制代码代码如下:scroll-into-view：这个绑定了一个属性，它的值应该是页面元素的id，设置它的值就可以跳转到ID对应的元素那里了。scroll-y：添加这个属性标明是竖向滑动的，对应的scroll-x则表示横向滑动，竖向滑动时scroll-view必须设置一个固定的heightbindscroll：监听滑动，传给他一个事件，滑动时执行该事件文档上给的属性特别多，暂时只需要上述几个就可实现我们想要的效果。实现原理也很简单，内容部分，每个英文简写的view设置一个id，然后在导航list那里点击时，就把scroll-into-view的值设置成点击的那个id即可实现跳转。再说一下scroll-view的高度问题，这个一定要做适配的固定高度，不然在不同屏幕大小的手机上的显示效果有差异。获取屏幕大小的代码：height是个变量，获取到的高度付给他，并反馈到页面  onLoad: function (options) {\r\n\r\n    var that = this\r\n    // 获取系统信息\r\n    wx.getSystemInfo({\r\n      success: function (res) {\r\n        // 计算主体部分高度,单位为px\r\n        that.setData({\r\n          height: res.windowHeight\r\n        })\r\n      }\r\n    })\r\n  },几点优化到这里功能基本都实现了，但后面还发现一些问题：如果要隐藏scroll-view的滚动条，需要设置css样式:::-webkit-scrollbar\r\n::-webkit-scrollbar {\r\n width: 0;\r\n height: 0;\r\n color: transparent;\r\n}还有就是点了一个锚点实现了跳转，这个时候你滚动页面再点之前点的锚点，页面就不会再跳转了，这个时候就需要监听滚动事件，滚动时将scroll-into-view属性的值清空。或者在每次锚点跳转后，再由一个异步操作将scroll-into-view属性的值清空。scroll-view默认是无滑动动画的，需要滚动的动画效果需要在组件上设置：scroll-with-animation='true' 关于固定高度height的设置问题，一开始我以为这个高度和滚动元素的数目/高度有关，这个时候处理动态变化的列表就很麻烦。后面在网上看到的一个方法就是使用wx.getSystemInfo方法得到windowHeight，把这个设置为scroll-view的高度(单位为px)即可。自己的测试代码wxml代码：\r\n\r\n  \r\n  \r\n    \r\n      \r\n        {{item.name}}\r\n      \r\n     \r\n  \r\n   \r\n    \r\n      \r\n      {{item.name}} \r\n    \r\n  \r\n  \r\n\r\n  \r\n    \r\n    {{item}}\r\n    \r\n  \r\nwxss代码：/* 汽车图片 */\r\n.tupian{\r\n  width: 100rpx;\r\n  height: 100rpx;\r\n  display:inline-block;\r\n  vertical-align:middle;\r\n  margin-left: 10rpx;\r\n}\r\n/* 汽车外框 */\r\n.carFrame,.biaotou{\r\n  font-size: 30rpx;\r\n  width: 100%;\r\n  height: 100rpx;\r\n  line-height: 50rpx;\r\n  border-bottom: 1rpx solid #F4F4F8;\r\n  display:inline-block;\r\n}\r\n/* 文本文字 */\r\n.carText{\r\n  font-size: 28rpx;\r\n  margin-left: 50rpx;\r\n  display:inline-block;\r\n  vertical-align:middle;\r\n}\r\n/* 字母属性 */\r\n.zimu{\r\n  height: 50rpx;\r\n  border-bottom: 1rpx solid #F4F4F8;\r\n  font-size: 29rpx;\r\n  color: #777777;\r\n}\r\n/* 字母位置 */\r\n.weizhi{\r\n  margin:10rpx 0 0 18rpx;\r\n}\r\n/* 菜单位置 */\r\n#cdwz{\r\n  position: fixed;\r\n  right: 30rpx;\r\n  top: 80rpx;\r\n  text-align: center;\r\n}\r\n/* 字母菜单样式 */\r\n.caidan{\r\n  font-size: 25rpx;\r\n  margin-top: 10rpx;\r\n  color: #007ADF;\r\n}\r\n::-webkit-scrollbar {\r\n width: 0;\r\n height: 0;\r\n color: transparent;\r\n}js代码：　　//获取屏幕高度\r\n\r\n　　var screenHeight = wx.getSystemInfo({\r\n  　　success: function (res) {\r\n    　　screenHeight = res.windowHeight\r\n  　　}\r\n　　})\r\nPage({\r\n\r\n  /**\r\n   * 页面的初始数据\r\n   */\r\n  data: {\r\n    toView:'',\r\n    height:\"\",\r\n    carModel: [\r\n      [\r\n        {\r\n          id: \"0\",\r\n          name: \"A\"\r\n        },\r\n      ],\r\n      [\r\n      {\r\n        id: \"0\",\r\n        name: \"B\"\r\n      },\r\n      ],\r\n      [\r\n        {\r\n          id: \"0\",\r\n          name: \"C\"\r\n        },\r\n      ],\r\n      [\r\n        {\r\n          id: \"0\",\r\n          name: \"D\"\r\n        },\r\n      ],\r\n      [\r\n        {\r\n          id: \"0\",\r\n          name: \"E\"\r\n        },\r\n      ],\r\n      [\r\n        {\r\n          id: \"0\",\r\n          name: \"F\"\r\n        },\r\n      ], \r\n      [\r\n        {\r\n          id: \"0\",\r\n          name: \"G\"\r\n        },\r\n      ], \r\n      [\r\n        {\r\n          id: \"0\",\r\n          name: \"H\"\r\n        },\r\n      ], \r\n      [\r\n        {\r\n          id: \"0\",\r\n          name: \"I\"\r\n        },\r\n      ],\r\n      [\r\n        {\r\n          id: \"0\",\r\n          name: \"J\"\r\n        },\r\n      ], \r\n      [\r\n        {\r\n          id: \"0\",\r\n          name: \"K\"\r\n        },\r\n      ], \r\n      [\r\n        {\r\n          id: \"0\",\r\n          name: \"L\"\r\n        },\r\n      ], \r\n      [\r\n        {\r\n          id: \"0\",\r\n          name: \"M\"\r\n        },\r\n      ], \r\n      [\r\n        {\r\n          id: \"0\",\r\n          name: \"N\"\r\n        },\r\n      ], \r\n      [\r\n        {\r\n          id: \"0\",\r\n          name: \"O\"\r\n        },\r\n      ], \r\n      [\r\n        {\r\n          id: \"0\",\r\n          name: \"P\"\r\n        },\r\n      ], \r\n      [\r\n        {\r\n          id: \"0\",\r\n          name: \"Q\"\r\n        },\r\n      ], \r\n      [\r\n        {\r\n          id: \"0\",\r\n          name: \"R\"\r\n        },\r\n      ], \r\n      [\r\n        {\r\n          id: \"0\",\r\n          name: \"S\"\r\n        },\r\n      ], \r\n      [\r\n        {\r\n          id: \"0\",\r\n          name: \"T\"\r\n        },\r\n      ], \r\n      [\r\n        {\r\n          id: \"0\",\r\n          name: \"U\"\r\n        },\r\n      ], \r\n      [\r\n        {\r\n          id: \"0\",\r\n          name: \"V\"\r\n        },\r\n      ], \r\n      [\r\n        {\r\n          id: \"0\",\r\n          name: \"W\"\r\n        },\r\n      ], \r\n      [\r\n        {\r\n          id: \"0\",\r\n          name: \"X\"\r\n        },\r\n      ], \r\n      [\r\n        {\r\n          id: \"0\",\r\n          name: \"Y\"\r\n        },\r\n      ], \r\n      [\r\n        {\r\n          id: \"0\",\r\n          name: \"Z\"\r\n        },\r\n      ],\r\n    ],\r\n    letter: ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'],\r\n    },\r\n  jump: function (num){\r\n    var text = this.data.letter[num.target.id];\r\n    this.setData({\r\n      toView: text,\r\n    })\r\n    console.log(text);\r\n\r\n  },\r\n  onLoad: function (options) {\r\n\r\n    var that = this\r\n    // 获取系统信息\r\n    wx.getSystemInfo({\r\n      success: function (res) {\r\n        // 计算主体部分高度,单位为px\r\n        that.setData({\r\n          height: res.windowHeight\r\n        })\r\n      }\r\n    })\r\n  },\r\n\r\n})"}
{"title": "用小程序原生的swiper，实现酷炫banner（基于mpvue） ", "author": "Rolan", "time": "2018-9-17 00:59", "content": "前些日子老板大人又安排了新的任务——banner的开发，拿到设计妹子给的设计图之后，我的第一感觉就是——呵！看起来不难嘛！不就是用touchStart，touchmove，touchend组合+一些transition效果+一些位置计算就能实现了吗？？？看我两天内不用轮子直接手写一个实现它！。。。一天半后。。。在尝试了wx.createAnimation()中的translateX/left+原生的css3的transition之后，我拿起了镜子，摸了摸被自己打肿的脸，心里满是委屈：这特喵的效果怎么都不按照预想的来啊！是我的写法不对还是因为mpvue各种坑使？？？我开始深深滴怀疑自己。。。在基本确定此路不通之后（后来了解到其实应该是mpvue数据更新机制的问题，每次修改一个data()里面的值，都会刷新其他的值，不信你可以在mpvue中去试试用scroll-view组件的scroll-top属性实现返回顶部试试。。。），我打开了技术群，抛出了问题，然后有人指出其实用小程序的swiper应该也可以实现的，这个想法我之前在某一瞬间曾经有过——swiper设置好基础参数，然后额外加一些样式，应该可以实现。这位仁兄的思路和我不谋而合（咳咳咳，我先不要脸，你们随意），我也重拾信心，下面呢，就是具体的实现方法以及效果了：1.先看下效果吧动图我并不会做，就放一张截图吧，想看具体的效果的小伙伴们可以去我 github的项目：mpvue-banner 上下载并且跑起来看一下(我是真的不知道怎么在MacBook上制作gif，如果有哪位小伙伴知道，可以在评论里告知，感谢感谢！)，如果这个banner不是你想要的效果，您可以选择不再往下看，或者可以看看实现的思路～下面先看下图片吧banner就在上图中红色框内，可以看到此款banner并没有像大多数banner一样占据整个屏幕的宽度，而是前后的banner图都露出了一部分，而且展示的banner图比前后的banner图片大小上还放大了一定的倍数，这样看下来是不是觉得整体设计上要比默认的banner效果好了不少呢？如果还有兴趣的话，请继续往下看具体的实现思路以及代码2.看完了效果，我们再来看下mpvue的swiper组件吧mpvue的该组件也是基于小程序原生的swiper组件实现的，具体的属性我就不再挨个介绍了，毕竟官方文档里写的很清楚了～这里就主要说下我们要实现上图中的banner要依赖的最重要的两个属性previous-margin和next-margin，前者主要作用是「露出前一项的一小部分」，后者主要作用是「露出后一项的一小部分」，好了，我们先把mpvue-swiper组件介绍中的代码copy 过来：<template>\r\n  <div class=\"page\">\r\n    <view class=\"page__hd\">\r\n      <view class=\"page__title\">Swiper</view>\r\n      <view class=\"page__desc\">滑块视图容器，这里采用小程序原生 swiper 组件实现。</view>\r\n    </view>\r\n    <div class=\"page__bd page__bd_spacing\">\r\n      <swiper :indicator-dots=\"indicatorDots\" \r\n        :autoplay=\"autoplay\" \r\n        :interval=\"interval\" \r\n        :duration=\"duration\" \r\n        :circular=\"circular\" \r\n        @change=\"swiperChange\" \r\n        @animationfinish=\"animationfinish\">\r\n        <div v-for=\"item in imgUrls\" :key=\"index\">\r\n          <swiper-item>\r\n            <image :src=\"item\" class=\"slide-image\" />\r\n          </swiper-item>\r\n        </div>\r\n      </swiper>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  data() {\r\n    return {\r\n      indicatorDots: true,\r\n      autoplay: true,\r\n      interval: 5000,\r\n      duration: 900,\r\n      circular: true,\r\n      imgUrls: [\r\n        'http://img02.tooopen.com/images/20150928/tooopen_sy_143912755726.jpg',\r\n        'http://img06.tooopen.com/images/20160818/tooopen_sy_175866434296.jpg',\r\n        'http://img06.tooopen.com/images/20160818/tooopen_sy_175833047715.jpg'\r\n      ]\r\n    }\r\n  },\r\n  methods: {\r\n    swiperChange(e) {\r\n      console.log('第' + e.mp.detail.current + '张轮播图发生了滑动');\r\n    },\r\n    animationfinish(e) {\r\n      console.log('第' + e.mp.detail.current + '张轮播图滑动结束');\r\n    }\r\n  }\r\n}\r\n</script>\r\n<style>\r\n.slide-image {\r\n  width: 100%;\r\n  height: 100%;\r\n}\r\n</style>\r\n复制代码粘完这些代码，你能实现一个很常规的banner了，然后我们加上刚刚我们提到的那两个属性：<swiper :indicator-dots=\"indicatorDots\" \r\n        :autoplay=\"autoplay\" \r\n        :interval=\"interval\" \r\n        :duration=\"duration\" \r\n        :circular=\"circular\" \r\n        :previous-margin=\"'60rpx'\"\r\n        :next-margin=\"'60rpx'\"\r\n        @change=\"swiperChange\" \r\n        @animationfinish=\"animationfinish\">\r\n        <div v-for=\"item in imgUrls\" :key=\"index\">\r\n          <swiper-item>\r\n            <div class=\"img-wrapper\">\r\n                <image :src=\"item\" class=\"slide-image\" />\r\n            </div>\r\n          </swiper-item>\r\n        </div>\r\n    </swiper>\r\n复制代码这时候你就实现了一个能将前一项和后一项各露出60rpx的banner了，只不过此时各项的图片大小都是相同的，那怎么实现主项的图片大小的放大呢，当然是使用css的transform给图片标签加各放大的样式，且往下看代码：<swiper :indicator-dots=\"indicatorDots\" \r\n        :autoplay=\"autoplay\" \r\n        :interval=\"interval\" \r\n        :duration=\"duration\" \r\n        :circular=\"circular\" \r\n        :previous-margin=\"'60rpx'\"\r\n        :next-margin=\"'60rpx'\"\r\n        @change=\"swiperChange\" \r\n        @animationfinish=\"animationfinish\">\r\n        <div v-for=\"item in imgUrls\" :key=\"index\">\r\n          <swiper-item>\r\n            <div class=\"img-wrapper\"\r\n                :style=\"{\r\n                    boxSizing: 'border-box', \r\n                    width: '100%', \r\n                    height: '100%', \r\n                    display: 'flex', \r\n                    justifyContent: 动态值，需要根据设计图以及banner图片的个数以及位置进行计算得出, \r\n                    padding: 动态值，需要根据设计图以及banner图片的个数以及位置进行计算得出\r\n                }\">\r\n                <image :src=\"item\" \r\n                    class=\"slide-image\" \r\n                    :style=\"{\r\n                        transform: currentIndex===bannerIndex?'scale(' + scaleX + ',' + scaleY + ')':'scale(1,1)',\r\n                        transitionDuration: '.3s',\r\n                        transitionTimingFunction: 'ease'\r\n                    }\"/>\r\n            </div>\r\n          </swiper-item>\r\n        </div>\r\n    </swiper>\r\n复制代码其中几个出现的参数：currentIndex：即当前展现的banner项的索引bannerIndex：即banner项在整个图片列表中的索引scaleX以及scaleY：即你希望的主项的放大的倍数，此项的值可能需要我们根据屏幕宽度以及设计稿的展示来进行计算这几个样式就是：将当前展示的图片放大一定的倍数到了这里，我们需要的结构以及style上的代码基本上都有了，下面主要是script里对一些关键的参数进行控制，这里有个比较重要的函数@change<script>\r\ndata () {\r\n    return {\r\n        autoplay: false,\r\n        interval: 3000,\r\n        duration: 300,\r\n        circular: true,\r\n        currentIndex: 0,\r\n        scaleX: (634 / 550).toFixed(4),\r\n        scaleY: (378 / 328).toFixed(4)\r\n    }\r\n},\r\nmethods: {\r\n    // 控制currentIndex以及动画执行索引descIndex的值\r\n    swiperChange (e) {\r\n        const that = this\r\n        this.currentIndex = e.mp.detail.current\r\n        this.scaleX = (634 / 550).toFixed(4)\r\n        this.scaleY = (378 / 328).toFixed(4)\r\n    }\r\n}\r\n</script>\r\n复制代码3.注意点至此呢，主图中的banner的主要效果基本已经实现了，看下来其实并不是很难，主要是一些细节需要特别注意：3.1：previous-margin和next-margin的值它们的值并不是随便写的，需要你根据设计图去进行细微的计算3.2：swiper-item内，image标签外的class名为img-wrapper的div容器的样式其中我没有写出具体值的两项属性：justifyContent与padding，他们的具体值同样需要你去进行计算，此时的计算不止会涉及到设计稿，他们的值还会根据当前展示出来的三张图片在整个imgList（至少三项）中的顺序的不同而不同，在我的实现中我使用了超长的三目运算符来保证每个图片的具体的属性值。。。"}
{"title": "小程序导出朋友圈海报详细记录 ", "author": "Rolan", "time": "2018-9-18 00:08", "content": "小程序提供了转发给好友的接口，但是没提供分享到朋友圈的接口。于是，只有引导用户保存图片分享到朋友圈。 两种方案：用微信 api 手动保存，用 painter 。微信 api使用原生接口的话，大致是使用 canvas 绘制出海报，然后下载。所以重点是绘制出海报，下载的流程都是一样的。当然在保存图片到相册前，还会需要获取保存图片到相册的权限。总结下来就是canvas绘制，获取保存权限，保存图片这三个步骤。 首先来看绘制海报，需要使用以下接口wx.createCanvasContext 创建 canvas contextctx.drawImage 绘制图片到 canvasctx.fillText 写文字wx.getImageInfo 获取网络图片的 tempFilePathctx.draw canvas 绘制最终保存下来的海报是这样的绘制的内容很简单，首先就是背景图；然后是分享者的头像；接下来是 @ xx 邀请你 这样一个文本描述；最后就是底部的小程序码。首先，创建 canvas 画布<canvas canvas-id='canvas' class='canvas' :style=\"{height: windowHeight + 'px'}\"/>\r\n复制代码使用小程序 createCanvasContext api ,需要传入 canvasidconst ctx = wx.createCanvasContext('canvas')\r\n复制代码然后将背景图片绘制出来，背景图片是放在本地的图片。ctx.drawImage('../../../static/assets/img/poster_background.png', 0, 0, this.windowWidth, this.windowHeight)\r\n复制代码然后写上文字ctx.setFontSize(12);\r\nctx.setFillStyle('#FFFFFF');\r\nctx.setTextAlign('center');\r\nctx.fillText(`${this.privateUserInfo.nickname} 邀您领取`, this.windowWidth / 2, this.transformScale(520))\r\n复制代码这里会将原始尺寸和绘制的尺寸等比例转换一下，就不赘述了。再接下来就是绘制小程序码了。由于小程序码是带了分享者的信息，所以必须是临时获取的网络图片资源，具体怎么获取带有分享者信息的小程序码，会专门写一篇文章介绍。绘制图片绘制头像与小程序码，这两张图片都是网络资源，所以都要使用 wx. getImageInfo 接口将其下载下来放到微信内存中，然后使用其response.path 绘制。小程序并不支持直接的绘制网络图片，而且也不支持 base64图片的绘制（虽然模拟器上会有效果）。头像的绘制还有有一个裁剪圆形头像的过程。wx.getImageInfo是异步的，所以在回调函数里绘制，当然这不是好的方式。可以使用 promise 来解决，由于现在已经不用这个代码了，就没有去改了。wx.getImageInfo({\r\n          src: miniProgramCodeSrc,\r\n          success: (response) => {\r\n            const miniProgramCodeSize = this.transformScale(160)\r\n            ctx.drawImage(response.path, this.transformScale(85), this.transformScale(710), miniProgramCodeSize, miniProgramCodeSize)\r\n\r\n            wx.getImageInfo({\r\n              src: this.privateUserInfo.avatar,\r\n              success: (response) => {\r\n                const avatarSize = this.transformScale(100)\r\n                //先绘制圆，裁剪成圆形图片\r\n                ctx.save();\r\n                ctx.beginPath();\r\n                //圆的原点x坐标，y坐标，半径，起始弧度，终止弧度\r\n                ctx.arc(this.transformScale(320), this.transformScale(425), avatarSize / 2, 0, 2 * Math.PI);\r\n                ctx.setStrokeStyle('#ffffff');\r\n                ctx.stroke();\r\n                ctx.clip();\r\n\r\n                ctx.drawImage(response.path, this.transformScale(270), this.transformScale(375), avatarSize, avatarSize)\r\n                ctx.restore();\r\n\r\n                ctx.draw(false, () => {\r\n                  this.saveToTempFilePath()\r\n                })\r\n              }\r\n            })\r\n          }\r\n        })\r\n复制代码到这一步，绘制基本就结束了。我们所要的海报内容已经可以在 canvas 上呈现了，接下来就是将 canvas 的内容保存为图片了。值得提醒的是，ctx.draw这个接口也是异步的，需要在其回调中执行下载的操作。获取 tempFilePathwx.canvasToTempFilePath 获取整个 canvas 的tempFilePath保存图片最重要的就是tempFilePath了，使用canvasToTempFilePath 获取 tempFilePath。需要注意的是canvasToTempFilePath接口二参需要传入 this。saveToTempFilePath() {\r\n        wx.canvasToTempFilePath({\r\n          canvasId: 'canvas',\r\n          success: (response) => {\r\n            //获取相册授权\r\n          }\r\n        }, this)\r\n      }\r\n复制代码获取 tempFilePath 成功后再获取保存权限，当然也可以先获取保存权限，再获取tempFilePath。获取保存权限首先查看是否有保存权限，有权限就可以直接保存了。没有权限就先获取权限，再保存。wx.getSetting 查看权限列表wx.authorize 若没有保存图片权限，进行授权wx.getSetting({\r\n  success: (res) => {\r\n    if (!res.authSetting['scope.writePhotosAlbum']) {\r\n      wx.authorize({\r\n        scope:'scope.writePhotosAlbum',\r\n        success: () => {\r\n          this.saveImageToPhotosAlbumByWX(response.tempFilePath)\r\n        }\r\n      })\r\n    } else {\r\n      this.saveImageToPhotosAlbumByWX(response.tempFilePath)\r\n    }\r\n  }\r\n})\r\n复制代码保存图片到相册wx.saveImageToPhotosAlbum 保存图片到相册这一步就很简单了，万事俱备，只差保存了。调用 wx.saveImageToPhotosAlbum 即可。saveImageToPhotosAlbumByWX(tempFilePath) {\r\n        wx.saveImageToPhotosAlbum({\r\n          filePath: tempFilePath,\r\n          complete: () => {\r\n            // 其他操作\r\n          }\r\n        })\r\n      }\r\n复制代码到这里，使用原生 api 保存一张分享朋友圈的海报就好了。painterpainter 是什么呢？小程序生成图片库，轻松通过 json 方式绘制一张可以发到朋友圈的图片painter 是酷家乐开源的小程序图片生成库，类似 echarts，使用配置对象渲染图片到 canvas。渲染完成后回调会返回 tempFilePath,然后调用 wx.saveImageToPhotosAlbum 即可保存。保存的步骤和第一种方案一致，关键是获取到 tempFilePath。按照其 readme 来操作就好了，由于项目是使用了 mpvue，所以使用了 mpvue接入方案 。使用 painter<painter v-if=\"showPainter\" class='canvas' @imgOK=\"onImgOk\" :palette=\"palette\"/>\r\n复制代码为什么要使用 v-if 呢，需要在所有数据都准备好了后再渲染 painter，否则会无限绘制。data() {\r\n  return {\r\n    //painter 配置数据\r\n    palette: {\r\n      width: '640rpx',\r\n      height: '1008rpx',\r\n      background: '/static/assets/img/poster_background.png',\r\n      views: [\r\n        {\r\n          type: 'image',\r\n          url: '',\r\n          css: {\r\n            top: '380rpx',\r\n            left: '320rpx',\r\n            align: 'center',\r\n            width: '100rpx',\r\n            height: '100rpx',\r\n            borderRadius: '50rpx'\r\n          }\r\n        }, {\r\n          type: 'text',\r\n          text: '',\r\n          css: {\r\n            top: '490rpx',\r\n            left: '320rpx',\r\n            align: 'center',\r\n            fontSize: '24rpx',\r\n            color: '#fff'\r\n          }\r\n        },\r\n        {\r\n          type: 'image',\r\n          url: '',\r\n          css: {\r\n            top: '690rpx',\r\n            left: '85rpx',\r\n            width: '180rpx',\r\n            height: '180rpx'\r\n          }\r\n        }\r\n      ]\r\n    }\r\n\r\n  }\r\n},\r\n\r\ncomputed: {\r\n  showPainter() {\r\n    const avatar = this.palette.views[0].url\r\n    const text = this.palette.views[1].text\r\n    const qrCodeUrl = this.palette.views[2].url\r\n    return avatar !== '' && text !== '' && qrCodeUrl!== ''\r\n  }\r\n}\r\n复制代码在 painter绘制成功的回调里，将 tempFilePath 保存起来。接下来的权限获取和保存图片到相册流程就和上一个方案一致了。但是，需要提醒的是，tempFilePath 需要放在全局变量中，不能放在data 中。总结总结一下，遇到的一些坑小程序canvas不能支持 base64drow 有回调drawImage 不能直接使用网络图片需要处理获取权限，用户拒绝后的场景最后海报就暴露了，是的，就是漫游鲸。欢迎扫个码体验漫游鲸小程序，欢迎了解下漫游鲸。如果还不了解漫游鲸， 那么点击就能了解漫游鲸啦"}
{"title": "小程序构建骨架屏的探索 ", "author": "Rolan", "time": "2018-9-18 00:12", "content": "首屏一般情况下，在首屏数据未拿到之前，为了提升用户的体验，会在页面上展示一个loading的图层，类似下面这个其中除了菊花图以外网上还流传这各种各样的loading动画，在PC端上几乎要统一江湖了，不过最近在移动端上面看到不同于菊花图的加载方式，就是这篇文章需要分享的Skeleton Screen，中文称之为\"骨架屏\"概念A skeleton screen is essentially a blank version of a page into which information is gradually loaded.在H5中，骨架屏其实已经不是什么新奇的概念了，网上也有各种方案生成对应的骨架屏，包括我们经常使用的知乎、饿了么、美团等APP都有应用骨架屏这个概念图片来源网络，侵删方案先从H5生成骨架屏方案开始说起，总的来说H5生成骨架屏的方案有2种完全靠手写HTML和CSS方式给每个页面定制一套骨架屏利用预渲染的方式生成静态骨架屏第一套方案，毫无疑问是最简单最直白的方式，缺点也很明显，假如页面布局有修改的话，那么除了修改业务代码之外还需要额外修改骨架屏，增加了维护的成本。第二套方案，一定程度上改善了第一套方案带来的维护成本增加的缺点，主要还是使用工具预渲染页面，获取到DOM节点和样式，保留页面结构，覆盖样式，生成灰色块盖在原有文本、图片或者是canvas等节点上面，最后将生成的HTML和CSS打包出来，就是一个带有骨架屏的页面。最后再利用webpack工具将生成的骨架屏插入到HTML里面，详细的话可以看看饿了么的分享，这里就不多描述了。调研了下H5生成骨架屏的方案，对于小程序生成骨架屏的方案也有了一个大致的想法，主要有2个难点需要实现预渲染获取节点预渲染再说回饿了么提供的骨架屏的方案，使用 puppeteer 渲染页面（或者使用服务端渲染，vue或者react都有提供相应的方案），拿到DOM节点和样式，这里有一点需要注意的是，页面的渲染是需要初始化的数据，数据的来源可以是初始化的data（vue）或者mock数据，当然小程序是无法直接使用 puppeteer 来做预渲染（有另外的方案可以实现），需要利用小程序初始化的 data + template 渲染之后得到一个初始化结构作为骨架屏的结构//index.js\r\nPage({\r\n    data: {\r\n        motto: 'Hello World',\r\n        userInfo: {\r\n            avatarUrl: 'https://wx.qlogo.cn/mmopen/vi_32/SYiaiba5faeraYBoQCWdsBX4hSjFKiawzhIpnXjejDtjmiaFqMqhIlRBqR7IVdbKE51npeF6X1cXxtDQD2bzehgqMA/132',\r\n            nickName: 'jay'\r\n        },\r\n        lists: [\r\n            'aslkdnoakjbsnfkajbfk',\r\n            'qwrwfhbfdvndgndghndeghsdfh',\r\n            'qweqwtefhfhgmjfgjdfghaefdhsdfgdfh',\r\n        ],\r\n        showSkeleton: true\r\n    },\r\n    onLoad: function () {\r\n        const that = this;\r\n        setTimeout(() => {\r\n            that.setData({\r\n                showSkeleton: false\r\n            })\r\n        }, 3000)\r\n    }\r\n})\r\n\r\n//index.wxml\r\n<view class=\"container\">\r\n    <view class=\"userinfo\">\r\n        <block>\r\n            <image class=\"userinfo-avatar skeleton-radius\" src=\"{{userInfo.avatarUrl}}\"\r\n                   mode=\"cover\"></image>\r\n            <text class=\"userinfo-nickname skeleton-rect\">{{userInfo.nickName}}</text>\r\n        </block>\r\n    </view>\r\n    <view style=\"margin: 20px 0\">\r\n        <view wx:for=\"{{lists}}\" class=\"lists\">\r\n            <icon type=\"success\" size=\"20\" class=\"list skeleton-radius\"/>\r\n            <text class=\"skeleton-rect\">{{item}}</text>\r\n        </view>\r\n    </view>\r\n\r\n    <view class=\"usermotto\">\r\n        <text class=\"user-motto skeleton-rect\">{{motto}}</text>\r\n    </view>\r\n\r\n    <view style=\"margin-top: 200px;\">\r\n        aaaaaaaaaaa\r\n    </view>\r\n</view>有了上面的 data + template 之后，就有了一个初始化的页面结构，接下来就需要拿到节点信息节点小程序基础库1.4.0之后小程序基础库提供了一组新的API，可用于获取节点信息，具体API戳这里。跟H5方式一样，根据class或者id获取节点信息，不同的是只能获取到当前的节点信息，无法获取到其父或者子节点信息，所以只能手动给需要渲染骨架屏的节点添加相应的class或者id<view class=\"container\">\r\n    <view class=\"userinfo\">\r\n        <block>\r\n            <image class=\"userinfo-avatar skeleton-radius\" src=\"{{userInfo.avatarUrl}}\"\r\n                   mode=\"cover\"></image>\r\n            <text class=\"userinfo-nickname skeleton-rect\">{{userInfo.nickName}}</text>\r\n        </block>\r\n    </view>\r\n    <view style=\"margin: 20px 0\">\r\n        <view wx:for=\"{{lists}}\" class=\"lists\">\r\n            <icon type=\"success\" size=\"20\" class=\"list skeleton-radius\"/>\r\n            <text class=\"skeleton-rect\">{{item}}</text>\r\n        </view>\r\n    </view>\r\n\r\n    <view class=\"usermotto\">\r\n        <text class=\"user-motto skeleton-rect\">{{motto}}</text>\r\n    </view>\r\n\r\n    <view style=\"margin-top: 200px;\">\r\n        aaaaaaaaaaa\r\n    </view>\r\n</view>约定2个特殊的class作为获取节点信息的标记skeleton-rect和skeleton-radius，在页面中获取相应的top、left、width、height进行骨架屏的绘制结果具体的调用方式和源码，请看 github ，最后求start总结上文有说到小程序也可以使用 page-skeleton-webpack-plugin 方式一样生成骨架屏，最重要的一点就是需要将小程序跑在chrome上面，后面的流程就一样了，至于怎么将小程序跑在chrome上面呢？可以利用 wept ，缺点就是目前作者已经停止维护这个工具了，不支持新版小程序的API。说回来我这个生成骨架屏的方案，其实跟 page-skeleton-webpack-plugin 有点相似，不同的是，page-skeleton-webpack-plugin 采用离线渲染的方式生成静态骨架屏插入路由中，而我采用运行时先渲染页面默认结构，然后根据默认结构再绘制骨架屏。从性能角度出发确实不如 page-skeleton-webpack-plugin，但是也差不了多少了，主要还是小程序并没有提供类似服务端渲染的方案。目前从使用上来讲，还是有点小麻烦，需要默认数据撑开页面结构，需要给相应的节点添加class，后面有时间再研究下有没有更好的方案吧~~~"}
{"title": "微信小程序评论/留言功能，附：前端+后端代码+视频讲解！ ", "author": "Rolan", "time": "2018-9-18 00:27", "content": "前端界面：演示：<!-- 表单 -->\r\n<form bindsubmit=\"formSubmit\">\r\n<input type=\"text\" name=\"liuyantext\" placeholder='输入留言内容' class=\"input-style\"/>\r\n<button formType=\"submit\" class=\"btn\" wx:if=\"{{nickName == empty}}\" open-type=\"getUserInfo\" bindgetuserinfo=\"bindGetUserInfo\" bindtap='login'>授权登录</button>\r\n<button formType=\"submit\" class=\"btn\" wx:else>留言</button>\r\n<input type=\"text\" name=\"nickname\" value='{{nickName}}' style=\"display:none;\"/>\r\n<input type=\"text\" name=\"headimg\" value='{{avatarUrl}}' style=\"display:none;\"/>\r\n</form>\r\n\r\n<view wx:for=\"{{re}}\" wx:key=\"re\">\r\n  <view class=\"result\">{{item.result}}</view>\r\n</view>\r\n<view style=\"text-align:center;font-size:14px;color:#ccc;margin-top:20px;\">以下是留言内容</view>\r\n<view wx:for=\"{{liuyanlist}}\" wx:key=\"liuyanlist\" class=\"liuyanview\">\r\n  <view class=\"headimg\"><image src=\"{{item.headimg}}\"></image></view>\r\n  <view class=\"nickname_liuyantext\">\r\n    <view class=\"nickname\">{{item.nickname}} <view class=\"time\">{{item.lytime}}</view></view>\r\n    <view class=\"text\">{{item.liuyantext}}</view>\r\n  </view>\r\n  <!-- 占位符 -->\r\n  <view style=\"width:100%;height:10px;\"></view>\r\n</view>\r\n//index.js\r\n//获取应用实例\r\nconst app = getApp()\r\nPage({\r\n  /**\r\n   * 页面的初始数据\r\n   */\r\n  data: {\r\n    \r\n  },\r\n\r\n  //授权登录\r\n  login: function () {\r\n    var that = this;\r\n    // 查看是否授权\r\n    wx.getSetting({\r\n      success(res) {\r\n        if (res.authSetting['scope.userInfo']) {\r\n          // 已经授权，可以直接调用 getUserInfo 获取头像昵称\r\n          wx.getUserInfo({\r\n            success: function (res) {\r\n              console.log(res.userInfo),\r\n                that.setData({\r\n                  nickName: res.userInfo.nickName,\r\n                  avatarUrl: res.userInfo.avatarUrl,\r\n                })\r\n            }\r\n          })\r\n        }\r\n      }\r\n    })\r\n  },\r\n  bindGetUserInfo(e) {\r\n    console.log(e.detail.userInfo)\r\n  },\r\n\r\n\r\n  formSubmit: function (e) {\r\n    wx.showToast({\r\n      title: '已留言',\r\n      icon: 'success'\r\n    })\r\n    var that = this;\r\n    var liuyantext = e.detail.value.liuyantext; //获取表单所有name=liuyantext的值 \r\n    var nickName = e.detail.value.nickname; //获取表单所有name=nickName的值 \r\n    var headimg = e.detail.value.headimg; //获取表单所有name=headimg的值 \r\n    wx.request({\r\n      url: 'http://localhost/liuyanserver/liuyan.php?liuyantext=' + liuyantext + '&nickname=' + nickName + '&headimg=' + headimg,\r\n      data: {\r\n        liuyantext,\r\n        nickName,\r\n        headimg\r\n      },\r\n      header: { 'Content-Type': 'application/json' },\r\n      success: function (res) {\r\n        console.log(res.data)\r\n        that.setData({\r\n          re: res.data,\r\n        })\r\n        wx.hideToast();\r\n      }\r\n    })\r\n  },\r\n\r\n  onPullDownRefresh: function () {\r\n    wx.showNavigationBarLoading();\r\n    var that = this\r\n    wx.request({\r\n      url: 'http://localhost/liuyanserver/loadliuyan.php',\r\n      headers: {\r\n        'Content-Type': 'application/json'\r\n      },\r\n      success: function (res) {\r\n        //将获取到的json数据，存在名字叫list的这个数组中\r\n        that.setData({\r\n          liuyanlist: res.data,\r\n          //res代表success函数的事件对，data是固定的，liuyanlist是数组\r\n        })\r\n        // 隐藏导航栏加载框\r\n        wx.hideNavigationBarLoading();\r\n        // 停止下拉动作\r\n        wx.stopPullDownRefresh();\r\n      }\r\n    })\r\n  },\r\n\r\n  //加载最新数据\r\n  onLoad: function () {\r\n    var that = this\r\n    wx.request({\r\n      url: 'http://localhost/liuyanserver/loadliuyan.php',\r\n      headers: {\r\n        'Content-Type': 'application/json'\r\n      },\r\n      success: function (res) {\r\n        //将获取到的json数据，存在名字叫list的这个数组中\r\n        that.setData({\r\n          liuyanlist: res.data,\r\n          //res代表success函数的事件对，data是固定的，liuyanlist是数组\r\n        })\r\n      }\r\n    })\r\n  }\r\n})/**index.wxss**/\r\n.input-style{\r\n  width: 90%;\r\n  height: 50px;\r\n  border:1px solid #ccc;\r\n  margin:10px auto;\r\n}\r\n\r\n.btn{\r\n  width: 88%;\r\n  margin:5px auto;\r\n}\r\n\r\n.liuyanview{\r\n  width: 90%;\r\n  margin: 10px auto;\r\n}\r\n\r\n.result{\r\n  text-align: center;\r\n  font-size: 14px;\r\n  color: #f00;\r\n  margin-top: 20px;\r\n}\r\n\r\n.headimg{\r\n  width: 45px;\r\n  height: 45px;\r\n  border-radius: 100%;\r\n}\r\n\r\n.headimg image{\r\n  width: 45px;\r\n  height: 45px;\r\n  border-radius: 100%;\r\n}\r\n\r\n.nickname_liuyantext{\r\n  width: calc(100% - 55px);\r\n  float: right;\r\n  margin-top:-45px;\r\n}\r\n\r\n.nickname_liuyantext .nickname{\r\n  font-size: 15px;\r\n  color: #999;\r\n}\r\n\r\n.nickname_liuyantext .nickname .time{\r\n  font-size: 11px;\r\n  color: #999;\r\n  float: right;\r\n}\r\n\r\n.nickname_liuyantext .text{\r\n  font-size: 16px;\r\n  color: #666;\r\n}以上是前端部分后端有两个文件。点击下载后端，后端需要修改自己的数据库配置！http://www.youka.la/product/5...数据库格式：视频:https://www.lanzous.com/i1w1deb"}
{"title": "在微信小程序中渲染HTML内容 ", "author": "Rolan", "time": "2018-9-18 00:36", "content": "大部分Web应用的富文本内容都是以HTML字符串的形式存储的，通过HTML文档去展示HTML内容自然没有问题。但是，在微信小程序（下文简称为「小程序」）中，应当如何渲染这部分内容呢？解决方案wxParse小程序刚上线那会儿，是无法直接渲染HTML内容的，于是就诞生了一个叫做「 wxParse 」的库。它的原理就是把HTML代码解析成树结构的数据，再通过小程序的模板把该数据渲染出来。rich-text后来，小程序增加了「rich-text」组件用于展示富文本内容。然而，这个组件存在一个极大的限制： 组件内屏蔽了所有节点的事件 。也就是说，在该组件内，连「预览图片」这样一个简单的功能都无法实现。web-view再后来，小程序允许通过「web-view」组件嵌套网页，通过网页展示HTML内容是兼容性最好的解决方案了。然而，因为要多加载一个页面，性能是较差的。当「WePY」遇上「wxParse」基于用户体验和功能交互上的考虑，我们抛弃了「rich-text」和「web-view」这两个原生组件，选择了「wxParse」。然而，用着用着却发现，「wxParse」也不能很好地满足需要：我们的小程序是基于「WePY」框架开发的，而「wxParse」是基于原生的小程序编写的。要想让两者兼容，必须修改「wxParse」的源代码。「wxParse」只是简单地通过image组件对原img元素的图片进行显示和预览。而在实际使用中，可能会用到云存储的接口对图片进行缩小，达到「 用小图显示，用原图预览 」的目的。「wxParse」直接使用小程序的video组件展示视频，但是video组件的 层级问题 经常导致UI异常（例如把某个固定定位的元素给挡了）。此外，围观一下「wxParse」的代码仓库可以发现，它已经两年没有迭代了。所以就萌生了基于「WePY」的组件模式重新写一个富文本组件的想法，其成果就是「WePY HTML」项目。实现过程解析HTML首先仍然是要把HTML字符串解析为树结构的数据，我采用的是「特殊字符分隔法」。HTML中的特殊字符是「<」和「>」，前者为开始符，后者为结束符。如果待解析内容以开始符开头，则截取 开始符到结束符之间 的内容作为节点进行解析。如果待解析内容不以开始符开头，则截取 开头到开始符之前 （如果开始符不存在，则为末尾）的内容作为纯文本解析。剩余内容进入下一轮解析，直到无剩余内容为止。正如下图所示：为了形成树结构，解析过程中要维护一个上下文节点（默认为根节点）：如果截取出来的内容是开始标签，则根据匹配出的标签名和属性，在当前上下文节点下创建一个子节点。如果该标签不是自结束标签（br、img等），就把上下文节点设为新节点。如果截取出来的内容是结束标签，则根据标签名关闭当前上下文节点（把上下文节点设为其父节点）。如果是纯文本，则在当前上下文节点下创建一个文本节点，上下文节点不变。过程正如下面的表格所示：经过上述流程，HTML字符串就被解析为节点树了。对比把上述算法与其他类似的解析算法进行对比（性能以「解析10000长度的HTML代码」进行测定）：可见，在不考虑容错性（产生错误的结果，而非抛出异常）的情况下，本组件的算法与其余两者相比有压倒性的优势，符合小程序「 小而快 」的需要。而一般情况下，富文本编辑器所生成的代码也不会出现语法错误。因此，即使容错性较差，问题也不大（但这是需要改进的）。模板渲染树结构的渲染，必然会涉及到子节点的 递归 处理。然而，小程序的模板并不支持递归，这下仿佛掉入了一个大坑。看了一下「wxParse」模板的实现，它采用简单粗暴的方式解决这个问题：通过13个长得几乎一模一样的模板进行嵌套调用（1调用2，2调用3，……，12调用13），也就是说最多可以支持12次嵌套。一般来说，这个深度也足够了。由于「WePY」框架本身是有构建机制的，所以不必手写十来个几乎一模一样的模板，通过一个构建的插件去生成即可。以下为需要重复嵌套的模板（精简过），在其代码的开始前和结束后分别插入特殊注释进行标识，并在需要嵌入下一层模板的地方以另一段特殊注释（「<!-- next template -->」）标识：<!-- wepyhtml-repeat start -->\r\n<template name=\"wepyhtml-0\">\r\n\t<block wx:if=\"{{ content }}\" wx:for=\"{{ content }}\">\r\n\t\t<block wx:if=\"{{ item.type === 'node' }}\">\r\n\t\t\t<view class=\"wepyhtml-tag-{{ item.name }}\">\r\n\t\t\t\t<!-- next template -->\r\n\t\t\t</view>\r\n\t\t</block>\r\n\t\t<block wx:else>{{ item.text }}</block>\r\n\t</block>\r\n</template>\r\n<!-- wepyhtml-repeat end -->以下是对应的构建代码（需要安装「 wepy-plugin-replace 」）：// wepy.config.js\r\n{\r\n\tplugins: {\r\n\t\treplace: {\r\n\t\t\tfilter: /\\.wxml$/,\r\n\t\t\tconfig: {\r\n\t\t\t\tfind: /<\\!-- wepyhtml-repeat start -->([\\W\\w]+?)<\\!-- wepyhtml-repeat end -->/,\r\n\t\t\t\treplace(match, tpl) {\r\n\t\t\t\t\tlet result = '';\r\n\t\t\t\t\t// 反正不要钱，直接写个20层嵌套\r\n\t\t\t\t\tfor (let i = 0; i <= 20; i++) {\r\n\t\t\t\t\t\tresult += '\\n' + tpl\r\n\t\t\t\t\t\t\t.replace('wepyhtml-0', 'wepyhtml-' + i)\r\n\t\t\t\t\t\t\t.replace(/<\\!-- next template -->/g, () => {\r\n\t\t\t\t\t\t\t\treturn i === 20 ?\r\n\t\t\t\t\t\t\t\t\t'' :\r\n\t\t\t\t\t\t\t\t\t`<template is=\"wepyhtml-${ i + 1 }\" wx:if=\"{{ item.children }}\" data=\"{{ content: item.children\"></template>`;\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn result;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}然而，运行起来后发现，第二层及更深层级的节点都没有渲染出来，说明嵌套失败了。再看一下dist目录下生成的wxml文件可以发现，变量名与组件源代码的并不相同：<block wx:if=\"{{ $htmlContent$wepyHtml$content }}\" wx:for=\"{{ $htmlContent$wepyHtml$content }}\">「WePY」在生成组件代码时，为了避免组件数据与页面数据的变量名冲突，会 根据一定的规则给组件的变量名增加前缀 （如上面代码中的「$htmlContent$wepyHtml$」）。所以在生成嵌套模板时，也必须使用带前缀的变量名。先在组件代码中增加一个变量「thisIsMe」用于识别前缀：<!-- wepyhtml-repeat start -->\r\n<template name=\"wepyhtml-0\">\r\n\t{{ thisIsMe }}\r\n\t<block wx:if=\"{{ content }}\" wx:for=\"{{ content }}\">\r\n\t\t<block wx:if=\"{{ item.type === 'node' }}\">\r\n\t\t\t<view class=\"wepyhtml-tag-{{ item.name }}\">\r\n\t\t\t\t<!-- next template -->\r\n\t\t\t</view>\r\n\t\t</block>\r\n\t\t<block wx:else>{{ item.text }}</block>\r\n\t</block>\r\n</template>\r\n<!-- wepyhtml-repeat end -->然后修改构建代码：replace(match, tpl) {\r\n\tlet result = '';\r\n\tlet prefix = '';\r\n\r\n    // 匹配 thisIsMe 的前缀\r\n\ttpl = tpl.replace(/\\{\\{\\s*(\\$.*?\\$)thisIsMe\\s*\\}\\}/, (match, p) => {\r\n\t\tprefix = p;\r\n\t\treturn '';\r\n\t});\r\n\r\n\tfor (let i = 0; i <= 20; i++) {\r\n\t\tresult += '\\n' + tpl\r\n\t\t\t.replace('wepyhtml-0', 'wepyhtml-' + i)\r\n\t\t\t.replace(/<\\!-- next template -->/g, () => {\r\n\t\t\t\treturn i === 20 ?\r\n\t\t\t\t\t'' :\r\n\t\t\t\t\t`<template is=\"wepyhtml-${ i + 1 }\" wx:if=\"{{ item.children }}\" data=\"{{ ${ prefix }content: item.children }}\"></template>`;\r\n\t\t\t});\r\n\t}\r\n\r\n\treturn result;\r\n}至此，渲染问题就解决了。图片为了节省流量和提高加载速度，展示富文本内容时，一般都会按照所需尺寸对里面的图片进行缩小，点击小图进行预览时才展示原图。这主要涉及节点属性的修改：把图片原路径（src属性值）存到自定义属性（例如「data-src」）中，并将其添加到预览图数组。把图片的src属性值修改为缩小后的图片URL（一般云服务商都有提供此类URL规则）。点击图片时，使用自定义属性的值进行预览。为了实现这个需求，本组件在解析节点时提供了一个钩子（ onNodeCreate ）：onNodeCreate(name, attrs) {\r\n\tif (name === 'img') {\r\n\t\tattrs['data-src'] = attrs.src;\r\n\t\t// 预览图数组\r\n\t\tthis.previewImgs.push(attrs.src);\r\n\t\t// 缩图\r\n\t\tattrs.src = resizeImg(attrs.src, 640);\r\n\t}\r\n}对应的模板和事件处理逻辑如下：<template name=\"wepyhtml-img\">\r\n\t<image class=\"wepyhtml-tag-img\" mode=\"widthFix\" src=\"{{ elem.attrs.src }}\" data-src=\"{{ elem.attrs['data-src'] || elem.attrs.src }}\" @tap=\"imgTap\"></image>\r\n</template>// 点击小图看大图\r\nimgTap(e) {\r\n\twepy.previewImage({\r\n\t\tcurrent: e.currentTarget.dataset.src,\r\n\t\turls: this.previewImgs\r\n\t});\r\n}视频在小程序中，video组件的层级是较高的（且无法降低）。如果页面设计上存在着可能挡住视频的元素，处理起来就需要一些技巧了：隐藏video组件，用image组件（视频封面）占位；点击图片时，让视频全屏播放；如果退出了全屏，则暂停播放。相关代码如下：<template name=\"wepyhtml-video\">\r\n\t<view class=\"wepyhtml-tag-video\" @tap=\"videoTap\" data-nodeid=\"{{ elem.nodeId }}\">\r\n\t\t<!-- 视频封面 -->\r\n\t\t<image class=\"wepyhtml-tag-img wepyhtml-tag-video__poster\" mode=\"widthFix\" src=\"{{ elem.attrs.poster }}\"></image>\r\n\t\t<!-- 播放图标 -->\r\n\t\t<image class=\"wepyhtml-tag-img wepyhtml-tag-video__play\" src=\"./imgs/icon-play.png\"></image>\r\n\t\t<!-- 视频组件 -->\r\n\t\t<video style=\"display: none;\" src=\"{{ elem.attrs.src }}\" id=\"wepyhtml-video-{{ elem.nodeId }}\" @fullscreenchange=\"videoFullscreenChange\" @play=\"videoPlay\"></video>\r\n\t</view>\r\n</template>{\r\n\t// 点击封面图，播放视频\r\n\tvideoTap(e) {\r\n\t\tconst nodeId = e.currentTarget.dataset.nodeid;\r\n\t\tconst context = wepy.createVideoContext('wepyhtml-video-' + nodeId);\r\n\t\tcontext.play();\r\n\t\t// 在安卓微信下，如果视频不可见，则调用play()也无法播放\r\n\t\t// 需要再调用全屏方法\r\n\t\tif (wepy.getSystemInfoSync().platform === 'android') {\r\n\t\t\tcontext.requestFullScreen();\r\n\t\t}\r\n\t},\r\n\t// 视频层级较高，为防止遮挡其他特殊定位元素，造成界面异常，\r\n\t// 强制全屏播放\r\n\tvideoPlay(e) {\r\n\t\twepy.createVideoContext(e.currentTarget.id).requestFullScreen();\r\n\t},\r\n\t// 退出全屏则暂停\r\n\tvideoFullscreenChange(e) {\r\n\t\tif (!e.detail.fullScreen) {\r\n\t\t\twepy.createVideoContext(e.currentTarget.id).pause();\r\n\t\t}\r\n\t}\r\n}开源最后贴一下「WePY HTML」的项目仓库： https://github.com/beiliao-web-frontend/wepy-html ，具体使用方法见项目内的 README 。如果你在使用过程中遇到了问题，或者是有好的建议和意见，都可以在 Issues 中提出。"}
{"title": "小程序无限层级路由方案 ", "author": "Rolan", "time": "2018-9-19 00:21", "content": "小程序无限层级路由方案小程序原生页面存在层级限制，超过一定层数就会无法打开新页面。一开始这个限制为不超过5层，目前是不超过10层。这个限制对于体量较大的小程序来说，挺难受的。特别是只能打开5层那会儿，业务流程很容易一不小心就超了，比如：首页-搜索结果页-商品详情页-聊天页-下单页-地址选择页-...；更有访问回路防不胜防，比如：商品详情页-查看更多页-商品详情页-查看更多页-...、商品详情页-聊天页-个人主页-商品详情页-聊天页-个人主页-商品详情页-...、诸如此类。即使后来放宽至了10层，还是很容易遭遇层级溢出。一种处理思路是调整交互路径，严格控制层级数量。但是这种处理方案，一则很多时候会牺牲用户体验，比如为避免个人主页和商品详情页的访问回路，要么不能在个人主页中访问用户商品，要么不能在商品详情页中访问卖家主页，要么访问时需要替换当前不能返回继续浏览，不管怎么取舍都会牺牲某些用户的浏览诉求；二则维护成本特别高，业务逻辑越来越复杂，交互路径越来越发散，路径的统一梳理和规划就会越来越困难，而且管理过程对业务不透明，业务方在设计需求时要受到交互路径的种种限制，甚至一个需求的交互调整很可能无意中造成另一个需求层级溢出，维护成本高且不断膨胀。因而本文考虑并实现了另一种处理思路：在小程序中支持不限层级的路由过程。策略修改小程序默认导航行为，自行维护完整历史记录页面层级小于等于10时，导航行为与原生导航行为一致请求打开第11层及以上时，逻辑层级记录完整历史，实际层级每次都是直接将第10层替换为目标页面返回时，逻辑层级相应回退；若回退后逻辑层级大于等于10，则实际层级将第10层替换为目标页面，否则实际层级回退到相应页面demo:  逻辑层级 1 - 2 - ... - 8 - 9 - 10\r\n  实际层级 1 - 2 - ... - 8 - 9 - 10\r\n  \r\n  打开\r\n  \r\n  逻辑层级 1 - 2 - ... - 8 - 9 - 10 - 11\r\n  实际层级 1 - 2 - ... - 8 - 9 - 11\r\n  \r\n  打开，打开，打开\r\n  \r\n  逻辑层级 1 - 2 - ... - 8 - 9 - 10 - 11 - 12 - 13 - 14\r\n  实际层级 1 - 2 - ... - 8 - 9 - 14\r\n  \r\n  返回\r\n  \r\n  逻辑层级 1 - 2 - ... - 8 - 9 - 10 - 11 - 12 - 13\r\n  实际层级 1 - 2 - ... - 8 - 9 - 13\r\n  \r\n  返回，返回，返回\r\n  \r\n  逻辑层级 1 - 2 - ... - 8 - 9 - 10\r\n  实际层级 1 - 2 - ... - 8 - 9 - 10\r\n  \r\n  返回\r\n  \r\n  逻辑层级 1 - 2 - ... - 8 - 9\r\n  实际层级 1 - 2 - ... - 8 - 9实现转转 实现了上述策略，并提供开源使用，地址：https://github.com/zhuanzhuanfe/fancy-mini，欢迎使用或参阅。主要难点及实现方案：如何接管路由过程要求所有页面不使用<navigator>元素，统一使用js触发跳转要求所有页面不直接调用wx.navigateTo、wx.redirectTo等路由相关接口，统一改用模块封装的相应接口如何监听返回行为统一监听页面的onUnload函数，结合路由过程判断是否用户返回如何兼容系统交互问题：系统交互会跳出正常路由流程，并且难以接管或监控，如：用户点击右上角返回主页按钮、用户切后台后又从其它入口进入、用户强制关闭小程序进程等处理：引入校正机制，在合适的时机根据系统路由栈对自行维护的路由栈进行校正。这样可以保证10层以内路由正确性。系统交互多是回到第1层，会被成功校正。如何避免/兼容代码疏漏问题：接管&监听过程要求所有页面遵循一些编码约束，如何保证这些约束切实全面生效；万一有页面未遵循约束，能否依然保证健壮性处理1：编写并配置相应eslint规则，保证约束被切实遵循处理2：上一条中的校正机制，保证即使有代码疏漏，在10层内也会被校正；10层外可能会影响返回逻辑正确性，但一般不会造成页面功能问题。如何进行状态恢复问题：返回后逻辑层级大于等于10时，实际是在第10层重新载入目标页面；用户在前一页面的表单输入等状态信息并不会像系统返回一样正常保留处理：在合适的时机存储页面的data，返回时予以恢复成本接入成本需要引入并配置路由模块需要检查并修改项目中所有页面跳转过程，统一使用模块封装的接口需要统一监听所有页面的onUnload函数维护成本新增页面跳转过程，需统一使用模块封装的接口新增页面onUnload函数需接入统一监听性能成本模块执行逻辑相对简单，内存开销相对较小，页面性能暂未发现明显损耗收益无限层级避免复杂/循环访问导致页面无法打开可以放心地向用户提供适合的访问入口，不必过分担心路径限制完全的路由管控能力可以完全监控路由过程并实现或引入一些附加功能附加功能：实例覆盖自动恢复问题：wepy框架存在单实例问题，同一路径页面被打开两次时，其数据会相互影响，如：详情页A - 详情页B - 返回A，点击查看大图 - B的图片（而不是A的图片）  详见issue：[两级页面为同一路由时，后者数据覆盖前者](https://github.com/Tencent/wepy/issues/322)\r\n  - 策略：返回时，若判断目标页面数据已被覆盖，则自动予以恢复\r\n  - 引入：参见模块使用说明附加功能： 免并发- 问题：用户连续快速点击多个/多次按钮时，会一次性打开多个窗口，一则造成层级膨胀，二则影响浏览体验\r\n- 策略：第一次点击造成的跳转完成之前无视后续点击产生的跳转请求\r\n- 引入：参见模块使用说明附加功能：数据预先加载- 问题：小程序的page1跳转到page2，到page2的onLoad是存在一个300ms ~ 400ms的延时的，在page2的onLoad中才开始获取数据会浪费这个延时\r\n- 策略：在 page1 中预先拿取数据，然后在 page2 中直接使用数据；wepy框架对此有良好的实现，参见[WePY 在小程序性能调优上做出的探究](https://segmentfault.com/a/1190000008975448?winzoom=1) \r\n- 引入：参见模块使用说明\r\n效果无限层级路由方案已在 转转二手交易网 小程序中应用了很长一段时间，欢迎体验：无限层级路由方案已被抽离封装成独立开源模块，欢迎直接使用：https://github.com/zhuanzhuanfe/fancy-mini"}
{"title": "WePY - 小程序敏捷开发实践丨掘金开发者大会 ", "author": "Rolan", "time": "2018-9-20 00:14", "content": "本主题虽然在其它地方讲了很多次，但还是有非常多新内容。因为很多东西正在做或者想要做。本次分享主要分为以下几个部分：WePY 的介绍WePY 的用户上面展示的 WePY 用户不是全部的数据。因为没有办法让 WePY 用户主动上报自己在使用 WePY，所以我只列了我知道的在使用 WePY 的公司，数据比较有限。就我所知道的，最近有一个刷爆朋友圈的小程序 —— 腾讯疫苗，前端采用的 WePY，后端用了腾讯开源的 TARS 项目。微信支付内部也有大量小程序在使用 WePY 框架。右边贴的聊天记录是我在 WePY 交流群收集到的用户反馈，就反馈的内容来看，有很多感谢的话，说明 WePY 这个框架确实能帮助开发者提高自己的开发效率。嘿嘿，我没有贴 WePY 的负面反馈，因为我担心一页 PPT 不够贴 :eyes:。WePY 的数据WePY 项目在 Github 上现在有13900多个 Star。拿其它前端框架对比，Vue、React 等 Star 数可能达到了 10W+，但是它们都是国际的项目。WePY 这个项目由于微信小程序的原因，算是一个国内项目，能有13000多个 Star 还是相当不错的。Star 数多不一定代表 WePY 这个框架好，但是能表明小程序这块流量很大，开发小程序也非常有前景。 开发者们需要 WePY 这样的框架来提供帮助。这也是为什么后来出现了 Taro、mpvue 等类似的非常优秀的框架。issues 目前有1300多个。这意味着我每天起床都有超过10条 to-do list 需要处理。加上每天还有公司的其它事情需要处理，比较头大。pull requests 目前有320多条。相比其它开源项目，这个 PR 数量相当不错，非常感谢为 WePY 作贡献的开发者们。用户数有4000多。这个数据的来源我是统计的我建立的 WePY 交流群，目前这个交流群里有 4000 多人。WePY 是什么将 Web App 和小程序进行对比。Web App 和小程序在功能上类似， Web App 在开发的时候，可能使用 Vue.js 作为其核心库，用 Webpack 进行打包。在微信小程序中，大家可以简单的将 WePY 理解为 Web App 里的 Vue.js + Webpack 的合体。WePY 的特点WePY 在开发中到底帮助开发者做了什么事情呢？WePY 又有哪些特点呢？脚手架：它提供了一个相当于 vue-cli 的脚手架，一行命令生成简单的 demo 项目。用户可以基于这个 demo 进行开发，省去了启动项目前繁琐的配置。编译打包：原生开发小程序缺失了许多能力，比如 LESS、SASS。很多用户面对这个问题都是做一个简单的 Gulp 编译。WePY 自带了编译打包能力，想用 LESS、SASS、NPM 等可以直接使用 WePY 的打包工具输出小程序可以运行的代码。核心库：核心库类似 Vue、React 等。WePY 核心库包含一些简单的 API 封装帮助处理一些事情。特性与优化：开发上，WePY 提供了一些语法糖，可以简单方便的实现一些复杂功能。性能上，小程序本身的性能有一些问题，WePY 把性能上的问题抹平了，开发者不用关心性能这部分。复用与扩展：复用方面，原生小程序使用 npm 资源需要将相对应的资源下载并放到代码目录中，利用 WePY 可以直接安装 npm 包并使用。扩展方面，在编译过程中，可以随意添加和扩展编译手段，比如 LESS、SASS、编译插件等。多端：利用 WePY 可以将一份代码运行在小程序、H5 等端。WePY 的规划16年8月参加小程序内测，10月份开始着手代码转换相关的工作。在不停的迭代中，我发现还有很多事情可以做。比如可以将相关的工作抽象出来提供给其它开发者。于是在11月我对代码进行了重构，将 Gulp 编译部分抛弃重写并于 Github 开源1.1版本。开源之后有很多人关注到这个项目，说明还是有不少人遇到了相应的问题。因此我做了更加具体的优化，在1.1版本上又一次重构，把编译流程抽象，提出了编译器和插件两个概念，方便用户进行扩展。17年1月份发布1.4版本，对整个开发流程和开发者使用框架时的体验进行了更多优化，包括性能优化等。1.6 版本开始考虑多端问题：小程序一套代码多端复用。17年11月左右，小程序推出了原生组件。WePY 本身就是为了解决小程序组件的问题，原生组件发布之后，WePY 的使用场景就没有以前那么强了，所以我开始思考， WePY 需要做一个完全重构的版本。18年2月份启动了该重构版本，这个版本主要是为了解决小程序原生组件相关的问题，是一个全新的重构版本。但由于各种原因，这个版本还没有正式公布。敬请期待！WePY 的实现原理接下来我会讲一下 WePY 在技术上的实现原理。WePY 解决的问题任何一个项目都是发现问题，解决问题的过程，WePY 要解决的问题就是：组件化开发：小程序原生组件出现之前，小程序没有很好的组件化开发模式。比如我自己实现了一套 dialog，别人想使用的时候可能要把我的代码拷贝一份。实现了组件化之后，我只要把这个组件给他就好了。npm 资源：Web 发展至今，npm 库上有非常庞大的资源。但是原生小程序没有使用 npm 资源的能力，WePY 提供了这个功能。前端工程化：前面提及的打包构建部分性能优化友好的开发体验：体验优化跨平台支持：多端这部分总的来说，WePY 解决的问题就是开发中遇到的痛点问题。WePY 的架构上面是我写的两个核心的部分：CLI 以及 Core。Core 通过 CLI 编译，生成小程序端运行的代码。CLI 部分又分为 wepy、wepy-web ，分别负责 wepy 的编译和 wepy-web 的编译。其上又分为编译器和插件两部分，编译器涉及到目前主流的预处理器，类似 Webpack 的 loader 。插件是在编译之后要做的事情，类似于 Webpack 的 plugin。Core 部分分为 wepy 核心库、小程序核心库和 wepy-web 核心库。wepy-web 核心库比小程序多了 wepy components 和 wepy API 。小程序本身的一些内置组件，比如弹窗组件，想要多端运行都需要封装起来放在 wepy components 。小程序原生 API 需要通过 wepy API 封装。web 本身还分很多平台种类，比如 browser、微信 h5、QQ h5，这些都需要分别适配，所以 wepy-web 之上是一个适配层。整个 Core 之上，是用户封装的一些组件，比如上报、异步。还有一些功能组件，比如用户做的弹窗、toast、imageloader 等。纵观整个 WePY，我的代码会通过 CLI 基于 Core 输出小程序端运行的代码。WePY 的编译过程WePY 本身定义了一个文件后缀 .wpy 。编译时将该文件解析并拆分为 Style、Template、Script。拆分时，会解析并记录组件关系，包括事件、引用等。每个节点的信息都会被记录，在注入时生成到 JS 中，在 JS 中就可以知道组件关系并进行调用。生成完之后进入到 plugin，plugin 是用户自定义的，需要进行图片压缩、JS 混淆、wxml 压缩等处理。依次做完这些处理之后才会得到可以在小程序中运行的代码。以上就是 WePY 的整个编译过程。多端的实现在实现多端方面，面临着以下问题：开发模式小程序开发模式自成一派，与现有开发模式都不相同。好在使用 WePY 开发时，WePY 使用的是类 Vue 的开发语法，跟 Vue 开发模式很贴近，所以开发模式问题借助 WePY 非常好解决。标签与样式小程序与 H5 的标签不一样，但是可以直接做一些简单的转换处理。比如 <view> 转换为 <div> 。样式上小程序有一个 rpx 单位，在 750 px 的情况下直接 /2 将 rpx 转为 px。模版语法小程序有自己的模版语法，比如 <wx-if> 等，解析时可以做简单的转换。模块化小程序原生可以使用 require ,但是H5不可以。好在有很多工具值得借鉴，比如 webpack,browserify。内置组件及内置 APIWePY 本身使用的是类 Vue 的语法，要转换为 Vue 运行在 Web 端的话，内置组件直接使用 Vue 的形式编写，使用时直接引入这个 Vue 组件。内置 API 使用 WePY 提供的 JSSDK 去模拟微信端、H5等提供的 API。因此，多端实现完全可行。我们的一些项目完全利用 WePY 实现多端。生态左边是在 Github 上看到的一些 UI 库，大家在使用 WePY 开发的时候可以直接利用这些 UI 库进行二次开发。右边是网上收集到的开发资源，包括开发组件、第三方模块等。Github 上 WePY 关键字搜索结果有900多页。从用户反馈来看，用户选择 WePY 的一个原因也是 WePY 诞生的时间长，生态比较完善。WePY 的规划现有问题WePY 目前存在的核心问题是静态组件编译WePY 项目做的比较仓促，花了大概一个多月就上线了。最开始只是为了解决组件化的问题。因此它采用了静态组件编译这套方案，在编译组件时，直接将我写的组件进行静态替换，将我写的组件注入到页面中，做了一些隔离相关的事情。这导致动态 repeat 时会出现比较严重的 BUG。这是设计上的缺陷，也是急需解决的问题。语法解析xml 的解析用了一个存在问题的库，导致 xml 解析时经常出错。js 的解析设计之初没有考虑用语法树解析，而是使用正则进行解析。因为目前仅涉及解析和语法注入，实现起来都比较简单，所以没有考虑用 AST 语法树进行解析，导致用户没有按照规范写的一些代码在解析时会出现错误。类 Vue 语法从用户的反馈来看，大家更希望用 Vue 的语法而不是类 Vue 语法。这两个之间还是有一些差异的。数据绑定性能优化数据绑定时做了一些优化和处理。但这些优化和处理是通过脏数据进行的，帮助用户减少 setDate 的次数。但是后来再看，这块还是有可以优化的空间。错误处理机制目前 WePY 的错误处理还比较简单，没有一个通用的错误处理机制。用户在使用和编译时的报错很难追溯和定位。后面希望能做到在报错时可以定位到报错的文件和代码。测试用例覆盖度WePY 目前只有核心库被测试用例覆盖。CLI 部分很复杂没有做测试用例覆盖。这导致目前大部分问题都和 CLI 相关。在下一个版本要全部被测试用例覆盖。编译上图是2.0版本编译部分的对比。左边是 1.0 的编译，右边是2.0正在做的事。前面有讲到1.0的编译是把.wpy 文件放到 CLI 中进行编译。CLI 本身涉及编译器和插件。在2.0中，将文件编译修改为了入口编译，从 App 入口，通过 CLI 自动解析依赖，CLI 中也只有插件，所有的核心功能都将通过插件实现。最后生成的除了小程序文件，还有 Vendor 文件（Vendor 文件是指所有的 npm 包都会打包到这个文件内）、资源文件以及自己引用的模块的文件。插件化编译的核心部分是参考 Webpack 做的插件化编译。插件化的概念参考我上面做的图：固定一块板子，板子上有固定数量的挂钩，每个挂钩都可以挂不同的东西。每个挂钩放什么不清楚，但是每个挂钩都可以实现不同的功能。我只需要规定编译的流程，通过在挂钩中写不同的内容实现整个编译流程。所以整个编译过程变为：配置初始化:arrow_right:核心编译:arrow_right:输出文件。插件化可以提供更高的扩展性和可复用性。所有的核心功能都依赖插件进行。用户觉得某个功能不合适的时候，完全可以自己写一个插件替换掉核心功能。用户可以对编译的任何一个环节进行修改。数据绑定v1v1 的数据绑定：在初始化的时候对数据进行深拷贝做数据备份。每个流程都会预置 apply 动作，比如有一个点击事件，点击事件对数据进行修改后进入到 apply 流程，在 apply 流程中进行深比较得到脏数据，脏数据最终进入到 setDate 中。右边是比较简单易懂的图：小明对文件 B 进行修改得到 B+,老师将 B+ 和 B 进行对比，得到修改的数据。这是一个同步流程。当小明叫小红修改 C 文件时，如果老师不再，需要小红主动叫老师对 C 文件进行对比。即手动调用 apply 流程。数据绑定v22.0 使用了 Vue 的数据绑定机制。在初始化时生成 Render Watcher，每个数据初始化时都会添加 observer。修改数据时记录修改的 key-path 并加入队列中，所有的修改动作都会触发 Watcher。在一个 nextTick 时间内会清空队列，并在 Render Watcher 中进行 setDate。setDate 环节根据记录的 key-path 进行 setDate。相比小明和老师的故事：小明在修改文件时会主动记录修改的内容并发起通知，小红的操作方式与小明一致。当老师收到通知时，根据小明、小红的修改记录对修改的内容进行 setDate 的处理。这种优化方式不需要手动调用 apply,也不需要关心异步流程。质量第二个版本会先在内部项目运用，内部实践之后没有问题再开源。另外2.0版本测试用例覆盖度要完全覆盖。开源经验分享规范如何保证开源项目的质量？第一是文档规范。Readme 部分要言简意赅的讲明这个项目能做什么，一个简单的示例说明如何启动项目。Readme 要简洁，大家一眼能看到他想要的东西。第二是 CI。将对应的状态放在 Readme，让开发者可以更安心的使用这个项目。第三是 license。还有 contributer 文档，代码规范、Git 规范等。测试使用了 Mocha 和 Istanbul，集成使用了 TravisCI，部署使用了 npm 和 lerna。推广运营推广运营方面主要靠自己发文章，做外链。另外我在公众号和微信群推了自己的文章。微信群做了一个机器人放入群码。还做了文档监控，官方文档修改之后，我可以第一时间知道官方文档都修改了什么。以及监控报告，每天都会给我的微信推送今天项目有多少 star 、多少 issue 。"}
{"title": "微信小程序开发教程第五章：名片夹详情页开发 ", "author": "admin", "time": "2016-10-12 22:39", "content": "先看下「名片盒」详情页的效果图：备注下大致需求：顶部背后是轮播图，二维码按钮弹出模态框信息、点击微信栏、点击存入手机，地址栏需要地图展示，名片分享也是模态框指引。首先是轮播图，autoplay 自动播放，interval 轮播的时间，duration 切换速度，可以根据自己需求去添加。Delete：是删除按钮，加载进来是隐藏的，需用户点轮播图进去后，轮播图全屏显示才出来。noClickImg 与 ClickImg：切换全屏与非全屏轮播图，绑定了点击事件 changeClick 来切换，只是改变样式即可。Block：图片列表。Number_img：当前轮播 index（currentNumber），与图片 length 集合（cardnum）。其中 currentNumber：//轮播图发生改变时改变数字//初始化数据Data:{currentNumber:1}slidechange:function(e){var number = e.detail.current;this.setData({currentNumber:number+1})},这里可以看到全屏状态下当关闭按钮被点击后 getBackStyle，把 changeClick 切换到 imgFullScrenn 待命。再次点击返回原样式，切换后事件又走回到 getBackStyle 了，灵活运用。刷新下开发者工具可以看到具体效果如下：详情页可以看到信息基本都是样式一样，可以使用微信提供的循环 block。下面是详情页里面的个人信息数据，如果有信息就显示出来，没有数据的不显示，这里使用//中文信息               var chinaMessage = res.card.groups[0].fields;var personMessage= []               for(var i = 0;i                personMessage.push(chinaMessage[i])               }               //为空或者null是不显示判断              for(var k in personMessage){                if(personMessage[k].value==null || personMessage[k].value==\"\"){                personMessage[k][\"display\"] = \"none\";                }else{                personMessage[k][\"display\"] = \"block\";                }               }具体以 json 数据格式来处理，我们需要做的就是给它绑定 display 的值，然后我们调用即可。微信此版本的 setData 不支持异步更新数据，故而我们在发生真实网络数据请求时一定要在后面加上 forceUpdata()，强制触发视图渲染，否则会出现很多莫名其妙的 bug。这里说明下：如是服务器真实数据。可以看到会报错，可能是 js 的执行顺序，依次往下走，此时网络数据还在请求中。定义一个变量即可。当然这里的数据都是 push 上来的。以下是二维码弹出信息。这是弹出模态框二维码信息，布好局初始化是none状态。那里需要它直接绑定数据即可：This.setData({//模态框名字:”显示？隐藏”})方法是让它显示。需要用他的地方调用方法即可。(支持重复调用)详情页公司位置地图直接调用微信提供的接口实现（群里的 demo 有实现方式）。可以看下实现的效果："}
{"title": "微信小程序开发教程第六章：「名片盒」「我」的页面开发 ", "author": "admin", "time": "2016-10-12 22:46", "content": "效果图与需求：用户有多张名片，需要左右切换查看，往下切换是菜单按钮。这里需求两处滑动，用到了微信提供给我们的滑动组件 swiper，并且进行了嵌套使用，第一层是名片展示与菜单按钮的上下滑动，第二层是名片展示的左右滑动（支持互相嵌套使用的，可以放心使用）。Vertical 加上就是纵向滑动，去掉即是左右滑动。整体结构如下所示：点击事件绑定的是数据切换方式，因为需要支持多次点击切换。初始化数据是 nextSlide：再看下 nextSlide 事件。currentSlide 是当前页面的 index，改变它即可完成切换效果，可以看上图初始化数据时设置了 cs 是 0。因而赋值当前 data.cs+1 即可，再把绑定点击事件 clickNext 切换成 nextSlideAgain。再看下 nextSlideAgain 事件，执行的减去 1 个索引，实现多次点击切换效果。具体效果可以看到。点击个人名片进去编辑名片页面，由于需要带参，故而使用的是 wx.navgateTo。可以看下效果：最后上点干货：我们发出第一篇教程的时候有人就注意到这点了，怎么做真实数据交互，下面大家可以了解下。首先进去是 MD5 加密，requster 交互层。怎么引用 MD5.js？当然是模块化 require，被引用的 js 不要忘记 module.exports 出来。下面是 requester.js 引用 MD5.js。ApplicationRoot 是服务器地址（配置服务器时在开发设置页面查看 AppID 和 AppSecret，配置服务器域名）。Require.js 这里 module.exports 是暴露方法出去。这时候在全局 app.js 里面引入 require.js 映射到全局 global，这个 global 是全局的。这时候那个页面需要那个页面就直接去接受吧，模块化是不是很好用？可以完整的看下与后台做数据交互的一个请求实现方式如下：图一是 requester.js 里面的封装。图二是需要调用数据的页面渲染。"}
{"title": "微信小程序开发教程第一章：微信小程序开发实操指南 ", "author": "admin", "time": "2016-10-12 22:49", "content": "序言开始开发应用号之前，先看看官方公布的「小程序」教程吧！（以下内容来自微信官方公布的「小程序」开发指南）本文档将带你一步步创建完成一个微信小程序，并可以在手机上体验该小程序的实际效果。这个小程序的首页将会显示欢迎语以及当前用户的微信头像，点击头像，可以在新开的页面中查看当前小程序的启动日志。1. 获取微信小程序的 AppID首先，我们需要拥有一个帐号，如果你能看到该文档，我们应当已经邀请并为你创建好一个帐号。注意不可直接使用服务号或订阅号的 AppID。 利用提供的帐号，登录 https://mp.weixin.qq.com ，就可以在网站的「设置」-「开发者设置」中，查看到微信小程序的 AppID 了。注意：如果我们不是用注册时绑定的管理员微信号，在手机上体验该小程序。那么我们还需要操作「绑定开发者」。即在「用户身份 - 开发者」模块，绑定上需要体验该小程序的微信号。本教程默认注册帐号、体验都是使用管理员微信号。2. 创建项目我们需要通过开发者工具，来完成小程序创建和代码编辑。开发者工具安装完成后，打开并使用微信扫码登录。选择创建「项目」，填入上文获取到的 AppID，设置一个本地项目的名称（非小程序名称），比如「我的第一个项目」，并选择一个本地的文件夹作为代码存储的目录，点击「新建项目」就可以了。为方便初学者了解微信小程序的基本代码结构，在创建过程中，如果选择的本地文件夹是个空文件夹，开发者工具会提示，是否需要创建一个 quick start 项目。选择「是」，开发者工具会帮助我们在开发目录里生成一个简单的 demo。项目创建成功后，我们就可以点击该项目，进入并看到完整的开发者工具界面，点击左侧导航，在「编辑」里可以查看和编辑我们的代码，在「调试」里可以测试代码并模拟小程序在微信客户端效果，在「项目」里可以发送到手机里预览实际效果。3. 编写代码点击开发者工具左侧导航的「编辑」，我们可以看到这个项目，已经初始化并包含了一些简单的代码文件。最关键也是必不可少的，是 app.js、app.json、app.wxss 这三个。其中，.js 后缀的是脚本文件，.json 后缀的文件是配置文件，.wxss 后缀的是样式表文件。微信小程序会读取这些文件，并生成小程序实例。下面我们简单了解这三个文件的功能，方便修改以及从头开发自己的微信小程序。app.js 是小程序的脚本代码。我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。调用 MINA 提供的丰富的 API，如本例的同步存储及同步读取本地数据。```//app.jsApp({onLaunch: function () {// 调用 API 从本地缓存中获取数据var logs = wx.getStorageSync('logs') || []logs.unshift(Date.now())wx.setStorageSync('logs', logs)},getUserInfo:function(cb){var that = this;if(this.globalData.userInfo){typeof cb == \"function\" && cb(this.globalData.userInfo)}else{// 调用登录接口wx.login({success: function () {wx.getUserInfo({success: function (res) {that.globalData.userInfo = res.userInfo;typeof cb == \"function\" && cb(that.globalData.userInfo)}})}});}},globalData:{userInfo:null}})```app.json 是对整个小程序的全局配置。我们可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口 背景色，配置导航条样式，配置默认标题。注意该文件不可添加任何注释。```{\"pages\":[\"pages/index/index\",\"pages/logs/logs\"],\"window\":{\"backgroundTextStyle\":\"light\",\"navigationBarBackgroundColor\": \"#fff\",\"navigationBarTitleText\": \"WeChat\",\"navigationBarTextStyle\":\"black\"}}```app.wxss 是整个小程序的公共样式表。我们可以在页面组件的 class 属性上直接使用 app.wxss 中声明的样式规则。```/**app.wxss**/.container {height: 100%;display: flex;flex-direction: column;align-items: center;justify-content: space-between;padding: 200rpx 0;box-sizing: border-box;}```### 4. 创建页面在这个教程里，我们有两个页面，index 页面和 logs 页面，即欢迎页和小程序启动日志的展示页，他们都在 pages 目录下。微信小程序中的每一个页面的【路径 + 页面名】都需要写在 app.json 的 pages 中，且 pages 中的第一个页面是小程序的首页。每一个小程序页面是由同路径下同名的四个不同后缀文件的组成，如：index.js、index.wxml、index.wxss、index.json。.js 后缀的文件是脚本文件，.json 后缀的文件是配置文件，.wxss 后缀的是样式表文件，.wxml 后缀的文件是页面结构文件。index.wxml 是页面的结构文件：```{{userInfo.nickName}}{{motto}}```本例中使用了 、、 来搭建页面结构，绑定数据和交互处理函数。index.js 是页面的脚本文件，在这个文件中我们可以监听并处理页面的生命周期函数、获取小程序实例，声明并处理数据，响应页面交互事件等。```//index.js// 获取应用实例var app = getApp()Page({data: {motto: 'Hello World',userInfo: {}},// 事件处理函数bindViewTap: function() {wx.navigateTo({url: '../logs/logs'})},onLoad: function () {console.log('onLoad')var that = this// 调用应用实例的方法获取全局数据app.getUserInfo(function(userInfo){// 更新数据that.setData({userInfo:userInfo})})}})```index.wxss 是页面的样式表：```/**index.wxss**/.userinfo {display: flex;flex-direction: column;align-items: center;}.userinfo-avatar {width: 128rpx;height: 128rpx;margin: 20rpx;border-radius: 50%;}.userinfo-nickname {color: #aaa;}.usermotto {margin-top: 200px;}```页面的样式表是非必要的。当有页面样式表时，页面的样式表中的样式规则会层叠覆盖 app.wxss 中的样式规则。如果不指定页面的样式表，也可以在页面的结构文件中直接使用 app.wxss 中指定的样式规则。index.json 是页面的配置文件：页面的配置文件是非必要的。当有页面的配置文件时，配置项在该页面会覆盖 app.json 的 window 中相同的配置项。如果没有指定的页面配置文件，则在该页面直接使用 app.json 中的默认配置。**logs 的页面结构**```{{index + 1}}. {{log}}```logs 页面使用 控制标签来组织代码，在 上使用 wx:for-items 绑定 logs 数据，并将 logs 数据循环展开节点//logs.jsvar util = require('../../utils/util.js')Page({data: {logs: []},onLoad: function () {this.setData({logs: (wx.getStorageSync('logs') || []).map(function (log) {return util.formatTime(new Date(log))})})}})运行结果如下：5. 手机预览开发者工具左侧菜单栏选择「项目」，点击「预览」，扫码后即可在微信客户端中体验。目前，预览和上传功能尚无法实现，需要等待微信官方的下一步更新。如你所见，微信官方给出的开发指南还非常简单，很多细节、代码和功能都没有明确的展示，所以接下来就到博卡君展示实力的时候啦！开发教程正式开始！第一章：准备工作做好准备工作很重要。开发一个微信应用号，你需要提前到微信的官方网站（weixin.qq.com）下载开发者工具。* 下载最新微信开发者工具，打开后你会看到该界面：* 点击「新建 web+」项目，随后出现如下画面：* 该页面内的各项内容需要注意——* AppID：依照官方解释来填。* Appname: 项目最外层文件夹名称，如你将其命名为「ABC」，则之后的全部项目内容均将保存在「/ABC/…」目录下。* 本地开发目录：项目存放在本地的目录。注：再次强调，如果你和团队成员共同开发该项目，则建议你们使用同样的目录名称及本地目录，以确保协同开发的统一性。如果你之前已有项目，则导入过程与以上内容近似，不再赘述。* 准备工作全部完成后，点击「新建项目」按钮，弹出框点「确定」。* 如上图所示，此刻，微信开发者工具已经为你自动构建了一个初始的 demo 项目，该项目内包含了一个微信应用项目所需具备的基本内容和框架结构。点击项目名称（图中即「cards」）进入该项目，就能看到整个项目的基本架构了："}
{"title": "微信小程序开发教程第二章：项目构架 ", "author": "admin", "time": "2016-10-12 23:08", "content": "微信目前用户群体非常庞大，微信推出公众号以后，火爆程度大家都看得到，也同样推动着 h5 的高速发展，随着公众号业务的需求越来越复杂，应用号现在的到来也是恰到好处。我们团队具体看了一两次文档后发现，它提供给开发者的方式也在发生全面的改变，从操作 DOM 转为操作数据，基于微信提供的一个过桥工具实现很多 h5 在公众号很难实现的功能，有点类似于 hybrid 开发，不同于 hybrid 开发的方式是：微信开放的接口更为严谨，结构必须采用他提供给我们的组件，外部的框架和插件都不能在这里使用上，让开发者完全脱离操作 DOM，开发思想转变很大。工欲善其事，必先利其器。理解它的核心功能非常重要，先了解它的整个运作流程。生命周期：在index.js里面：开发者工具上 Console 可以看到：在首页 console 可以看出顺序是 App Launch-->App Show-->onload-->onShow-->onReady。首先是整个 app 的启动与显示，app 的启动在 app.js 里面可以配置，其次再进入到各个页面的加载显示等等。可以想象到这里可以处理很多东西了，如加载框之类的都可以实现等等。路由：路由在项目开发中一直是个核心点，在这里其实微信对路由的介绍很少，可见微信在路由方面经过很好的封装，也提供三个跳转方法。* wx.navigateTo(OBJECT)：保留当前页面，跳转到应用内的某个页面，使用wx.navigateBack可以返回到原页面。* wx.redirectTo(OBJECT)：关闭当前页面，跳转到应用内的某个页面。* wx.navigateBack()：关闭当前页面，回退前一页面。这三个基本上使用足够，在路由方面微信封装的很好，开发者根本不用去配置路由，往往很多框架在路由方面配置很繁琐。组件：此次微信在组件提供方面也是非常全面，基本上满足项目需求，故而开发速度非常快，开发前可以认真浏览几次，开发效率会很好。其它：任何外部框架以及插件基本上无法使用，就算原生的 js 插件也很难使用，因为以前我们的 js 插件也基本上全部是一操作 dom 的形式存在，而微信应用号此次的架构是不允许操作任何 dom，就连以前我们习惯使用的动态设置的 rem.js 也是不支持的。此次微信还提供了 WebSocket，就可以直接利用它做聊天，可以开发的空间非常大。跟公众号对比我们发现，开发应用号组件化，结构化，多样化。新大陆总是充满着惊喜，更多的彩蛋等着大家来发现。接下来开始搞一些简单的代码了！* 找到项目文件夹，导入你的编辑器里面。在这里，我使用了 Sublime Text 编辑器。你可以根据自己的开发习惯选择自己喜欢的编辑器。* 接下来，你需要根据自己的项目内容调整项目结构。在范例项目中，「card_course」目录下面主要包含了「tabBar」页面以及该应用的一些配置文件。* 示例项目的「tabBar」是五个菜单按钮：* 找到「app.json」文件，用来配置这个五个菜单。在代码行中找到「tabBar」：* 你可以根据实际项目需求更改，其中：* 「Color」是底部字体颜色，「selectedColor」是切换到该页面高亮颜色，「borderStyle」是切换菜单上面的一条线的颜色，「backgroundColor」是底部菜单栏背景颜色。文字描述较为抽象，建议你一一调试并查看其效果，加深印象。* 「“list”」下的代码顺序必须依次放置，不能随便更改。* 「”pagePath”」之后的文件名内，「.wxml」后缀被隐藏起来了，这是微信开发代码中人性化的一点——帮你节约写代码的时间，无须频繁声明文件后缀。* 「”iconPath”」为未获得显示页面的图标路径，这两个路径可以直接是网络图标。* 「”selectedIconPath”」为当前显示页面高亮图标路径，可以去掉，去掉之后会默认显示为「”iconPath”」的图标。* 「”Text”」为页面标题，也可以去掉，去掉之后纯显示图标，如只去掉其中一个，该位置会被占用。注意：微信的底部菜单最多支持五栏（五个 icons），所以在你设计微信应用的 UI 和基本架构时就要预先考虑好菜单栏的排布。* 根据以上代码规则，我做好了示例项目的基本架构，供你参考：* 「Json」文件配置好后，「card_course」的基本结构入上图所示，不需要的子集都可以暂时删除，缺少的子集则需要你主动新建。删除子集时记得顺带检查一下「app.json」里的相关内容是否已经一并删除。注意：我个人建议你新建一个「wxml」文件的同时，把对应的「js」和「wxss」文件一起新建好，因为微信应用号的配置特点就是解析到一个「wxml」文件时，会同时在同级目录下找到同文件名的「js」和「wxss」文件，所以「js」文件需及时在「app.json」里预先配置好。编写「wxml」时，根据微信应用号提供的接口编码即可，大部分就是以前的「div」，而我们现在就用「view」即可。需要用其它子集时，可以根据微信提供的接口酌情选择。使用「class」名来设置样式，「id」名在这里基本没有什么用处。主要操作数据，不操作「dom」。* 以上是示例项目首页的「wxml」编码。从图中就可以看出，实现一个页面代码量非常少。* 「Wxss」文件是引入的样式文件，你也可以直接在里面写样式，示例中采用的是引入方式：* 修改代码后刷新一次，可以看到未设背景的「view」标签直接变成了粉色。注意：修改「wxml」和「wxss」下的内容后，直接 F5 刷新就能直接看到效果，修改「js」则需点击重启按钮才能看到效果。* 另外，公共样式可以在「app.wxss」里直接引用。* 「Js」文件需要在「app.json」文件的「”page”」里预先配置好。为了项目结构清晰化，我在示例项目中的「index」首页同级目录新建其它四个页面文件，具体如下：经过以上步骤，案例中的五个底部菜单就全部配置完毕了。"}
{"title": "微信小程序开发教程第三章：项目结构以及配置 ", "author": "admin", "time": "2016-10-12 23:22", "content": "找到创建的 demo 文件夹，把项目导入到你的编辑器，这里使用的是Sublime Text编辑器。这个时候需要根据自己的项目需求结构进行更改了，项目根目录下面是首页渲染的几个 tabBar 页面，以及 app 的一些配置文件，如名片盒项目的 tabBar 是 3 个切换菜单我们先找到 app.json 文件打开配置好这几个菜单，配置好 tabBar，这个直接把配置文件改成你自己设计的即可。App.json 里面有几个配置项：* Pages：这个是编写的js文件，后缀.js这里不需要使用，配置好正确路径即可正常调用（若调用不到，在重启微信开发者工具会直接报 page 错误）。* Window：配置顶部的一些样式，文档介绍比较详细。* tabBar：底部的几项配置，见名知意。* networkTimeout：暂时没发现用处，建议看文档。根据实际项目需求进行添加与更改。* iconPath和selectedIconPath：底部菜单按钮图片与得到切换点击高亮。* text：可以去掉，全部去掉会发现底部 tabar 高度会减少很多。 Json 文件配置好后，根据项目进行文件创建。Demo：存放的是假数据，这一期的开发工具支持 require，假数据使用的是 .js 文件形式，里面的数据结构 json 一致，把 data 暴露出去即可然后取数据 require 进来即可，这一点使用很方便；Images：图片路径；Page：除 tabar 以外的页面；Servise：服务交付层（与后台联调真实数据时使用）；Wxss：一些公共的 css 文件；看到这里大家发现每个页面都被连带好三个不同的后缀。分别页面，css，js 目前只能依照这样，是微信应用号的一个规范吧。Wxss 文件是引入你写的样式文件，也可以直接在里面写样式。Js 文件需全部配置到 pages 里面才能生效。"}
{"title": "微信小程序开发教程第四章：首页面开发 ", "author": "admin", "time": "2016-10-12 23:26", "content": "进行了各种准备与配置后，来到首页开发。首先需要实现首页效果图如下：Template 名片很多，需要用模板、这里需要微信提供的基础组件大致是 input（搜索框）、action-sheet（右边是个底部下拉菜单，需要下拉菜单）、Scroll-view (右边 ABC 跳转)、（这个目前实现还有点问题，正在攻克中）。View是块元素，整个搜索框的一个样式。* 名片夹：由于该项目主打名片功能，故很多地方使用，所以需要把名片以 template 分离出来。* Template：定义一个模板，name 模板的名字其实是个作用域。* Block：循环控制，名片很多，必须用循环出来，和很多操作数据的前端框架循环差不多。* 支持自定义属性 data，这里用作判断线上名片以及线下名片。* View 里面是一些数据引入，里面是支持三目运算符。引入 template 时非常方便，is 和 name 一样，data 是 nameData 传递过来的数据填充。一切都绑定数据为中心点。取到数据具体操作根据你数据结构：这里的数据结构和 json 数据结构一样，这里如要传到页面的话即是```this.setData({nameData:card_list_name.data.cards,timeData:card_list_time.data.cards});```因为页面遍历的是 nameData,timeData可以看下打印出来的数据结构，根据你的结构进行解析与传递。也可以看下这里对数据的一些操作。（这里须根据定义的 json 数据格式来操作的）名片的样式由于很多页面需要使用放在 common.css 里面，这个 common.css 是所有页面都需要用到，一些初始化设置。它是在 app.wxss 里面引用之后才能被映射到全局 APP。搜索框：其中 bindChange 为输入框发生改变事件。微信提供的 bindchange 在支持方面还有小问题，目前是失去焦点才能触发到此事件的发生，待后续完善吧，先实现功能再说。在 index.js 里面写事件```bindInputChange:function(e){//发生搜索事情var self = this; //this绑定，这个this指向微信的提供windowvar Text = e.detail.value.toUpperCase(); //取到输入的内容if(Text==\"\"){ //如果输入为空 一些东西需要显示 否则不显示show_letter = \"block\";}else{show_letter = \"none\";}this.setData({show_letter:show_letter,showSheet:true});var res = nameData; 获取到传递的数据if(data_type==\"name\"){}else if(data_type==\"time\"){res = timeData; };for(var k in res){ //for-in循环取到data里面的cardsvar data = res[k].cards;for(var i = 0;iIf(data[i].userName!=null && data[i].userName.indexOf(Text)!=-1){data[i][\"display\"] = \"block\"; //存在就是赋值显示}else{data[i][\"display\"] = \"none\"; // 不存在赋值不显示}}}}```菜单栏：做到菜单栏，使用微信提供的下拉菜单组件 action-sheet，它被触发的条件在这里。一切以绑定事件为起点：```bindButtonTapSheet:function(e){//调取底部下拉菜单栏}```还是得先布好局才能被调动Js 配置：Data 初始化数据：这里得取非，直接设置 false 调不出来: 调用事件。调出来还得去掉它啊：如下相同即可取消直接上事件即可。（分为菜单栏外部与底部）//好了，就是这么简单。实现效果简单，体验效果确实非常不错。还需要个 loading 效果（暂时没做动画，后期再考虑。）Loading 布局首页的最外层 view根据微信的生命周期```Onload:function(e){this.setData({toastDisplay:”block”,htmlWrapDisplay:”none”})},onShow:function(e){this.setData({toastDisplay:”none”,htmlWrapDisplay:”block”})}```加载条完成。扫一扫，直接调用拍照功能，从这里看到微信提供的拍照 api 使用起来非常快速，只需根据需求配置即可。点击扫一扫之后，在开发者工具即可看到如下效果。做到这里说明下，dom 长度有限制，页面的结构太长，也是无法渲染的，暂且把公司排序暂时先去掉了。左边的 ABC 跳转（还在继续完善中）。这里还有个左滑删除名片功能，微信没有提供这个在移动端很实用的功能真的比较遗憾"}
{"title": "微信小程序开发教程第八章：分组开发与左滑功能实现 ", "author": "admin", "time": "2016-10-12 23:31", "content": "整体思路：进入分组管理页面-->点击新建分组新建进入到未分组页面基本操作进入到已建分组里面底部菜单栏操作-->从名片夹中添加进行操作。理清完基本流程我们开始开发。首先整个布局可以先看下，我再一步步讲。静态布号局后，我们开始实现新增分组效果，当然触发它出现的是显示窗口点击取消消失当里面的输入框内容发生改变时 bindinput 事件，大家别使用 bindchange 事件，这里的 bindchange 事件只有当失去焦点时才会被触发。当输入框事件发生时，确定按钮会变成可以点击状态，为空时，addTeam样式数据绑定。里面有表单就使用了 from。创建分组请求交互。创建分组完成，这里可能很多疑问，为什么不使用微信提供的模态框组件来实现，而是自己实现，其实我也很懒，非常想使用自带的模态框组件，但是发现在模态框里面提交表单好像有点麻烦，直接自定义了。接下来创建好的分组支持左滑删除与重命名，今天重点谈下左滑删除的实现方式。首先需要左滑的是被创建好的分组，未分组是写死的，故而不支持的。左滑删除使用了两个事件 bindtouchstart 与 bindtouchmove，这里必须绑定它的 id，这个 id 都是不同的，我这使用的用户创建完成后在后台生成的一个 id 号，之后我再 block 出来使用在这里，这个 id 都是唯一的，不能是相同的 id。样式布局，父元素是绝对定位，子元素删除是相对定位，鉴于动画效果，我这加了 css3 的动画效果，使滑动带点动画效果。现在我们来看事件构成：Bindtap 点击之后直接是跳转页面。左滑从触摸事件开始，当然需使用的参数在外面最好先定义一下：bindtouchStart 发生后，会执行 bindtouchmove 事件，在这里我们可以判断是否左右滑动：* Var dataId = e.currentTarget.id //获取到前面唯一的id；If(key){ //用户左滑距离很长时会发生多次左滑事件，这里定义一个开关发生第一次之后就关闭它；* Touch是获取触摸点的一些数据，touches 是一个触摸点的数组，每个触摸点包括以下属性：* pageX,pageY：距离文档左上角的距离，文档的左上角为原点 ，横向为 X 轴，纵向为 Y 轴；* clientX,clientY：距离页面可显示区域（屏幕除去导航条）左上角距离，横向为X轴，纵向为Y轴；* screenX,screenY：距离屏幕左上角的距离，屏幕左上角为原点，横向为X轴，纵向为Y轴；这里使用 clientX,clientY 即可。我们在 bindtouchstart 时记录到开始的点，在 bindtouchmove 记录到触摸结束的点，如果 X 轴滑动大于 Y 轴的，再如果结束点-开始点小于一个数值（这个数组可以自己设置，鉴于灵敏度，我这设置的很小），右滑也是同理。判断到左滑与右滑事件后，我们就需要对当前组件绑定数据了，数据从那里来？可以看下我这数组一个来历，以及怎么被左滑事件里面获取到（我这数据是一个数组，需要在 wxml 里面 block 的）。这时候取到需要的数组，循环出来后，我进行对比，如果数据的 id== 当前被事件操作的 id，那么我给改数组再添加一个 right 向右偏移 15%，否则其他都不偏移，右滑同理，直接全部设置为 0。最后把数据到绑定到页面上来。OK，左滑效果实现。如果出现全部被滚动了，记得在外层加上，X 轴关闭即可。这时候你点击左滑会出现点透效果，官方文档提供给我们一个 catch，不冒泡点击事件，即可完美解决。点击删除事件弹出模态框供用户确定是否删除。这里你点击取消时还要记得把左滑删除按钮去掉可能用户体验会好点。一定记得在 data({modalHidden:true})不然会出现一加载页面即出现了模态框。点击未分组按钮进入到未分组名片列表页面。这个布局完全是 copy 首页过来的，后面只是数据接口有变而已，大家有兴趣可以回过去看下前面的。点击多选，会出现多选框和下面的一些操作按钮。都是些数据绑定，显示与隐藏类的实现比较简单。多选我们直接给 checked 设置 Boole 开关。选择好名片后点击设置分组会弹出新建好的分组列表供用户确定设置到那个分组里面（这里由于后台接口方面还在完善，不继续往下写了）。用户已建分组点击进去的是点击顶部菜单按钮出现下拉菜单栏，这里直接使用微信提供的组件。最后点击从名片夹中添加进入到以下页面：整个布局基本还是和首页面差不多，这里不再多讲，顶部菜单直接多选绑定数据即可。牵扯到表单类的基本全都是 from 表单提交事件。除小部分接口方面欠缺外，写到这里其实分组前端方面效果基本实现。"}
{"title": "微信小程序试用报告：前端源码逻辑和工作流 ", "author": "天下雪", "time": "2016-10-13 16:49", "content": "文件基本结构：  　  先看入口app.js，app(obj)注册一个小程序。接受一个 object 参数，其指定小程序的生命周期函数等。其他文件可以通过全局方法getApp()获取app实例，进而直接调用它的属性或方法，例如（getApp().globalData）//app.jsApp({  onLaunch: function () {    //调用API从本地缓存中获取数据    var logs = wx.getStorageSync('logs') || []    logs.unshift(Date.now())    wx.setStorageSync('logs', logs)  },  getUserInfo:function(cb){    var that = this    if(this.globalData.userInfo){      typeof cb == \"function\" && cb(this.globalData.userInfo)    }else{      //调用登录接口      wx.login({        success: function () {          wx.getUserInfo({            success: function (res) {              that.globalData.userInfo = res.userInfo              typeof cb == \"function\" && cb(that.globalData.userInfo)            }          })        }      })    }  },  globalData:{    userInfo:null  }})  　  我理解app.js为入口初始化文件，也是提供全局API拓展的地方。下边分析下自带的几个方法和属性  　  onLaunch钩子函数会在小程序初始化完成后会自动执行一次，然后在小程序生命周期里如果你不主动调用onLaunch，它就不会在执行。  　  var logs = wx.getStorageSync('logs') || []获取本地缓存中的logs属性，如果值为空，那么设置logs=[] 与HTML5中的localStorage作用相似logs.unshift(Date.now()) 当前登录时间添加到数组中  　  wx.setStorageSync('logs', logs) 将数据存入本地缓存，因为wx为全局对象，所以可以在其他文件中直接调用wx.getStorageSync('logs')获取本地缓存数据  　  getUserInfo函数，顾名思义就是获取登录用户信息，相当于此函数提供了获取用户信息的接口，其他页面不调用自然不会执行。其他页面通过getApp().getUserInfo(function(userinfo){console.log(userinfo);})这种方式调用该方法，获取用户信息。getUserInfo:function(cb){//参数为cb,类型为函数    var that = this    if(this.globalData.userInfo){//用户信息不为空      typeof cb == \"function\" && cb(this.globalData.userInfo)//如果参数cb的类型为函数，那么执行cb,获取用户信息；    }else{//如果用户信息为空，也就是说第一次调用getUserInfo，会调用用户登录接口。      wx.login({        success: function () {          wx.getUserInfo({            success: function (res) {　　　　　　　　 console.log(res)              that.globalData.userInfo = res.userInfo//把用户信息赋给globalData，如果再次调用getUserInfo函数的时候，不需要调用登录接口              typeof cb == \"function\" && cb(that.globalData.userInfo)//如果参数cb类型为函数，执行cb,获取用户信息            }          })        }      })    }  }   　  globalData对象用来存储全局数据，在其他地方调用  　  然后简要分析下app.json文件,该文件作用是对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等、  　  最重要的是pages属性，必填，为数组，数组内的元素为字符串性文件路径，指定小程序由哪些页面组成，第一项必须是小程序初始页面。 {  \"pages\":[    \"pages/index/index\",    \"pages/logs/logs\"  ],  \"window\":{    \"backgroundTextStyle\":\"light\",    \"navigationBarBackgroundColor\": \"#fff\",    \"navigationBarTitleText\": \"WeChat\",    \"navigationBarTextStyle\":\"black\"  }}  　  然后来看下项目index和logs文件夹。微信小程序初始项目把每个页面相关的js、wxss、wxml放在各自的文件，这样看起来结构清晰明朗很多。  　  先来看index文件夹，即小程序初始页面。index文件夹下为index.js、index.wxml、index.wxss三个小文件。小程序把js、css、html代码分离开来，放在独自的文件里，各司其职。js和样式表文件名必须与当前文件夹的wxml文件名保持一致，这样才能保证js和样式表的效果能够在页面中显现出来。我很欣赏这样的设计理念，整齐划一，职责明确，减轻代码设计复杂度。  　  index.wxml，这就是常见的模板文件，数据驱动，有过前端mvc、mvvm项目开发的对这个一定不会陌生，毕竟这是基于react开发的。　　<!--index.wxml--><view class=\"container\">//视图容器  <view  bindtap=\"bindViewTap\" class=\"userinfo\">//bindtap为容器绑定点击触摸事件，在触摸离开时触发bindViewTap事件处理函数，bindViewTap通过index.js page()设置添加    <image class=\"userinfo-avatar\" src=\"{{userInfo.avatarUrl}}\" background-size=\"cover\"></image>//大双括号的变量来自于index.js的data对象解析成对应的值，而且是实时的    <text class=\"userinfo-nickname\">{{userInfo.nickName}}</text>  </view>  <view class=\"usermotto\">    <text class=\"user-motto\">{{motto}}</text>  </view></view>  　  index.js，与reaact用法几无二异，换汤不换药。page()来注册一个页面。接受一个 OBJECT 参数，其指定页面的初始数据、生命周期函数、事件处理函数等。var app = getApp() // 获取入口文件app的应用实例Page({  data: {    motto: 'Hello World',    userInfo: {}  },  //自定义事件处理函数，点击.userinfo的容易触发此函数  bindViewTap: function() {    wx.navigateTo({//全局对象wx的跳转页面方法      url: '../logs/logs'    })  },  onLoad: function () {//发生页面加载时，自动触发该生命周期函数    console.log('onLoad')    var that = this    //调用应用实例的方法获取全局数据    app.getUserInfo(function(userInfo){      //更新数据，页面自动渲染      that.setData({        userInfo:userInfo      })    })  }})  　  index.wxss文件只渲染当前所属页面，会覆盖全局app.wxss同一样式。  　  再分析下logs日志文件夹，logs文件夹下为logs.wxml、logs.js、logs.wxss、logs.json，同理保证同名，才能完成效果渲染。  　  logs.wxml文件<!--logs.wxml--><view class=\"container log-list\">  <block wx:for=\"{{logs}}\" wx:for-item=\"log\">//block容器作用，无其他实际含义。wx:for作用：遍历logs数组，遍历多少次，block块就会复制多少次，for-item等同于为<br>遍历元素起一个变量名，方便引用。<br>    <text class=\"log-item\">{{index + 1}}. {{log}}</text>  </block></view>  　　logs.js 文件//logs.jsvar util = require('../../utils/util.js') //util.js相当于一个函数库，我们可以在这个文件内自定义扩展和封装一些常用的函数和方法Page({  data: {    logs: []  },  onLoad: function () {    this.setData({      logs: (wx.getStorageSync('logs') || []).map(function (log) {//通过wx.getStorageSync获取本地缓存的logs日志数据        return util.formatTime(new Date(log))//日期格式化      })    })  }})　　logs.json文件{    \"navigationBarTitleText\": \"查看启动日志\"   //当前页面配置文件，设置window当前页面顶部导航栏标题等相关内容}　　基本页面结构和逻辑就这么简单，暴露给我们的没有一点令人费解的东西。"}
{"title": "小程序生成海报保存分享图片完全指南 ", "author": "Rolan", "time": "2018-8-21 00:28", "content": "小程序生成海报保存分享图片完全指南（包括：头像，文字）作者：starkwang原文：https://segmentfault.com/a/1190000016039298业务在小程序中生成海报（包括用户头像和自定义文字）并且保存到本地实现思路利用canvas画布，把用户头像和自定义文字定位好，用户点击按钮保存到本地注意事项 难点小程序canvas不支持自定义宽高，反正我没找到，canvas画布大部分业务都需要全屏，响应式，至少宽100%解决方案：判断到屏幕尺寸，传到wxml 里面远程图片不能直接使用 getImageInfo 获取，需要保存到本地解决方案：canvas直接支持远程图片，不需要使用这个api先来个ui （嘿嘿！此图经过公司的设计授权过）技术栈canvaswx.createCanvasContextwx.canvasToTempFilePathPromise实战首先我们在wxml里面写一个canvas占位注意这里的宽度是100%，响应式，海报的高posterHeight 是从js里面动态计算的<canvas canvas-id=\"starkImg\" style=\"width:100%;height:{{posterHeight}}px;\"></canvas>根据屏幕动态计算海报的尺寸data: {\r\n  motto: 'Hello World',\r\n  hidden: true,\r\n  userInfo: {},\r\n  hasUserInfo: false,\r\n  windowWidth: '',\r\n  posterHeight: '',\r\n},\r\nonLoad: function () {\r\n  const poster = {\r\n    \"with\": 375,\r\n    \"height\": 587\r\n  }\r\n  const systemInfo = wx.getSystemInfoSync()\r\n  let windowWidth = systemInfo.windowWidth\r\n  let windowHeight = systemInfo.windowHeight\r\n  let posterHeight = parseInt((windowWidth / poster.with) * poster.height)\r\n  this.setData({\r\n    windowWidth: windowWidth,\r\n    posterHeight: posterHeight\r\n  })\r\n}背景图片生成  const that = this\r\n  // 图片路径\r\n  const imagePath = '../../static/image/common/'\r\n  let bgimgPromise = new Promise(function (resolve, reject) {\r\n    console.log('data', that.data)\r\n    wx.getImageInfo({\r\n      src: imagePath + \"base.png\",\r\n      success: function (res) {\r\n        resolve(res);\r\n      }\r\n    })\r\n  });头像直接使用远程头像初始化的时候，调取，一定在生成海报之前此处可以存储本地，或使用状态都可以wxml// 可以从后端接口获取 或 官方本身远程地址\r\n\r\n \r\n  <button class=\"share\" type=\"primary\" open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\">开始答题（获取用户信息）</button>\r\njs  getUserInfo: function (e) {\r\n    app.globalData.userInfo = e.detail.userInfo\r\n    let userInfo = e.detail.userInfo\r\n    console.log('userInfo', userInfo)\r\n    // 更新用户信息\r\n    // api.post('更新用户信息的url', userInfo)\r\n    this.setData({\r\n      userInfo: e.detail.userInfo,\r\n      hasUserInfo: true\r\n    })\r\n  },生成海报背景和图片wxmlbgimgPromise.then(res => {\r\n      console.log('Promise.all', res)\r\n      const ctx = wx.createCanvasContext('shareImg')\r\n      ctx.width = windowWidth\r\n      ctx.height = posterHeight\r\n      console.log(windowWidth, posterHeight)\r\n      // 背景图\r\n      ctx.drawImage('../../' + res[0].path, 0, 0, windowWidth, posterHeight, 0, 0)\r\n      // 头像\r\n      ctx.drawImage(that.data.userInfo.avatarUrl, 48, 182, 58, 58, 0, 0)\r\n      ctx.setTextAlign('center')\r\n      ctx.setFillStyle('#000')\r\n      ctx.setFontSize(22)\r\n      // ctx.fillText('分享文字2：stark.wang出品', 88, 414)\r\n      ctx.fillText('分享文字1我的博客：https://shudong.wang', 55, 414)\r\n      ctx.stroke()\r\n      ctx.draw()\r\n    })保存到本地onLoad: function () {\r\n  share: function () {\r\n    var that = this\r\n    wx.showLoading({\r\n      title: '正在制作海报。。。'\r\n    })\r\n    new Promise(function (resolve, reject) {\r\n      wx.canvasToTempFilePath({\r\n        x: 0,\r\n        y: 0,\r\n        width: 444,\r\n        height: 500,\r\n        destWidth: 555,\r\n        destHeight: 666,\r\n        canvasId: 'starkImg',\r\n        success: function (res) {\r\n          console.log(res.tempFilePath);\r\n          that.setData({\r\n            prurl: res.tempFilePath,\r\n            hidden: false\r\n          })\r\n          wx.hideLoading()\r\n          resolve(res)\r\n        },\r\n        fail: function (res) {\r\n          console.log(res)\r\n        }\r\n      })\r\n    }).then(res => {\r\n      console.log(res)\r\n      this.save()\r\n    })\r\n  }\r\n}结果更新头像裁剪为圆形ctx.save() // 对当前区域保存\r\nctx.beginPath() // 开始新的区域\r\nctx.arc(73, 224, 38, 0, 2 * Math.PI);\r\nctx.clip();  // 从画布上裁剪出这个圆形\r\nctx.drawImage(res[1], 36, 186, 94, 94, 0, 0) // 把图片填充进裁剪的圆形\r\nctx.restore() // 恢复上面是远程连接容易发生请求失败把头像提前存到本地存储中解决getImg: function () {\r\n  let avatarUrl = this.data.userInfo.avatarUrl\r\n  downLoadFile(avatarUrl).then((res) => {\r\n    console.log(res)\r\n    wx.saveFile({\r\n      tempFilePath: res.data.tempFilePath,\r\n      success: function (res) {\r\n        wx.setStorageSync('avatarUrl', res.savedFilePath)\r\n      }\r\n    })\r\n  })\r\n},获取头像// 头像\r\nlet promiseAvatarUrl = new Promise(function (resolve, reject) {\r\n  resolve(wx.getStorageSync('avatarUrl'))\r\n}).catch(res=>{\r\n  console.log('catch',res)\r\n});背景还是不变const that = this\r\nlet promiseBdImg = new Promise(function (resolve, reject) {\r\n  console.log('data', that.data)\r\n  wx.getImageInfo({\r\n    src: imagePath + \"base1.png\",\r\n    success: function (res) {\r\n      console.log('promiseBdImg', res)\r\n      resolve(res);\r\n    }\r\n  })此时生成canvas更新Promise.all([\r\n    promiseBdImg, promiseAvatarUrl\r\n  ]).then(res => {\r\n    console.log('Promise.all', res)\r\n    const ctx = wx.createCanvasContext('shareImg')\r\n    ctx.width = windowWidth\r\n    ctx.height = posterHeight\r\n    console.log(windowWidth, posterHeight)\r\n    //主要就是计算好各个图文的位置\r\n    ctx.drawImage('../../' + res[0].path, 0, 0, windowWidth, posterHeight, 0, 0)\r\n    ctx.save() // 对当前区域保存\r\n    ctx.beginPath() // 开始新的区域\r\n    ctx.arc(73, 224, 38, 0, 2 * Math.PI);\r\n    ctx.clip();  // 从画布上裁剪出这个圆形\r\n    ctx.drawImage(res[1], 36, 186, 94, 94, 0, 0) // 把图片填充进裁剪的圆形\r\n    ctx.restore() // 恢复\r\n    ctx.setTextAlign('center')\r\n    ctx.setFillStyle('#000')\r\n    ctx.setFontSize(22)\r\n    ctx.save()\r\n    ctx.beginPath();\r\n    ctx.fillText('作者：stark.wang', 545 / 2, 130)\r\n    ctx.fillText('我的博客：http://shudong.wang', 190, 414)\r\n    ctx.stroke()\r\n    ctx.draw()\r\n  })结果完美ok，如果能帮助你，请赞一个。感觉日后会需要，推荐收藏"}
{"title": "小程序绘图工具painter-json文件绘制保存分享图-可点击任意元素触发函数 ... ... ", "author": "Rolan", "time": "2018-8-27 00:25", "content": "Painter是由酷家乐移动前端团队打造的一款小程序绘图组件。\r\n原项目地址：github.com/Kujiale-Mob…\r\n新版地址：github.com/shesw/Paint…\r\n这款交互版原来是为了针对业务中的新需求而由我自己开发的，后来需求改动，所以并没有用上。组里大佬考虑种种原因（主要是项目没用上，=0=～～），让我先在自己的github上开源。这版painter与原版的区别在于：\r\n\r\n添加了交互事件。Painter本质是以canvas为基础的，小程序的canvas有许多限制。允许canvas上元素的交互点击事件，可以实现更为便捷的功能，比如原来需要在canvas上添加功能按钮，现在可以直接画在canvas上\r\n添加拖拽元素的功能。目前这个功能没有完善好，因为它的滑动动作会与小程序的全屏滑动事件冲突，因此，拖拽功能在固定的页面上效果才好，如在拖拽时设置overflow: hidden等。\r\n\r\n这里将新版的Painter称为dancing-painter。引入方式请参考readme和demo。\r\n演示：\r\n\r\n主要功能：\r\n指原版的painter的功能。这些功能依然是本项目的主(实)要(用)功能。\r\n简介：\r\n原版的使用简介请参见 juejin.im/post/5b40b1…\r\n简单来讲，使用过程如下图所示，可以结合demo来看：\r\n距离首次开源Painter库已经有一段时间了，这期间获益于各路道友的帮助和提点，Painter进行了几波更新（原项目地址)：\r\n新增特性：\r\n\r\n增加align属性，可以使任意元素可以实现左中右对齐。\r\n加入文字换行的能力。对一段文字设置width或者maxLines，都有可能触发文字的换行。\r\n添加文字的一些属性：fontWeight, textDecoration, textStyel(fill, stroke), maxLines, lineHeight\r\n图片mode属性，实现图片裁剪、缩放，默认为aspectFill\r\n图片不设置width, heighti属性，使用默认宽高\r\nleft, right, top, bottom对负数的支持\r\n\r\n修复问题：\r\n\r\n某些机型上切边会出现黑线。\r\n安卓机型上圆角无法显示\r\n使用文件前检查文件是否正常\r\n二维码大小显示异常\r\n\r\n交互功能：\r\n这一版的特色主要是具备元素的点击事件实现以及拖拽功能，做出来以后因为项目上暂时用不上，所以感觉功能上可能比较鸡肋。不过还蛮好玩的"}
{"title": "mpvue写一个CPASS小程序 ", "author": "Rolan", "time": "2018-9-4 00:06", "content": "本文是对CPASS项目的技术要点和所踩的坑做一些总结。项目一个提供移动办公场地的小程序平台。使用美团mpvue框架， mpvue：1.0.13, mpvue-loader：1.0.15 静态资源（除了tabbar图标）放在阿里云oss组件（页面）间通信四种方式：Vuex状态管理（mapActions，mapGetters）本地缓存（setStorage，getStorage，removeStorage）Bus集中式的事件中间件（$emit，$on，$off）路由query传值这里说一下比较少用的第三种通信方式。Bus应用于非父子组件通信，利用$emit，$on，$off分别来分发、监听、取消监听。第一步：在mixins（混合）建一个文件event-bus.jsimport Vue from 'vue';\r\nexport default new Vue();复制代码第二步：在需要分发的组件中引入event-bus，再传递分发事件import Bus from '@/mixins/event-bus'\r\n\r\n// 需要传递给兄弟组件的值\r\nlet params = { \r\n    ***\r\n}\r\nBus.$emit('getParams', params)\r\n\r\n复制代码第三步：在需要监听的组件中引入event-bus，在created周期去监听事件（小程序周期监听无效）,在 beforeDestroy 周期取消监听事件import Bus from '@/mixins/event-bus'\r\ncreated () {\r\n  // 监听事件\r\n  Bus.$on('getParams', params => {\r\n    // to do something\r\n\r\n  })\r\n},beforeDestroy () {\r\n  // 清除监听\r\n  Bus.$off('getParams');\r\n}复制代码swiper选项卡 +  无限加载利用微信官方提供的swiper封装一个无限数据加载的swiperTab选项卡。空态下：技术难点：swiper需要设置固定高度，触底 onReachBottom 无限加载又需要高度。所以需要在swiper标签设置动态高度 :style=\"{height: swiperHeight + 'px'}\" 。 onLoad 周期获取单个list-item的高度。假如所渲染数据有n组数据，则swiper高度为： swiperHeight = baseHeight * n + 加载提示占位高度 。// swiper动态设置高度，list为需要渲染的数据\r\nautoHeight(list) {\r\n  let num = list.length;\r\n  // this.loadHeight加载提示语的高度\r\n  let listHeight = this.baseItemHeight * num + this.loadHeight\r\n  this.swiperHeight = Math.max(this.windowHeight, listHeight);\r\n},\r\n// 获取静态高度\r\ncalcStaticHeight() {\r\n  return new Promise((resolve) => {\r\n    let self = this;\r\n    let tabListHeight; // 获取tab高度\r\n    // 获取除去tabList高度，全屏高度（空态状态时需要）\r\n    wx.createSelectorQuery().select('#tab-list').fields({\r\n      size: true\r\n    }, function (res) {\r\n      tabListHeight = res.height\r\n      wx.getSystemInfo({\r\n        success: function(resp) {\r\n          self.windowHeight = resp.windowHeight - tabListHeight\r\n        }\r\n      })\r\n    }).exec()\r\n    // 获取单个item高度\r\n    wx.createSelectorQuery().select('#base-item').fields({\r\n      size: true\r\n    }, function (res) {\r\n      self.baseItemHeight = res.height\r\n      resolve()\r\n    }).exec()\r\n  })\r\n}复制代码如果频繁切换swiper会导致卡死，是因为触摸滑动swiper和点击选项卡时赋值swiperIndex都会触发swiper bindchange 事件，这里做了判断处理。// 滑动切换\r\nswiperTab (e) {\r\n  // 如果是触摸滑动切换\r\n  if (e.mp.detail.source === 'touch') {\r\n    if (this.currentTab === e.mp.detail.current) {\r\n      return false;\r\n    } else {\r\n      this.currentTab = e.mp.detail.current\r\n      this.isLoading = false\r\n      this.allLoaded = false\r\n      this.pageNum = 1\r\n      this.loadTips = '上拉加载更多'\r\n      this.getDataList(this.loadTips);\r\n    }\r\n  }\r\n},\r\n// 点击切换\r\nclickTab (tab) {\r\n  if (this.currentTab === tab) {\r\n    return false;\r\n  } else {\r\n    this.currentTab = tab\r\n    this.allLoaded = false\r\n    this.pageNum = 1\r\n    this.loadTips = '上拉加载更多'\r\n    this.getDataList(this.loadTips);\r\n  }\r\n},复制代码scroll-view封装indexList实现两种定位方式：点击定位，按住右侧字母indexList滑动定位。技术难点：按住右侧indexList滑动定位，获取字母indexList的上边距 offsetTop ，按住滑动时获取手指距离屏幕顶部的距离 clientY， 手指移动距离为 moveY=clientY-offsetTop， 具体实现如下：// 索引定位(滑动开始) @touchstart=\"handlerStart\"\r\nhandlerStart (e) {\r\n  this.targetIndex = e.mp.target.id\r\n},\r\n// 索引定位(滑动过程) @touchmove=\"handlerMove\"\r\nhandlerMove(e) {\r\n  let keyList = this.keyList;\r\n  // 手指滑动垂直距离\r\n  let moveY = e.mp.touches[0].clientY;\r\n  let rY = moveY - this.offsetTop;\r\n  if (rY >= 0) {\r\n    // apHeight为字母表indexList中单个字母块高度，计算结果向上取整\r\n    let index = Math.ceil((rY - this.apHeight) / this.apHeight);\r\n    if (index >= 0 && index < keyList.length) {\r\n      this.targetIndex = keyList[index];\r\n    }\r\n  } else {\r\n    this.targetIndex = keyList[0]\r\n  }\r\n},复制代码坑view或者text设置border-radius=50%有时候在真机会变形（排除flex布局的影响）。wxml不支持复杂逻辑，如模版字符串，字符串截取等等。text设置行高的时候会出现样式异常，替换成view便可解决此问题。wx.showLoading和wx.showToast的属性title不可为空，线上会报错，影响js执行。总结本文只是简单讲一下项目中涉及到的几处技术要点，欢迎交流。打一波广告："}
{"title": "微信小程序集成 Jenkins ", "author": "Rolan", "time": "2018-9-4 00:18", "content": "微信小程序的测试发布在没有 CI/CD 等相关工具的情况下，存在着如下的问题：小程序开发助手中，同一个开发者只能显示一个开发版本测试同事找开发要二维码，效率较低本地生成的二维码会出现携带本地代码、未及时拉取分支其他改动等问题为了避免如上问题的发生，采用 微信小程序集成 Jenkins 的方案。基础在介绍实现方案之前，先来回顾一下常规的微信小程序发布流程。从上面的流程图可以看出，微信小程序预览、上传都是需要在微信开发者工具中进行的，接下来了解一下微信开发者工具提供的上传方式。微信开发者工具除了图形化界面，微信开发者工具还提供了命令行与 HTTP 服务两种接口供外部调用，来进行登录、预览、上传等操作。命令行调用命令行工具所在位置：macOS: <安装路径>/Contents/Resources/app.nw/bin/cliWindows: <安装路径>/cli.bat以 macOS 操作系统示例：1、打开开发者工具：/Applications/wechatwebdevtools.app/Contents/Resources/app.nw/bin/cli -o\r\n复制代码其中， /Applications/wechatwebdevtools.app/ 为安装路径。2、登录：/Applications/wechatwebdevtools.app/Contents/Resources/app.nw/bin/cli -l\r\n复制代码输入上面的命令行后，终端中打印出登录二维码，使用微信扫码登录。在微信端完成操作之后，会输出 login success ，如下图所示：如果想得到 base64 形式的二维码，可以使用下面的命令：# 登录，在终端中打印登录 base64 形式的二维码\r\ncli -l --login-qr-output base64\r\n\r\n# 登录，二维码转成 base64 并存到文件 /Users/username/code.txt \r\ncli -l --login-qr-output base64@/Users/username/code.txt\r\n复制代码更多 API 可以参考命令行调用 。HTTP 服务HTTP 服务在 工具启动后自动开启 ，每次开启 host 固定为 127.0.0.1，端口号并不固定。端口号在 用户目录 下记录，位置如下：macOS : ~/Library/Application Support/微信web开发者工具/Default/.ideWindows : ~/AppData/Local/微信web开发者工具/User Data/Default/.ide以 macOS 操作系统示例：首先需要 运行开发者工具 ，可以利用上面介绍的命令行方法打开微信开发者工具。/Applications/wechatwebdevtools.app/Contents/Resources/app.nw/bin/cli -o\r\nport=$(cat \"/Users/zyy/Library/Application Support/微信web开发者工具/Default/.ide\")\r\necho \"微信开发者工具运行在${port}端口\"\r\n复制代码这样就可以拿到微信开发者工具运行的端口号了，其中， /Users/zyy/ 为用户目录。1、打开开发者工具：# 打开工具\r\nhttp://127.0.0.1:端口号/open\r\n# 打开/刷新项目\r\nhttp://127.0.0.1:端口号/open?projectpath=项目全路径\r\n复制代码2、登录：# 登录，返回图片格式的二维码\r\nhttp://127.0.0.1:端口号/login\r\n# 登录，取 base64 格式二维码\r\nhttp://127.0.0.1:端口号/login?format=base64\r\n# 登录，取 base64 格式二维码，并写入 /Users/username/logincode.txt\r\nhttp://127.0.0.1:端口号/login?format=base64&qroutput=%2FUsers%2Fusername%2Flogincode.txt\r\n复制代码3、预览：# 预览路径为 /Users/username/demo 的项目，返回图片格式的二维码\r\nhttp://127.0.0.1:端口号/preview?projectpath=%2FUsers%2Fusername%2Fdemo\r\n\r\n# 预览路径为 /Users/username/demo 的项目，返回 base64 格式的二维码\r\nhttp://127.0.0.1:端口号/preview?projectpath=%2FUsers%2Fusername%2Fdemo&format=base64\r\n\r\n# 预览路径为 /Users/username/demo 的项目，返回 base64 格式的二维码，并写入 /Users/username/logincode.txt\r\nhttp://127.0.0.1:端口号/preview?projectpath=%2FUsers%2Fusername%2Fdemo&format=base64&qroutput=%2FUsers%2Fusername%2Flogincode.txt\r\n\r\n# 预览路径为 /Users/username/demo 的项目，返回图片格式的二维码，并将预览信息输出至 /Users/username/info.json\r\nhttp://127.0.0.1:端口号/preview?projectpath=%2FUsers%2Fusername%2Fdemo&infooutput=%2Users%2username%2info.json\r\n复制代码更多 API 可以参考HTTP 调用 。方案微信开发者工具目前只有 macOS 和 Windows 两种版本，这限制了服务器的系统。下面以 macOS 为例， 来介绍具体的实现过程：安装 JenkinsThe leading open source automation server, Jenkins provides hundreds of plugins to support building, deploying and automating any project.作为领先的开源自动化服务器，Jenkins提供数百个插件来支持构建，部署和自动化任何项目。Jenkins 依赖于 Java 运行环境，所以需要在机器上安装 Java。安装 Jenkins 方式很多，可以在官网直接下载最新的软件包，然后执行下面的命令启动 Jenkins 。java -jar jenkins.war --httpPort=8888\r\n复制代码其中， --httpPort=8888 为设置服务端口号，默认端口号为 8080 。新建任务选择 “ 构建一个自由风格的软件项目 ” ，在输入任务名称之后，点击确定按钮，进入到任务配置页面。任务配置在介绍任务配置之前，先来看一下最终要实现的功能。主要的功能点如下：使用 git 来管理代码，可以选择分支打包版本（开发版／体验版）可以选择（注意：这里的「开发版」对应「预览」，体验版对应「上传」）1、源码管理在任务配置页面的第二项 “源码管理” 中，选择 git 方式管理代码。填入 git 仓库地址及访问的账户，上图中的 $branch 是自定义的构建参数，下面来看一下构建参数的定义。2、构建参数在任务配置页面的第二项 “General” 中，选择 “参数化构建过程”，进入构建参数配置页面。参数有上述的几种类型供选择，可以参考下图进行配置，这里不再赘述。需要注意的是，这里的 name 可以通过 branch 。构建在任务配置页面的 “构建” 中，选择 “执行 shell” 方式来进行构建。Tips：这里的 shell 脚本是微信小程序集成 Jenkins 最核心的内容。回顾一下，本文最开始提到的微信小程序发布流程图：这一系列的操作使用 shell 脚本来完成，如何实现呢？登录微信开发者工具的登录需要在微信端扫码确认，这一步微信并没有提供账号密码的登录方式。不过，微信开发者工具是可以保持登录态的。由于微信限制，一个开发者身份只能在一个终端登录，所以我们申请了一个新的微信账号「前端小姐姐」用于在 Jenkins 机器上登录。项目基础设置在图形化界面中，上传代码时，会在开发者工具中填入 AppID 、项目路径等信息，也会在「详情」中选择项目的基本设置，比如「ES6 转 ES5」。微信还提供了一种配置方法，在项目根目录使用 project.config.json 文件。这里通过一段 node 脚本，生成 project.config.json 文件。const fs = require('fs')\r\n\r\nconst content = '{\"description\":\"项目配置文件。\",\"setting\":{\"urlCheck\":false,\"es6\":true,\"postcss\":true,\"minified\":true,\"newFeature\":true},\"miniprogramRoot\":\"./\",\"compileType\":\"miniprogram\",\"appid\":\"***\",\"projectname\":\"wechat-app\",\"condition\":{\"search\":{\"current\":-1,\"list\":[]},\"conversation\":{\"current\":-1,\"list\":[]},\"plugin\":{\"current\":-1,\"list\":[]},\"game\":{\"currentL\":-1,\"list\":[]},\"miniprogram\":{\"current\":-1,\"list\":[]}}}'\r\n\r\nfs.writeFileSync('./dist/project.config.json', content, 'utf-8')\r\n复制代码这样就完成了项目的基础设置，接下来将介绍如何通过 shell 脚本完成上传。shell 脚本echo -------------------------------------------------------\r\necho GIT_BRANCH: ${GIT_BRANCH}\r\necho -------------------------------------------------------\r\n# 执行项目构建\r\nnpm i --registry=http://registry.npm.taobao.org\r\nnpm run build\r\n# 打开微信开发者工具\r\n/Applications/wechatwebdevtools.app/Contents/Resources/app.nw/bin/cli -o\r\nport=$(cat \"/Users/devops/Library/Application Support/微信web开发者工具/Default/.ide\")\r\necho \"微信开发者工具运行在${port}端口\"\r\nreturn_code=$(curl -sL -w %{http_code} http://127.0.0.1:${port}/open)\r\nif [ $return_code == 200 ]\r\n  then\r\n  echo \"返回状态码200，devtool启动成功！\"\r\nelse\r\n  echo \"返回状态码${return_code}，devtool启动失败\"\r\n  exit 1\r\nfi\r\nif [ \"$build_type\" == \"dev\" ]\r\n  then\r\n  echo \"发布开发版！\"\r\n  wget -O $BUILD_ID.png http://127.0.0.1:${port}/preview?projectpath=/Users/Shared/Jenkins/Home/workspace/fe-wechat-app/dist\r\n  echo \"预览成功！请扫描二维码进入开发版！\"\r\nelif [ \"$build_type\" == 'prod' ]\r\n  then\r\n  echo \"准备上传！\"\r\n  /Applications/wechatwebdevtools.app/Contents/Resources/app.nw/bin/cli -u 1.0.0@/Users/Shared/Jenkins/Home/workspace/fe-wechat-app/dist --upload-desc 'initial release'\r\n  echo \"上传成功！请到微信小程序后台设置体验版并提交审核！\"\r\nfi\r\n复制代码因为本项目需要编译代码，所以服务器上需要安装 node 和 npm。 npm run build 命令不光在编译代码，而且还执行了前面介绍的生成 project.config.json 的 node 脚本。开发版上传成功后，将二维码图片保存下来，用于构建后显示二维码和发送邮件。这里结合 命令行调用 和 HTTP 调用 两种方式来完成上传，主要出于以下原因：HTTP 调用 可以很方便的下载生成的二维码图片HTTP 服务 只有在微信开发者工具启动之后，才会启动，所以需要通过 命令行调用 方式，来启动微信开发者工具构建后使用 description setter plugin 插件来实现，构建完成后显示二维码图片。安装插件回到 Jenkins 主页，在「系统管理」中，进入到「插件管理」页面，搜索 description setter plugin 并安装。安装好插件后，返回任务配置页面。在「构建后操作」中，增加「Set build description」步骤，如下图：这里采用 HTML <img> 标签形式，展示二维码信息，如下：<img src=\"http://机器ip:端口/job/项目名称/ws/${BUILD_ID}.png\" alt=\"二维码${BUILD_ID}\" width=\"200\" height=\"200\" /> <a href=\"http://机器ip:端口/job/项目名称/ws/${BUILD_ID}.png\">二维码${BUILD_ID}</a>\r\n复制代码按照上面的方式配置后，发现图片并没有显示出来，而是显示了文本信息。这是由于 Jenkins 出于安全的限制，所有描述信息的 Markup Formatter 默认都采用 Plain text 的模式。在「系统管理」-> 「全局安全配置」中，将 Markup Formatter 由 Plain text (纯文本) 更改为 Safe HTML 即可。按照上面的步骤操作后，就可以显示出开发版二维码。因为 Jenkins 构建时，均使用「前端小姐姐」微信账号，所以小程序开发助手上「前端小姐姐」发布的开发版不确定是哪位同学构建的，故需要使用 Jenkins 平台生成的二维码，并注意二维码有效期（有效期25分钟）。总结本文以微信小程序常规的发布流程为切入点，循序渐进地介绍了如何集成 Jenkins 实现微信小程序预览、上传功能。后台、测试同事可以在该平台上选择分支获取开发版用于联调、测试，解决了本文开篇提及的问题。由于本文篇幅有限，只是介绍了该平台的一些基本功能，如果有其他的需求，可以参考文末的拓展链接解决。此外，文中若有任何表述不清或不当的地方，欢迎大家批评指正～本文首发于 github.com/yingye/Blog… ，欢迎各位关注我的Blog，正文以issue形式呈现，喜欢请点star，订阅请点watch～"}
{"title": "简陋至极：微信小程序日历组件（思路） ", "author": "Rolan", "time": "2018-9-4 00:35", "content": "最近在做微信小程序项目，其中涉及到日历。一直以来，遇到日历，就是网上随便找个插件，这次心血来潮，想着自己去实现一下。这次不是封装功能强大，健硕完美的组件，只是记录一下，主体思路。更多功能还得根据项目需要，自己去挖掘、实现。（大佬轻喷）思路分析首先最主要的一点，就是要计算出某年某月有多少天，其中涉及到大小月，闰、平年二月。其次，弄清楚每月一号对应的是周几。然后，有时为填充完整，还需显示上月残余天数以及下月开始几天，这些又该如何展示。最后，根据自己项目需求实现其它细枝末节。计算每月天数按照一般思路，[1,3,5,7,8,10,12]这几个月是31天，[2,3,6,9,11]这几个月是30天，闰年2月29天，平年2月28天。每次需要计算天数时，都得如此判断一番。方案可行，而且也是大多数人的做法。但是，这个方法，我却觉得有些繁琐。其实换一种思路，也未尝不可。时间戳就是一个很好的载体。当前月一号零时的时间戳，与下一月一号零时的时间戳之差，不就是当前月天数的毫秒数嘛。// 获取某年某月总共多少天\r\ngetDateLen(year, month) { \r\n    let actualMonth = month - 1;\r\n    let timeDistance = +new Date(year, month) - +new Date(year, actualMonth);\r\n    return timeDistance / (1000 * 60 * 60 * 24);\r\n},\r\n复制代码看到上述代码，你可能会问，是不是还缺少当月为12月时的特殊判断，毕竟涉及到跨年问题。当然，你无需担心,根据MDN中关于Date的表述，js已经为我们考虑好了这一点当Date作为构造函数调用并传入多个参数时，如果数值大于合理范围时（如月份为13或者分钟数为70），相邻的数值会被调整。比如 new Date(2013, 13, 1)等于new Date(2014, 1, 1)，它们都表示日期2014-02-01（注意月份是从0开始的）。其他数值也是类似，new Date(2013, 2, 1, 0, 70)等于new Date(2013, 2, 1, 1, 10)，都表示时间2013-03-01T01:10:00。计算每月一号是周几呃，这个就不需要说了吧，getDay()你值得拥有// 获取某月1号是周几\r\ngetFirstDateWeek(year, month) { \r\n    return new Date(year, month - 1, 1).getDay()\r\n},\r\n复制代码每个月的数据如何展示如果只是简单展示当月数据，那还是很简单的，获取当月天数，依次遍历，就可以拿到当月所有数据。// 获取当月数据，返回数组\r\ngetCurrentArr(){ \r\n    let currentMonthDateLen = this.getDateLen(this.data.currentYear, this.data.currentMonth) // 获取当月天数\r\n    let currentMonthDateArr = [] // 定义空数组\r\n    if (currentMonthDateLen > 0) {\r\n        for (let i = 1; i <= currentMonthDateLen; i++) {\r\n\t    currentMonthDateArr.push({\r\n\t        month: 'current', // 只是为了增加标识，区分上下月\r\n                date: i\r\n            })\r\n        }\r\n    }\r\n    this.setData({\r\n    \tcurrentMonthDateLen\r\n    })\r\n    return currentMonthDateArr\r\n},\r\n复制代码很多时候，为了显示完整，需要显示上下月的残余数据。一般来说，日历展示时，最大是7 X 6 = 42位，为啥是42位，呃，自己去想想吧。当月天数已知，上月残余天数，我们可以用当月1号是周几来推断出来，下月残余天数，正好用42 - 当月天数 -上月残余。// 上月 年、月\r\npreMonth(year, month) { \r\n    if (month == 1) {\r\n\treturn {\r\n\t    year: --year,\r\n\t    month: 12\r\n\t}\r\n    } else {\r\n    \treturn {\r\n\t    year: year,\r\n\t    month: --month\r\n    \t}\r\n    }\r\n},\r\n复制代码// 获取当月中，上月多余数据，返回数组\r\ngetPreArr(){ \r\n    let preMonthDateLen = this.getFirstDateWeek(this.data.currentYear, this.data.currentMonth) // 当月1号是周几 == 上月残余天数）\r\n        let preMonthDateArr = [] // 定义空数组\r\n    if (preMonthDateLen > 0) {\r\n\tlet { year, month } = this.preMonth(this.data.currentYear, this.data.currentMonth) // 获取上月 年、月\r\n\tlet date = this.getDateLen(year, month) // 获取上月天数\r\n\tfor (let i = 0; i < preMonthDateLen; i++) {\r\n\t\tpreMonthDateArr.unshift({ // 尾部追加\r\n                        month: 'pre', // 只是为了增加标识，区分当、下月\r\n\t\t    date: date\r\n                })\r\n\t\tdate--\r\n\t}\r\n    }\r\n    this.setData({\r\n\tpreMonthDateLen\r\n    })\r\n    return preMonthDateArr\r\n},\r\n复制代码// 下月 年、月\r\nnextMonth(year, month) { \r\n    if (month == 12) {\r\n\treturn {\r\n\t    year: ++year,\r\n\t    month: 1\r\n\t}\r\n    } else {\r\n\treturn {\r\n            year: year,\r\n\t    month: ++month\r\n\t}\r\n    }\r\n},\r\n复制代码// 获取当月中，下月多余数据，返回数组\r\ngetNextArr() { \r\n    let nextMonthDateLen = 42 - this.data.preMonthDateLen - this.data.currentMonthDateLen // 下月多余天数\r\n    let nextMonthDateArr = [] // 定义空数组\r\n    if (nextMonthDateLen > 0) {\r\n        for (let i = 1; i <= nextMonthDateLen; i++) {\r\n            nextMonthDateArr.push({\r\n                month: 'next',// 只是为了增加标识，区分当、上月\r\n                date: i\r\n            })\r\n        }\r\n    }\r\n    return nextMonthDateArr\r\n},\r\n复制代码整合三组数据，就得到了完整的当月数据，格式如下[\r\n    {month: \"pre\", date: 30},\r\n    {month: \"pre\", date: 31},\r\n    {month: \"current\", date: 1},\r\n    {month: \"current\", date: 2},\r\n    ...\r\n    {month: \"current\", date: 31},\r\n    {month: \"next\", date: 1},\r\n    {month: \"next\", date: 2}\r\n]\r\n复制代码至于上下月切换，选择某年某月等功能，无非就是参数变化而已，自己琢磨琢磨即可。骨架都有了，你想创造什么样的功能还不是手到擒来。"}
{"title": "微信小程序 | 切换按钮或者view的选中状态 ", "author": "Rolan", "time": "2018-9-4 00:42", "content": "实现非常简单，通过一个简单的判断当前data中的选中值，点击按钮时更新data值，重新渲染页面。index.wxml文件<view class=\"switch-type\">\r\n    <view class=\"btn {{currentSelectTripType == 'pinche' ? 'active' : ''}}\" bindtap='selectedPinche' data-id='pinche'>拼车</view>\r\n    <view class=\"btn {{currentSelectTripType == 'baoche' ? 'active' : ''}}\" bindtap='selectedBaoche' data-id='baoche'>包车</view>\r\n  </view>\r\nindex.js文件Page({\r\n  data: {~~~~\r\n    currentSelectTripType: 'pinche',\r\n  },\r\n  // 更新data 切换选中状态\r\n  selectedPinche: function (e) {\r\n    this.setData({\r\n      currentSelectTripType: e.currentTarget.dataset.id\r\n    })\r\n  },\r\n  selectedBaoche: function(e) {\r\n    this.setData({\r\n      currentSelectTripType: e.currentTarget.dataset.id\r\n    })\r\n  },\r\n})\r\n附上一个简单的样式index.wxss.switch-type {\r\n  display: flex;\r\n}\r\n.switch-type .btn:first-child {\r\n  border-top-right-radius: 0;\r\n  border-bottom-right-radius: 0;\r\n}\r\n.switch-type .btn:last-child {\r\n  border-top-left-radius: 0;\r\n  border-bottom-left-radius: 0;\r\n}\r\n.switch-type .btn {\r\n  background: #dfdfdf;\r\n  padding: 10rpx 40rpx;\r\n}\r\n.switch-type .btn.active {\r\n  border: 2rpx solid #007bff;\r\n  background: #fff;\r\n}"}
{"title": "小程序远程图片资源按需预加载 ", "author": "Rolan", "time": "2018-9-4 15:27", "content": "最近做H5开发遇到个问题，为了防止页面打开时，出现大图加载缓慢的情况，写了一个图片资源管理器，今天顺便实现了一下小程序版。特别说明一下，小程序由于资源包大小限制，很多图片资源会存放到CND图片服务器上，为了实现小程序初始化时按需加载远程图片资源，实现了以下加载器，希望能解决部分小程序新人开发者预加载图片的苦恼。特别强调：本加载器为初级版本，暂未研究其他实现方式，当前实现方式需要在微信公众平台->设置->downloadFile合法域名，中添加想要加载的图片所在服务器合法域名。原理介绍：使用小程序自带API读取远程图片资源：wx.getImageInfo({\r\n src: 'images/a.jpg',\r\n success: function (res) {\r\n console.log(res.width)\r\n console.log(res.height)\r\n }\r\n}) \r\n这个接口可以创建图片组件对象并返回图片加载状态。加载器用法：1、在app.js的同级目录下创建一个ImageSource.js作为图片资源的路径管理文件（可以根据情况改为其他文件名称）。2、在utils文件夹下放入ImageLoader.js或ImageLoader.min.js（附件）。3、根据需要在对应的文件中创建ImageLoader对象（看下文）。使用示例：1、载入文件：const ImageLoader = require('./utils/ImageLoader.min.js');\r\nconst ImageSource = require('./imageSource.js');\r\nImageLoader.min.js 为加载器源文件。imageSource.js 为图片资源路径文件。2、创建ImageLoader对象。new ImageLoader({\r\n base: ImageSource.BASE,\r\n source: [ImageSource],\r\n loading: res => {\r\n // 可以做进度条动画\r\n console.log(res);\r\n },\r\n loaded: res => {\r\n // 可以加载完毕动画\r\n console.log(res);\r\n }\r\n });\r\n参数base : String 图片资源的基础路径 必填 示例： \"https://image.example.com/static/images/\"source : Array 需要预加载的图片资源 必填 示例： [ImageSource.banners, ImageSource.imageList]loading : function 图片加载中的回调方法 非必填 示例：loaded : funciton 图片记载完成后的回调 非必填 示例:加载器（ImageLoader.js）源码：let base = 0;\r\nlet Img = function(src) {\r\n this.src = src;\r\n this.status = false;\r\n this.fail = false;\r\n}\r\n \r\nlet loop = (o, res) => {\r\n let tem = Object.keys(o);\r\n tem.map(v => {\r\n if (typeof o[v] === 'object') {\r\n loop(o[v], res);\r\n } else {\r\n if(v === 'BASE') {\r\n base = o[v];\r\n } else {\r\n res.push(o[v]);\r\n }\r\n }\r\n });\r\n}\r\n \r\nfunction ImageLoader(obj) {\r\n let arr = [];  if(obj.loading) {\r\n this.loadingcallback = obj.loading;\r\n }\r\n if(obj.loaded) {\r\n this.loadedcallback = obj.loaded;\r\n }\r\n \r\n if(obj.base) {\r\n base = obj.base\r\n }\r\n this.insert = (item) => {\r\n arr.push(item);\r\n };\r\n \r\n this.init = (o) => {\r\n let res = [];\r\n loop(o, res);\r\n console.log(res)\r\n res.map((v) => {\r\n this.insert(new Img(v));\r\n });\r\n this.load();\r\n };\r\n \r\n this.load = () => {\r\n this.start = (new Date).getTime();\r\n arr.map((v) => {\r\n let src = base ? base + v.src: v.src;\r\n wx.getImageInfo({\r\n src: src,\r\n success: res => {\r\n v.status = true;\r\n },\r\n fail: err => {\r\n v.fail = true;\r\n }\r\n })\r\n });\r\n let timer = setInterval(() => {\r\n let status = this.isLoaded();\r\n if (status) {\r\n clearTimeout(timer);\r\n }\r\n }, 200);\r\n \r\n setTimeout(() => {\r\n clearTimeout(timer);\r\n }, 60000);\r\n };\r\n \r\n this.isLoaded = () => {\r\n let status = true,\r\n count = 0,\r\n fail = 0;\r\n arr.map((v) => {\r\n if (!v.status) {\r\n status = false;\r\n } else {\r\n count += 1;\r\n }\r\n if(v.fail) {\r\n status = true;\r\n fail += 1;\r\n }\r\n });\r\n if(status) {\r\n if(this.loadedcallback) {\r\n this.loadedcallback({\r\n status: true,\r\n timecost: (new Date).getTime() - this.start,\r\n success: count,\r\n fail: fail,\r\n totalcount: arr.length\r\n })\r\n }\r\n } else {\r\n if(this.loadingcallback) {\r\n this.loadingcallback({\r\n status: false,\r\n percent: count / arr.length\r\n });\r\n }\r\n }\r\n return status;\r\n };\r\n if(obj.source) {\r\n this.init(obj.source);\r\n }\r\n}\r\nmodule.exports = ImageLoader\r\n图片资源路径文件（imageSource.js）源码：module.exports = {\r\n \"BASE\": \"https://img.caibeitv.com/static_project/teacherTest/static/img/\",\r\n \"single1\": \"ghost.4449aa4.png\",\r\n \"single2\": \"ghost.4449aa4.png\",\r\n \"single3\": \"ghost.4449aa4.png\",\r\n \"single4\": \"ghost.4449aa4.png\",\r\n \"pages\": {\r\n \"index\": [\"ghost.4449aa4.png\", \"ghost.4449aa4.png\"],\r\n \"user\": [\"ghost.4449aa4.png\", \"ghost.4449aa4.png\"],\r\n \"home\": [\"ghost.4449aa4.png\", \"ghost.4449aa4.png\"],\r\n \"login\": [\"ghost.4449aa4.png\", \"ghost.4449aa4.png\"]\r\n },\r\n \"imageList\": [\r\n \"ghost.4449aa4.png\",\r\n \"ghost.4449aa4.png\",\r\n \"ghost.4449aa4.png\",\r\n \"ghost.4449aa4.png\",\r\n \"ghost.4449aa4.png\"\r\n ],\r\n \"folders\": {\r\n \"page1\": \"ghost.4449aa4.png\",\r\n \"page2\": \"ghost.4449aa4.png\",\r\n \"inner\": [\r\n \"ghost.4449aa4.png\",\r\n \"ghost.4449aa4.png\"\r\n ],\r\n \"home\": {\r\n \"poster\": \"ghost.4449aa4.png\"\r\n }\r\n }\r\n}\r\n说明：BASE 字段必填 根据自我需要填写。其他图片资源支持：1、直接key：value形式把图片路径写入，如：\"single1\": \"ghost.4449aa4.png\" \r\n2、类似于pages目录把每个页面的远程资源写入到对应位置下，方便引用和管理，如：\"pages\": {\r\n \"index\": [\"ghost.4449aa4.png\", \"ghost.4449aa4.png\"],\r\n \"user\": [\"ghost.4449aa4.png\", \"ghost.4449aa4.png\"],\r\n \"home\": [\"ghost.4449aa4.png\", \"ghost.4449aa4.png\"],\r\n \"login\": [\"ghost.4449aa4.png\", \"ghost.4449aa4.png\"]\r\n },\r\n3、直接以数组方式把图片堆放在一个数组里，如：\"imageList\": [\r\n \"ghost.4449aa4.png\",\r\n \"ghost.4449aa4.png\",\r\n \"ghost.4449aa4.png\",\r\n \"ghost.4449aa4.png\",\r\n \"ghost.4449aa4.png\"\r\n ] \r\n4、随意的资源数组，对象嵌套，如：\"folders\": {\r\n \"page1\": \"ghost.4449aa4.png\",\r\n \"page2\": \"ghost.4449aa4.png\",\r\n \"inner\": [\r\n \"ghost.4449aa4.png\",\r\n \"ghost.4449aa4.png\"\r\n ],\r\n \"home\": {\r\n \"poster\": \"ghost.4449aa4.png\"\r\n }\r\n }\r\n这样就完成了整个远程图片资源加载器的配置，可以在new ImageLoader() 对象的 loading, loaded回调中看到图片预加载的最终状态status，数量totalcount，成功加载的图片数量success，加载失败的图片数量fail, 加载图片的总计耗时timecost（单位ms）。创建ImageLoader对象时source字段的说明：new ImageLoader({\r\nbase: ImageSource.BASE,\r\nsource: [ImageSource],\r\nloading: res => {\r\n// 可以做进度条动画\r\nconsole.log(res);\r\n},\r\nloaded: res => {\r\n// 可以加载完毕动画\r\nconsole.log(res);\r\n}\r\n});\r\nsource字段接受一个Array类型的参数，以上文中imageSource.js中的配置来说，写了很多不同格式的数据，使用const ImageSource = require('./imageSource.js');\r\n引入后，可以直接使用ImageSource来读取各个部分的数据，因此在配置source字段时可以直接把整个ImageSource对象放入进去source: [ImageSource]\r\n也可以根据项目需要只加载其中一部分资源，如：source: [ImageSource.imageList, ImageSource.single2]\r\n这样加载器在执行时就会只载入source中写入的部分，而不是整个ImageSource。最后，在加载过程中如果过于耗时，可以选择在每个页面的onLoad里单独加载资源，做法类似于在app里调用，本文的示例是写在app.js的onLaunch中。如果加载时间过长可以做一个进度条或者加载动画，优化启动体验。预加载过的图片会在微信内存中缓存一到小程序进程被关闭，因此在随后的页面里可以直接使用图片。const app = getApp();\r\nconst imgSource = require('../../imageSource.js');\r\nPage({\r\n data: {\r\n base: imgSource.BASE,\r\n src: imgSource.single1\r\n },\r\n onLoad: function () {\r\n console.log(imgSource)\r\n }\r\n})\r\n页面上的Image会立即显示，不需要重新发起加载图片请求。个人研究结果，如有错误、不足欢迎批评指正，相互探讨。个人QQ: 837195936 熊专栏作家熊晨沣（个人QQ: 83719593）。小程序社区博主，坚持原创分享技术博文。本文原创发布于小程序社区。未经许可，禁止转载原文地址：小程序远程图片资源按需预加载-小程序社区/博主专区-微信小程序开发社区-微信小程序联盟"}
{"title": "实现一个扫描商品条码进行评价或留言的小程序（附源码） ", "author": "Rolan", "time": "2018-9-5 00:08", "content": "对准上面的小程序码，扫一下，‘嘀’~地一声，扫码成功，打开小程序，进入小程序首页。因为手头上没有可乐，所以我找来了一只非常专业的猫，扮演一瓶330ml的可口可乐演示给大家看。摁住它，对准它的条码，扫一下，‘喵’~地一声，说明猫跑掉了，扫码失败了，去追如果‘嘀’~地一声，说明扫码成功了，这时页面就自动跳到商品详情页。然后你就可以看得到别人在可口可乐下写的留言，当然你也可以点击右下角的蓝色按钮就发表你的留言了；原理：因为一个商品对应唯一一个条码，所以扫描同一个商品条码就可以进入唯一一个留言列表；全国各地的可口可乐330ml的条形码都是一样的，扫码后都会进入同一个页面条形码就像一个暗号，一句口令，一个邮差.. 当然，不只是条形码，二维码也可以留言，比如说别人的微信二维码一般是长时间不会变的，你可以码上说别人坏话。接下来详细介绍一下每个页面的功能2.首页首页有三个部分：1.用户的信息：头像和昵称；2.轮播图-可以放一些平时要展示的图片；3.扫码按钮-点击即可打开扫描条码；当用户点击扫码按钮时，我们就调用小程序的扫码接口去扫描商品条码，当用户扫描好条码后，我们就得到了商品条码（barcode）；这时，我们就可以跳转到商品详情页面了，顺便把条码传过去，这样商品详情页才能知道用户扫的是什么商品：wx.navigateTo({\r\n          url: \"/page/component/proDtl/proDtl?barcode=\" + barcode,  //把商品条码传给商品详情页\r\n    })\r\n复制代码3.商品详情页进入详情页后，我们的第一件事情：在生命周期onLoad中获取首页传过来商品条码，然后根据条码请求当前商品的留言列表，如果这个商品还没有人扫过的话，就可能没有留言，那我们只要显示“暂无留言”即可onLoad(options){\r\n       var barcode = options.barcode ? options.barcode:'';\r\n       this.getProductInfo(barcode)  //根据条码请求当前商品的留言列表\r\n  },\r\n复制代码在getProductInfo（）方法中，我们会向后台请求商品留言列表； 接着我们就把请求到的商品留言列表渲染到页面上:如果用户觉得请求到的商品名称是不对的，还可以点击名称进行编辑：最后，页面底部还有一个提交留言的小按钮：如果你要发表留言，你可以用你的食指点击它：点击按钮后，小程序就会跳到添加留言页面，顺便把商品条码信息传过去：turnToSubmit(){\r\n    wx.navigateTo({\r\n      url: \"/page/component/addNode/addNode?barcode=\" + this.data.barcode,\r\n    })\r\n  },\r\n复制代码4.添加留言页面如图，这时候我们就可以开始写我们的留言了。写完留言之后，你可以标注一下你的留言类型：如果你觉得你写的是一首诗，你可以选择类型为‘诗一首’；如果你觉得你写的是一封信，等待别人扫码阅读，你可以选择类型为‘鱼书’；如果你扫描的是一本书的条码，你可以选择类型为‘书摘’；类型的右边就是是上传图片功能，首先，我们点击'添加图片'小图标，这时就会使用小程序选择图片的接口打开相册或者直接拍照，得到图片之后，因为现在的手机图片拍照像素都比较高，导致图片比较大，上传会很慢，占服务器空间，请求也会很慢...所以为了优化用户体验，我们需要压缩一下图片然后再上传。wx.chooseImage({\r\n      count: 1, // 默认9  \r\n      sizeType: ['original'], // 可以指定是原图还是压缩图，默认二者都有\r\n      sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有\r\n      success: function (res) {  //图片选择成功之后\r\n        \r\n               var tempFilePaths = res.tempFilePaths;\r\n               self.compressedImg(res)  //调用compressedImg方法，先把图片压缩一下\r\n\r\n        }\r\n  })\r\n复制代码虽然小程序的选择图片接口可以设置默认压缩，但好像没什么用，还是需要找其他的方法压缩一下， 网上最普遍的图片压缩是使用了小程序提供的canvas画布，把用户上传的图片搞到画布上（....），然后根据画布上的图片高和宽判断图片是否过大，如果过大，就直接把画布按比例缩小：while (canvasWidth > 220 || canvasHeight > 220) {  //如果宽度或者高度大于220，我就认为图片要进一步压缩，你可以根据需求改成其他的数字\r\n          //比例取整\r\n      canvasWidth = Math.trunc(res.width / ratio)\r\n      canvasHeight = Math.trunc(res.height / ratio)\r\n      ratio++;\r\n   }\r\n复制代码图片的压缩参考自：[微信小程序：利用canvas缩小图片][ blog.csdn.net/akony/artic… ]然后把canvas上这张压缩了的图片上传到后台服务器：......\r\n   wx.uploadFile({  //上传图片\r\n          url: 'https://mp.orancat.com/proImgUpload',\r\n          filePath: photo.tempFilePath,  //压缩后的图片\r\n          name: 'file',\r\n          header: {\r\n            'content-type': 'multipart/form-data'\r\n          },\r\n          success: function (res) {\r\n    .......          \r\n\r\n复制代码图片上传成功之后，后台会返回上传图片的地址给我们，我们把图片渲染到页面上，用户就会知道图片上传成功了；最后点击'提交'按钮，就会把以下内容发送给后台，后台就会自动将留言保存到数据库；var data={\r\n      authorName: userName, //用户昵称\r\n      token: userId,  //用户ID\r\n      content: this.data.textContent, //留言文本内容\r\n      imgUrl: userImg,  //用户的头像\r\n      code: this.data.barcode,  //商品的条码\r\n      typeIndex: this.data.typeIndex, //留言的类型\r\n      nodeImgUrl: this.data.nodeImgUrl //用户上传的图片的地址\r\n    }\r\n复制代码留言提交成功之后，页面会自动切回商品详情页面，这时，你就可以看到自己刚刚的留言了；5.排行榜页面有过留言的商品都会出现在排行榜页面，并且按照留言的数量多少进行排列，点击单个商品就查看该商品下的留言；6.其他实现的功能1.分页在商品详情页，有可能出现这种情况，比如说假设A商品有120条留言，如果一进A商品详情页就要加载120条留言的话，可能页面加载半天都没有出来；这样的话用户体验就会非常不好。所以相对理想的方式应该是，假设12条留言为一页，那么A商品的留言总共有10页，当我们进入A商品的详情页面时，先加载第一页（前12条留言），当我们往上滑动页面到底部时就自动加载下一页的内容，一页一页按需加载；我们使用小程序提供的OnReachBottom触底事件实现分页加载，当用户滑动留言列表到底部时触发加载下一页：onReachBottom: function () { //滑动到底部时触发\r\n       this.setData({\r\n           bottomLoading: true  // 显示loading提示\r\n       })\r\n       this.getRankList()  //请求下一页数据\r\n  }\r\n复制代码同理，排行榜页面也使用了分页加载；2.通过wx.login获取用户唯一凭证openId由于用户的昵称，头像什么的都可能随时会改变，当openID不会变，所以使用openId作为用户唯一凭证；虽然我获取了用户的Id，但暂时还没有使用到；如果以后要弄个用户个人主页或者留言回复等等可能就要用到openId；3.gif图片上传如上所述，在图片上传前，我们把图片压缩了一下 如果图片是jpeg，png时没问题的 但如果图片时gif动图的话，那可能会导致动图不会动了（可能直接变成jpeg图片？） 所以我另外加了一个判断：如果图片时gif格式的话，就不压缩图片,直接上传：if(res.type=='gif'){\r\n       if(res.width>666||res.height>666){ //如果图片太大了，拒绝上传\r\n         wx.hideLoading()\r\n         wx.showModal({\r\n           title: '提示',\r\n           content: '动图太大了，请上传小一点的',\r\n           showCancel: false\r\n         })\r\n         return false;\r\n       }\r\n       res.tempFilePath=res.path;\r\n       _this.uploadImg(res)  //上传图片\r\n       return false;\r\n    }\r\n复制代码这样在window和安卓下就可以上传gif图片了。苹果手机呢？？咳咳..苹果手机一打开相册选动图，动图就自动变成了jpeg的不动图...所以苹果手机暂时上传不了动图，似乎没有解决办法。。7.下载与本地电脑运行在本文底部的github地址下载源码，用微信开发者工具，填上你的小程序appId，打开项目即可；记得在开发者工具点击‘’详情‘’设置不校验域名：如果你要提交审核并分布小程序的话，你需要在公众号平台上的\"设置>开发设置\"页面上设置小程序的服务器域名如下：然后，由于一般电脑没有摄像头不能扫码，所以当你需要扫码时，你可以把下面这张条码图片保存在本地电脑上，点击扫码按钮时打开这张图片即可：当然，你也可以自己找其他的条码；另外，需要注意的是，当你在本地电脑调试时，由于我们都是使用同一个后台接口，所以你发的留言都会同步到我的小程序上，所以尽量不要发送太明显的测试留言，例如：可以发一些强颜欢笑，积极向上，人畜无害的留言，例如："}
{"title": "Web直播，你需要先知道这些 ", "author": "Rolan", "time": "2018-9-5 00:12", "content": "转自IMWeb社区，作者：Terrance，原文链接一、直播知识小科普一个典型的直播流程：录制->编码->网络传输（推流->服务器处理->CDN分发）->解码->播放IPB：一种常用的视频压缩方案，用I帧表示关键帧，B帧表示前向差别帧，P帧表示双向差别帧GOP (Group of Pictures)：GOP 越长（I帧之间的间隔越大），B 帧所占比例越高，编码的率失真性能越高。虽然B帧压缩率高，但解码时CPU压力会更大。音视频直播质量好坏的主要指标： 内容延时 、 卡顿（流畅度） 、 首帧时长音视频直播需要克服的主要问题：网络环境、多人连麦、主辅路、浏览器兼容性、CDN支持等MSE (Media Source Extensions)：W3C 标准API，解决 HTML5 的流问题（HTML5 原生仅支持播放 mp4/webm 非流格式，不支持 FLV），允许JavaScript动态构建 <video> 和 <audio>的媒体流。可以用MediaSource.isTypeSupported() 判断是否支持某种MINE类型。在ios Safari中不支持。文件格式/封装格式/容器格式 ：一种承载视频的格式，比如flv、avi、mpg、vob、mov、mp4等。而视频是用什么方式进行编解码的，则与Codec相关。举个栗子，MP4格式根据编解码的不同，又分为nMP4、fMP4。nMP4是由嵌套的Boxes 组成，fMP4格式则是由一系列的片段组成，因此只有后者不需要加载整个文件进行播放。Codec ：多媒体数字信号编码解码器，能够对音视频进行压缩（CO）与解压缩( DEC ) 。CODEC技术能有效减少数字存储占用的空间，在计算机系统中，使用硬件完成CODEC可以节省CPU的资源，提高系统的运行效率。常用视频编码 ：MPEG、H264、RealVideo、WMV、QuickTime。。。常用音频编码 ：PCM、WAV、OGG、APE、AAC、MP3、Vorbis、Opus。。。二、现有方案比较RTMP协议基于TCPadobe垄断，国内支持度高浏览器端依赖Flash进行播放2~5秒的延迟RTP协议Real-time Transport Protocol，IETF于1996提出的一个标准基于UDP实时性强用于视频监控、视频会议、IP电话CDN厂商、浏览器不支持HLS 协议Http Live Streaming，苹果提出的基于HTTP的流媒体传输协议HTML5直接支持(video)，适合APP直播，PC断只有Safari、Edge支持必须是H264+AAC编码因为传输的是切割后的音视频片段，导致内容延时较大flv.jsBilibli开源，解析flv数据，通过MSE封装成fMP4喂给video标签编码为H264+AAC使用HTTP的流式IO(fetch或stream)或WebSocket协议流式的传输媒体内容2~5秒的延迟，首帧比RTMP更快WebRTC协议1、Google力推，已成为W3C标准2、现代浏览器支持趋势，X5也支持（微信、QQ）3、基于UDP，低延迟，弱网抗性强，比flv.js更有优势4、支持Web上行能力5、编码为H264+OPUS6、提供NAT穿透技术（ICE）实际情况下，当用户数量很大时，对推流设备的性能要求很高，复杂的权限管理也难以实现，采用P2P的架构基本不可行。对于个别用户提供上行流、海量用户只进行拉流的场景，腾讯课堂实现了一种P2S的解决方案。 进一步学习可阅读jaychen的系列文章《WebRTC直播技术》。三、小程序+直播技术方案基于RTMP，官方说底层使用HTTP/2的一种内部传输机制，但又说是基于UDP的，这就搞不懂了。。。live-pusher 和 live-player 没有限制第三方云服务可直接使用腾讯云视频直播能力，只需配置好推流url、播放url即可推流url：播放url：下面是我根据官网教程搭建的一个音视频小程序，搭建过程简单，同一个局域网下直播体验也很流畅（读者也可直接搜索 腾讯视频云 小程序进行体验）：前端核心代码还是相当简洁的：live-pusher组件：设置好url推流地址（仅支持 flv, rtmp 格式）等参数即可，使用bindstatechange获取播放状态变化<view id='video-box'>  \r\n    <live-pusher\r\n          id=\"pusher\"\r\n          mode=\"RTC\"\r\n          url=\"{{pusher.push_url}}\" \r\n          autopush='true'\r\n          bindstatechange=\"onPush\">\r\n    </live-pusher>  \r\n </view>\r\n复制代码live-player组件：设置后src音视频地址（仅支持 flv, rtmp 格式）等参数即可，使用bindstatechange获取播放状态变化<view id='video-box'>  \r\n    <live-player\r\n        wx:for=\"{{player}}\"\r\n        id=\"player_{{index}}\"\r\n        mode=\"RTC\"\r\n        object-fit=\"fillCrop\"\r\n        src=\"{{item.playUrl}}\" \r\n        autoplay='true'\r\n        bindstatechange=\"onPlay\">\r\n   </live-player>\r\n </view>\r\n复制代码能否和WebRTC同时使用?对于腾讯课堂的应用场景，老师上课推流采用的是RTMP协议，考虑到WebRTC目前只能用于PC端拉流，那么在移动端能否让用户可以直接通过小程序来观看直播课呢？我觉得在技术层面可行的，接入小程序直播对于扩大平台影响力、社交圈分享、提高收费转化都会产生很大的帮助。难点在于复杂的权限控制、多路音视频流、多人连麦等问题，比如权限控制只能单独放到房间控制逻辑中完成，而音视频流本身缺乏这种校验；主辅路的切换还需要添加单独的信令控制，同时在小程序中加入相应的判断逻辑。"}
{"title": "微信小程序接入百度统计 ", "author": "Rolan", "time": "2018-9-5 00:28", "content": "一. 百度统计添加应用，获取appkey和微信小程序统计sdk:百度统计首页，点击“我的全部应用”右侧的添加按钮：“应用类型”选择小程序统计，选择微信小程序，填写应用名称信息，选择内容分类，然后点击创建应用：获取到AppKey,下载微信小程序统计SDK，然后就可以在小程序中接入统计了，在这个页面下边就有SDK接入说明了。二. 微信小程序接入：把下载的微信小程序统计SDK解压后的mtj-wx-sdk.js和mtj-wx-sdk.config.js复制到小程序项目的utils文件夹中去：打开mtj-wx-sdk.config.js文件，将上边复制的appkey填写进去：编辑app.js,最顶部添加以下代码：const mtjwxsdk = require('./utils/mtj-wx-sdk.js');登录微信公众平台，进入小程序的设置->开发设置->服务器域名，把https://hmma.baidu.com加入request合法域名：三. 微信开发者工具中刷新项目配置：首次配置百度统计SDK，微信开发工具可能会报以下错误：如果已经在微信公众平台中把https://hmma.baidu.com加入request合法域名，那么就要刷新下开发工具的项目配置，如图,点下工具栏最右侧的“详情”，在详情弹窗界面中点击下“域名信息”，然后开发者工具就会自动刷新配置的，等https://hmma.baidu.com的域名刷新出来，就可以重新编译项目了："}
{"title": "小程序tab点击监听方法：onTabItemTap() ", "author": "Rolan", "time": "2018-9-5 00:37", "content": "page()的详细生命周期，可以查看文档，今天主要说下其onTabItemTap()方法，很少用到，但我们在开发中为了解决一些问题（在此方法中触发登录界面），试用下此方法：方法说明Triggered when the user taps the tab if the current page is a tab page（当点击tab界面时触发）测试代码：  /** tab点击 */  onTabItemTap(item) {    console.log(item)    wx.showToast({      title: 'tab点击',    })  },  /**   * 生命周期函数--监听页面显示   */  onShow: function() {    self = this;    app.NetUtil.CheckLoginStatus(null, function(loginStatus) {});    ···分别在模拟器、iOS系统、Android系统分别测试，结果如下：效果图小程序模拟器：三个tab切换时，不会触发onTabItemTap()方法，如果已经在“个人中心”界面，再次点击tab，会触发该方法，而且点击几次，触发几次，没有APP的tab那么好使。iOS版微信的小程序：切换正常触发，多次点击可以根据自己的需要做相应处理。Android版微信（OPPO）的小程序：切换正常触发，多次点击可以根据自己的需要做相应处理。作者：恩来客 链接：https://www.jianshu.com/p/2e8370b7c760"}
{"title": "微信小程序云端解决方案教程一：文件上传下载应用场景 ", "author": "天下雪", "time": "2016-10-15 16:55", "content": "内容架构：部署和运行整体架构1. 准备域名和证书2. 云主机和镜像部署3. 配置 HTTPS4. 域名解析5. 开通和配置 COS6. 启动小相册示例 Node 服务7. 微信小程序服务器配置8. 启动小相册 Demo主要功能实现上传图片获取图片列表下载和保存图片删除图片微信小程序提供了一套在微信上运行小程序的解决方案，有比较完整的框架、组件以及 API，在这个平台上面的想象空间很大。小相册是结合腾讯云对象存储服务（Cloud Object Service，简称COS）制作的一个微信小程序示例。在代码结构上包含如下两部分：applet: 小相册应用包代码，可直接在微信开发者工具中作为项目打开server: 搭建的 Node 服务端代码，作为服务器和applet通信，提供 CGI 接口示例用于拉取 COS 图片资源、上传图片到 COS、删除 COS 图片等。小相册主要功能如下：列出 COS 服务器中的图片列表点击左上角上传图片图标，可以调用相机拍照或从手机相册选择图片，并将选中的图片上传到 COS 服务器中轻按任意图片，可进入全屏图片预览模式，并可左右滑动切换预览图片长按任意图片，可将其保存到本地，或从 COS 中删除部署和运行拿到了本小程序源码的朋友可以尝试自己运行起来。整体架构1. 准备域名和证书在微信小程序中，所有的网络请求受到严格限制，不满足条件的域名和协议无法请求，具体包括：只允许和在 MP 中配置好的域名进行通信，如果还没有域名，需要注册一个。网络请求必须走 HTTPS 协议，所以你还需要为你的域名申请一个证书。域名注册好之后，可以登录微信公众平台配置通信域名了。2. 云主机和镜像部署小相册的服务器运行代码和配置已经打包成腾讯云 CVM 镜像，大家可以直接使用。镜像已包含所有小程序的服务器环境与代码，需要体验其它小程序的朋友无需重复部署3. 配置 HTTPS镜像中已经部署了 nginx，需要在 /etc/nginx/conf.d 下修改配置中的域名、证书、私钥。配置完成后，即可启动 nginx。nginx4. 域名解析我们还需要添加域名记录解析到我们的云服务器上，这样才可以使用域名进行 HTTPS 服务。在腾讯云注册的域名，可以直接使用云解析控制台来添加主机记录，直接选择上面购买的 CVM。解析生效后，我们在浏览器使用域名就可以进行 HTTPS 访问。5. 开通和配置 COS小相册示例的图片资源是存储在 COS 上的，要使用 COS 服务，需要登录 COS 管理控制台，然后在其中完成以下操作：开通 COS 服务分配得到唯一的APP ID使用密钥管理生成一对SecretID和SecretKey（用于调用 COS API）在 Bucket 列表中创建公有读私有写访问权限、CDN加速的 bucket（存储图片的目标容器）6. 启动小相册示例 Node 服务在镜像中，小相册示例的 Node 服务代码已部署在目录/data/release/qcloud-applet-album下：进入该目录：cd /data/release/qcloud-applet-album在该目录下有个名为config.js的配置文件（如下所示），按注释修改对应的 COS 配置：module.exports = {    // Node 监听的端口号    port: '9993',    ROUTE_BASE_PATH: '/applet',    cosAppId: '填写开通 COS 时分配的 APP ID',    cosSecretId: '填写密钥 SecretID',    cosSecretKey: '填写密钥 SecretKey',    cosFileBucket: '填写创建的公有读私有写的bucket名称',};小相册示例使用pm2管理 Node 进程，执行以下命令启动 node 服务：pm2 start process.json7. 微信小程序服务器配置进入微信公众平台管理后台设置服务器配置，配置类似如下设置：注意：需要将 www.qcloud.la 设置为上面申请的域名，将 downloadFile 合法域名设置为在 COS 管理控制台中自己创建的 bucket 的相应 CDN 加速访问地址，如下图所示：8. 启动小相册 Demo在微信开发者工具将小相册应用包源码添加为项目，并把源文件config.js中的通讯域名修改成上面申请的域名。然后点击调试即可打开小相册Demo开始体验。这里有个问题。截止目前为止，微信小程序提供的上传和下载 API 无法在调试工具中正常工作，需要用手机微信扫码预览体验。主要功能实现上传图片上传图片使用了微信小程序提供的wx.chooseImage(OBJECT)获取需要上传的文件路径，然后调用上传文件接口wx.request(OBJECT)发送 HTTPS POST 请求到自己指定的后台服务器。和传统表单文件上传一样，请求头Content-Type也是multipart/form-data。后台服务器收到请求后，使用 npm 模块 multiparty 解析 multipart/form-data 请求，将解析后的数据保存为指定目录下的临时文件。拿到临时文件的路径后，就可直接调用 COS SDK 提供的文件上传 API 进行图片存储，最后得到图片的存储路径及访问地址（存储的图片路径也可以直接在 COS 管理控制台看到）。获取图片列表调用列举目录下文件&目录 API可以获取到在 COS 服务端指定 bucket 和该 bucket 指定路径下存储的图片。下载和保存图片指定图片的访问地址，然后调用微信小程序提供的wx.downloadFile(OBJECT)和wx.saveFile(OBJECT)接口可以直接将图片下载和保存本地。这里要注意图片访问地址的域名需要和服务器配置的 dowmloadFile 合法域名一致，否则无法下载。删除图片删除图片也十分简单，直接调用文件删除 API 就可以将存储在 COS 服务端的图片删除。"}
{"title": "Runlin微信小程序系列教程一：从零开始写一个demo《上》 ", "author": "天下雪", "time": "2016-10-16 18:55", "content": "本文已获得原作者授权微信小程序内测至今也有20天左右，也有很多人作出了很多不错的DEMO并发布到github了。前几日看见了豆瓣电影这个demo，感觉很不错，也跟着做了一个，作为复习巩固文档API用。废话不多说，直接进入正题：第一节只写一个首页的展示，数据用的是自己写的虚拟的数据 新建一个demo，不要使用微信自带的DEMO，直接从零开始写起：首先创建3个文件：app.jsonapp.jsapps.wxss app.json  : 主要写配置项：内容如下，具体的每个key值对应的意思，这里就不再细说了，可以看我之前的配置指南，{\"pages\":[\"pages/index/index\",\"pages/rank/rank\",],\"window\":{\"enablePullDownRefresh\":true,\"backgroundColor\":\"#eee\",\"navigationBarTitleText\": \"上导航标题文字\",\"navigationBarTextStyle\":\"white\" },\"tabBar\": {\"color\": \"#d7ced5\",\"selectedColor\": \"#535f71\",\"borderStyle\": \"white\", \"backgroundColor\": \"#f9f9f9\",\"list\": [ {\"pagePath\": \"pages/index/index\", \"text\": \"推荐电影\", \"iconPath\": \"images/board.png\", \"selectedIconPath\": \"images/board-actived.png\" },{\"pagePath\": \"pages/rank/rank\",\"text\": \"北美票房\",\"iconPath\": \"images/note.png\",\"selectedIconPath\": \"images/note-actived.png\"}]},\"networkTimeout\": {\"request\": 10000,\"downloadFile\": 9000,\"uploadFile\":8000,\"connectSocket\":7000},\"debug\": true} app.js  :  主要用来注册一个小程序的实例 App({onLaunch: function () {},onShow: function () {},onHide: function () {},globalData: 'I am global data'});  app.wxss : 公用样式，基本等同于CSS，暂时不需要写内容。 创建好3个文件后，就可以开始写页面的内容了：新创建2个文件夹images和pages，一个放图片一，个放页面。目前只pages下面再创建2个文件夹index和rank，每个文件下分别创建json,js,wxml,wxss文件，此时目录如下：虽然不一定4个文件类型都需要用到，但为了之后方便，建议还是先创建好，需要用到的时候就比较方便了，不用再去创建。首先写index.js:   (为了模拟循环数组，data下面的moivelist还需要多复制几份，这里只写了一份出来，imgsrc路径要写好) Page({    data:{    moivelist:[{    imgsrc: \"../../images/AN2.jpg\",    title: \"肖申克的救赎\",    introduce: \"The shrakwos RedenpeTion(1994)\",    author: \"弗兰克*德拉立邦\",    rank: \"9.6\"}]},onLoad: function(options) {console.log(1);},onReady: function() {// Do something when page ready.},onShow: function() {// Do something when page show.},onHide: function() {// Do something when page hide.},onUnload: function() {// Do something when page close.},onPullDownRefresh: function() {// Do something when pull down},// Event handler.viewTap: function() {this.setData({text: 'Set some data for updating view.'})}})这里出现了很多on函数事件，对应页面的生命周期每个过程对应的事件，这里暂时先关注data对象小程序是以数据驱动的，页面进来的时候通过动态获取数据，通过{{xxx}}将数据绑定，并将数据渲染到视图层，这里先以一个虚拟的data数据模拟 然后写index.wxml文件：从上面显示的首页的图片来看，主要是1个标题，以及下面一个列表，列表用过循环来渲染出所有的数据标题:  标题比较简单，主要是写css<view class=\"head-title\"><text>豆瓣电影top250</text></view>这里主要讲下面的列表循环，可以发现我们只要写好列表中的第一个就可以了，其他的通过循环来展示列表主要分为左中右三块，分别为图片，内容，以及评分3块<block wx:for=\"{{moivelist}}\">  //循环渲染，wx:for=\"{{ xxx }}\" 代表循环js文件里面的data数据中的xxx<view>//微信循环时会给出每个项目的内容以及每个项目的下标，默认为item和index，item.imgsrc意为对象的（imgsrc）  key值图片：<image class=\"moive-img\" style=\"\" mode=\"\" src=\"{{item.imgsrc}}\" binderror=\"\" bindload=\"\"></image>内容：<view class=\"moive-content\">     <view class=\"content-titile\">        <text >{{item.title}}</text>    </view>    <view class=\"content-introduce\">         <text >{{item.introduce}}</text>    </view>    <view class=\"content-author\">        < text >{{item.author}}</text>\t    </view>\t</view>评分：<text class=\"content-rank\">{{item.rank}}</text></view></block>   基本都这里wxml就结束了，样式主要通过wxss来操作，样式比较简单，就不写了，主要讲一下左中右这三块通过将左中右这三块的父级设置为display:flex;左边和右边都设置为固定rpx，中间设置为flex:1。这样写代表中间这一块的内容占满：左边和右边布局后生下来的空间 ，即左右布局好后，剩多少，flex：1就等于多少。 第一节项目代码见：demo1https://github.com/linrunzheng/wx-samll-demo"}
{"title": "微信小程序实战教程：火车票查询（含demo） ", "author": "天下雪", "time": "2016-10-17 22:25", "content": "界面展示  结合动态图描述一下目前实现的功能：2.1 主页上半部分显示用户头像与用户名（和微信中的信息一致，这部分组件是工具自带的，我们可以修改这部分组件和内容，稍候会提到）；下半部分显示一个经典的问候语“Hello World”，提供一个可点击的按钮“点击获取火车票”；2.2 点击按钮后，通过事先指定的参数（调用了百度APIStore中去哪网火车票查询接口，站-站查询所需参数为始发地、目的地及时间）发送网络请求，将获取到的JSON数据按火车车次为节点进行解析并在新页面显示基本信息（除了详细座位信息），为每个车次提供一个可点击的按钮“点击查看座位信息”；2.3 点击某车次中的座位查询按钮后，会将该车次对应的所有座位信息显示在新页面中；2.4 点击后两个页面左上角的“返回”按钮可回到上一页，这个功能也是工具自带的； 顺便提一下在博客园中插入动画，上面的演示过程是一张格式为gif的图片，像添加普通图片一样操作即可。录制工具使用的是灵者Gif录制，可以指定开始、停止时所需操作与区域等录制信息。  3. 要点分析关于微信小程序工具的使用及初始项目的结构说明，网上资源已经很丰富，这里不打算再啰嗦 下面开始讲讲我个人在学习与开发过程中认为值得分享与记录的点，欢迎大小神们一起讨论与指正，特别是讲得不对或有待改善的地方。下面只给出和讲的点直接相关的代码，整体代码可以到项目工程中去查看，建议大家自己调试一遍。 3.1 indexindex是项目新建时自动生成的，作为小程序的启动页面。3.1.1 index.wxml首页的头像与用户名，从上图的演示过程可以看出我将微信的名字“***”改成了“用户名”：<view  bindtap=\"bindViewTap\" class=\"userinfo\"> 　　<image class=\"userinfo-avatar\" src=\"{{userInfo.avatarUrl}}\" background-size=\"cover\"></image> 　　<text class=\"userinfo-nickname\">用户名</text>  <!-- {{userInfo.nickName}}直接写成“用户名” --></view>用户名部分原本的内容为{{userInfo.nickName}}，{{key_name}}的作用是获取关键字名为key_name对应的值（数据一般以key_name:value的形式定义在wxml文件同目录下js文件的data成员中，后面会讲解），image显示的头像资源也是通过这种方式指定为src=\"{{userInfo.avatarUrl}}\"，程序中产生的数据可以在开发者工具顶部偏右的AppData栏中查看。如果不需要从js文件中获取数据，那么可以像代码中“用户名”那样直接写入数据值，不过一般不推荐这样做，因为像Android等平台App在开发时会将数据值放入strings.xml等文件，目的是为了将数据与布局分离，布局和功能实现代码分离，方便开发与维护。组件中的class项用来设置其样式，属性名对应的样式信息定义在wxss文件中，除了可以使用定义在本目录wxss文件中的样式，还可以使用app.wxss文件中定义的。如果样式只是在某页面中使用，那么建议定义在其目录下的wxss文件中，即局部作用域内；如果是多个页面共同使用，即全局样式，那么一般定义在主程序app.wxss文件中。class样式可以指定组件的宽高、背景颜色等属性，本文不再进行详述。在界面下方添加按钮“点击获取火车票”组件：<view class=\"gettrain-button\" bindtap=\"getTrainInfo\"> 　　<text>点击获取火车票</text> </view>按钮的目标是为了让用户可以点击进行交互，至于使用button、text或其他组件，视具体需求而定。这里是利用text组件，文本内容直接写入了字串“点击获取火车票”，对于只有一个子组件的布局其实可以如下面代码不用嵌套，一层布局搞定。一般来说嵌套层数越少，加载速度越快，这对移动程序的体验是至关重要的。<view class=\"gettrain-button\" bindtap=\"getTrainInfo\"> 　　点击获取火车票 </view>但如果在父容器下有多个子组件共享其定义的样式，那么嵌套可以另代码简洁很多：<view class=\"gettrain-button\"> 　　<text bindtap=\"getTrainInfo\">点击获取火车票</text> 　　<text bindtap=\"getCarInfo\">点击获取汽车票</text> 　　<text bindtap=\"getPlaneInfo\">点击获取飞机票</text> </view>组件若要有点击交互功能，须为其绑定事件响应方法，常用的有单点--bindtap，长按--binglongtap。bindtap=\"getTrainInfo\"，双引号中的文本是方法名称，在js文件中以该名定义方法，做需要的处理即可。3.1.2 index.js 实现wxml布局中按钮“点击获取火车票”绑定的函数功能：//获取火车票函数getTrainInfo: function() {    wx.request({        url: 'http://apis.baidu.com/qunar/qunar_train_service/s2ssearch',        header: {            apikey: '361cf2a2459552575b0e86e0f62302bc',        },        data: {            version: '1.0',            from: '北京',            to: '杭州',            date: '2016-11-15',        },        success: function(res) {            var json = res.data;            //将JSON类型转为String类型用以url参数传递，否则传递后会变成[object Object]            var jsonString = JSON.stringify(json);            wx.navigateTo({                url: '../train/train?trainInfos='+jsonString,            });        },    });},我们先来看看微信小程序官网对于网络请求方法--wx.request(OBJECT)的说明： 一般来说，wx api提供的方法默认会有一个Object参数，需要时传入，不需要时不传便是。不过这对于像我这种Android开发者来说一开始有点不适应，怎么函数调用时都传入一个{...}参数，内部各个项之间用逗号“,”分隔，代码中的url、data等。从代码中看，发起网络请求时传入了图中列出的四项参数：url、header、data及success，不同需求传入的参数也会不同。对于wx.request方法而言，需根据网络请求目标来传参数的是前四项：url、header、data及method。以本案例利用百度APIStore去哪网火车票获取站--站火车票信息来说（http://apistore.baidu.com/apiworks/servicedetail/697.html），其官网给出的接口调用的参数信息与格式如下：将上面两张图中的信息结合起来看，参数是一一对应的：wx url——火车票查询 接口地址；header——请求参数header；data——请求参数urlParam；method——请求方法；因为wx中的method参数默认是GET，和火车票查询接口指定的一致，所以调用时可以省略。而对于最后三个回调函数：success、fail及comlete，代码中添加了success，在请求成功时对数据进行处理。当然，一般的程序还得对请求失败的情况做处理。下面就来分析success方法中的代码，包括JSON数据的转换与新页面的跳转，请求返回的数据以参数res的形式传入到function中。先来看看res中包含了哪些信息，通过代码console.log(res)可以将其打印在工具调试页面的Console项中。request--ok和statusCode--200表示请求成功，所以才会回调success方法。而data对象才是我们需要的数据，更精确地说，data.data.trainList对象才是真正的火车票信息。var json = res.data，获取data对象（网络请求返回的数据一般为JSON格式），赋给变量json；var jsonString = JSON.stringify(json)，将JSON类型对象暂时转换为String类型，用来作为url的参数部分进行传递；一开始在这里耽搁了很久，不进行转换直接传的话在目标页面获取不到想要的数据，下面会说明原因；url: '../train/train?trainInfos='+jsonString，通过url指定的信息跳转到对应页面，如果不需要额外参数，直接写url: '../train/train'；如果只是传递简单的值，可写成url: '../train/train?param=123'；至此，如果网络没有问题，点击按钮便可以进行火车票的查询并携带结果数据跳转到新页面了。 3.2 traintrain是自定义新建的页面，用来显示火车票基本信息，注意新添的页面需在app.json文件中进行配置。\"pages/train/train\",  //火车票车次信息页面 \"pages/seat/seat\"  //车次余票信息页面3.2.1 train.wxml由于站--站火车票所有车次的始发站和终点站是一样，如北京--杭州东，所以先在页面顶部显示站点信息：<text class=\"train-item\">出发地：{{trainList[0].from}}</text><text class=\"train-item\">目的地：{{trainList[0].to}}</text>trainList对象会在js文件中定义成data成员，值为上面最后一张图中的JSON对象--trainList，即火车票车次数组，每个元素包含一个车次的具体信息。接下来显示每个车次的信息，以横线作分隔（由于是以学习和测试为目的，所以就没有在布局的美观上下功夫，大家见谅）：<view class=\"line\"></view><block wx:for=\"{{trainList}}\" wx:for-item=\"train\">    <text class=\"train-item\">{{index+1}}. 车次：{{train.trainNo}}</text>    <text class=\"train-item\">车型：{{train.trainType}}</text>    <text class=\"train-item\">起始时间：{{train.startTime}}</text>    <text class=\"train-item\">到站时间：{{train.endTime}}</text>    <text class=\"train-item\">总时长：{{train.duration}}</text>    <view id=\"trainindex-{{index}}\" class=\"getseat-button\" bindtap=\"getSeatInfo\">        <text>点击查看座位信息</text>    </view>    <view class=\"line\"></view></block>第1、11行很简单，在站点与车次、车次与车次之间添加横线。当布局中的组件个数和js中的数据有关，即在wxml中写死组件不能满足需求时，可以利用block和wx:for来进行组件的动态生成。第2行wx:for=\"{{trainList}}\"表示block块中的组件可以使用数组trainList中的内容，从下标0开始迭代，数据中有几个元素，就会动态生成几套组件。wx:for-item=\"train\"指定数组中元素的名称为train（默认的是item，指定的意义之一是可读性强），后续获取属性值时可通过train.key_name的形式。第3行开始添加组件，类型是text，值为{{index+1}}. 车次：{{train.trainNo}}，前半部分用来标明每个车次的序号，从1开始；而index和item类似，是默认的迭代索引名称，其实就是数组元素当前的下标，从0开始。后面几行添加text组件和第3行差不多，但第8行有两个点说一下：*1 bindtap=\"getSeatInfo\"，绑定一个回调函数，点击时跳转到新页面，显示当前车次对应的座位信息；*2 id=\"trainindex-{{index}}\"，给组件指定id，可以看到之前的组件都没有设置过该属性（不需要就可以不设置），那么什么时候需要呢？其中一种情况，当js中某组件绑定的回调方法需要得知是哪个组件触发了自己的时候，比如第一点中的方法getSeatInfo，要想点击某车次的查看座位信息按钮后显示出对应的座位信息，就得知道点击组件对应的trainList数组下标，而这个需求，正好可以借助id和index属性来实现；3.2.2 train.js首先定义data成员trainList，用来接收index页面传递过来的数据：trainList: []页面启动时若有数据需要载入，那么得添加onLoad方法（一开始自动运行，在其中实现数据的加载与处理），否则可以不添加。onLoad: function(options) {　　var jsonString = options.trainInfos;　　//将字串类型转为JSON类型　　var json = JSON.parse(jsonString);　　this.setData({    　　trainList: json.data.trainList,　　});},当方法的调用者有参数传入时，我们可以通过添加方法参数的形式来获取。对于参数名，自动启方法一般为options，组件回调方法一般为e（event）。第2行获取index页面在打开train页面时传入的火车票信息参数trainInfos。第4行将String类型对象转换回JSON格式，之前在index页面提到过，url传的参数是由JSON格式对象转换过来的String类型。第6行将真正的火车票车次信息数组取出，赋给数据成员trainList。注意：给数据成员赋值时，必须调用页面自身的setData方法，否则就算赋值了也不会同步到wxml文件中去，这一点容易出错且不好定位原因。车次数组得到后，wxml文件就会根据组件的属性设置显示对应的信息。再来看实现按钮“点击查看座位信息”对应的回调方法：getSeatInfo: function(e) {    var prefix = 'trainindex-';    var trainIndex = e.currentTarget.id.substring(prefix.length);    //输出根据组件id获取的车票索引，用以显示详细的座位信息    console.log(trainIndex);    var trainNo = this.data.trainList[trainIndex].trainNo;    var json = this.data.trainList[trainIndex].seatInfos;    //将JSON类型转为String类型用以url参数传递，否则传递后会变成[object Object]，同时传递车次    var jsonString = JSON.stringify(json);    wx.navigateTo({        url: '../seat/seat?'+'trainNo='+trainNo+'&seatInfos='+jsonString,    });},第2、3行获取之前定义的组件id中的index部分，即点击组件对应的trainList数组的下标。当然原先定义时也可以不添加前缀'trainindex-'，完全是为了可读性，因为当项目越来越大时有个一目了然的标示总是不错的。第6、7行分别获取车次信息的列车号与座位信息，他们稍候会被传递到seat页面。第9行同样地将得到的JSON格式对象先转换为String类型，让其可以在url中作为可被正确传递的参数。第11行打开新的页面seat显示座位信息，多个参数之间以“&”符号分隔。3.2.3 train.json主程序中app.json文件除了配置需要调用onLoad方法的页面外，还指定了一些全局的window样式。若某个页面在自己的json文件中没有定义局部的window属性，或根本没有json文件，那默认将使用全局的。项目初始没有为index生成json文件，因为其作为启动页，直接用全局的“WeChat”就好，其实index标题应该是小程序的名称，我们自己真正开发的程序肯定得取另一个名字。可以看到，logs、train及seat都对标题进行了定义，结果就是会覆盖掉全局的值。以train为例，其在json文件中定义标题为“站-站火车查询信息”：{ 　　\"navigationBarTitleText\": \"站-站火车查询信息\" }还有一点，页面的json文件不需要也不能页面配置属性（Pages），只能设置window属性，所以就可以省略window名称，直接像上述代码用{...}形式即可。 3.3 seatseat页面用来显示某车次的座位信息，包括座位等级、票价及余票。通过train页面的分析，相信大家对网络请求，数据在页面与页面、wxml与js文件之间的传递渐渐熟悉了。而seat和train类似，没有什么特别的地方，所以和logs一样这里就不再讲什么了。 4. 小感悟 微信小程序，虽然目前还不知道其在微信的接入口，但应该和订阅号、服务号以及企业号会有所不同。搜索打开使用，用完关闭，没有移动app的安装、下载等过程，微信流量大，轻便、易用等特性是其优点。然而正是因为这个优点，开发者担心这有可能使得小程序不能够像app那样强大，毕竟接入口、审核机制、推广成本以及最大允许内存等这些还未确定的因素对一款应用来说都是至关重要的。对于初学者（如原先搞android开发），暂且不管上面提到的那些，在弄明白应用需求的同时，得迈开并加快对前端知识学习的脚步了。本文项目代码获取地址Github：https://github.com/VincentWYJ/WXAppTrain.git；Blog file：http://files.cnblogs.com/files/tgyf/WXAppTrain.rar；"}
